Intel(R) Advisor can now assist with vectorization and show optimization
  report messages with your source code.
See "https://software.intel.com/en-us/intel-advisor-xe" for details.

Intel(R) Fortran Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 19.0.3.199 Build 20190206

Compiler options: -I/storage/home/hcodaman1/AMDTest/PACE-ProvBench/Application/Spack/packages/linux-rhel7-x86_64/intel-19.0.3/mvapich2-2.3.1-e6yqogu77jjh63n5tsj3mljad5hvx5e6/include -I/storage/home/hcodaman1/AMDTest/PACE-ProvBench/Application/Spack/packages/linux-rhel7-x86_64/intel-19.0.3/mvapich2-2.3.1-e6yqogu77jjh63n5tsj3mljad5hvx5e6/include -Xlinker -rpath=/storage/home/hcodaman1/AMDTest/PACE-ProvBench/Application/Spack/packages/linux-rhel7-x86_64/gcc-4.8.5/intel-parallel-studio-cluster.2019.3-3npq5qw6ri66bcpqgwzpeqjiqaddmlkl/compilers_and_libraries_2019.3.199/linux/compiler/lib/intel64 -axCOMMON-AVX512 -O3 -qopt-report=5 -march=core-avx2 -fma -ftz -fomit-frame-pointer -ipo -no-prec-div -fp-model fast=2 -o les3d.x -L/storage/home/hcodaman1/AMDTest/PACE-ProvBench/Application/Spack/packages/linux-rhel7-x86_64/intel-19.0.3/mvapich2-2.3.1-e6yqogu77jjh63n5tsj3mljad5hvx5e6/lib -lmpifort -Wl,-rpath -Wl,/storage/home/hcodaman1/AMDTest/PACE-ProvBench/Application/Spack/packages/linux-rhel7-x86_64/intel-19.0.3/mvapich2-2.3.1-e6yqogu77jjh63n5tsj3mljad5hvx5e6/lib -lmpi

    Report from: Interprocedural optimizations [ipo]

  WHOLE PROGRAM (SAFE) [EITHER METHOD]: true
  WHOLE PROGRAM (SEEN) [TABLE METHOD]: false
  WHOLE PROGRAM (READ) [OBJECT READER METHOD]: true

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: disabled
  -inline-max-per-compile: disabled

In the inlining report below:
   "sz" refers to the "size" of the routine. The smaller a routine's size,
      the more likely it is to be inlined.
   "isz" refers to the "inlined size" of the routine. This is the amount
      the calling routine will grow if the called routine is inlined into it.
      The compiler generally limits the amount a routine can grow by having
      routines inlined into it.

Begin optimization report for: LES3D

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (LES3D) [1/38=2.6%] main.f(1,15)
  -> EXTERN: (1,15) for_set_reentrancy
  -> EXTERN: (1,15) for_set_fpe_
  -> EXTERN: (32,12) mpi_init_
  -> EXTERN: (33,12) mpi_comm_size_
  -> EXTERN: (34,12) mpi_comm_rank_
  -> EXTERN: (38,13) for_open
  -> EXTERN: (39,13) for_read_seq_lis
  -> EXTERN: (40,13) for_read_seq_lis
  -> EXTERN: (40,13) for_read_seq_lis_xmit
  -> EXTERN: (41,13) for_read_seq_lis
  -> EXTERN: (42,13) for_read_seq_lis
  -> EXTERN: (42,13) for_read_seq_lis_xmit
  -> EXTERN: (42,13) for_read_seq_lis_xmit
  -> EXTERN: (43,13) for_read_seq_lis
  -> EXTERN: (44,13) for_read_seq_lis
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (51,13) for_read_seq_lis
  -> EXTERN: (52,13) for_read_seq_lis
  -> EXTERN: (52,13) for_read_seq_lis_xmit
  -> EXTERN: (55,34) log10
  -> EXTERN: (62,13) for_read_seq_lis
  -> EXTERN: (63,13) for_read_seq_lis
  -> EXTERN: (63,13) for_read_seq_lis_xmit
  -> EXTERN: (63,13) for_read_seq_lis_xmit
  -> EXTERN: (64,13) for_read_seq_lis
  -> EXTERN: (65,13) for_read_seq_lis
  -> EXTERN: (65,13) for_read_seq_lis_xmit
  -> EXTERN: (65,13) for_read_seq_lis_xmit
  -> EXTERN: (66,13) for_read_seq_lis
  -> EXTERN: (67,13) for_read_seq_lis
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (69,19) for_close
  -> EXTERN: (71,15) mpi_barrier_
  -> INLINE: (77,12) EJECT (isz = 24) (sz = 31)
    -> EXTERN: (364,7) for_write_seq_fmt
    -> EXTERN: (365,12) mpi_abort_
    -> EXTERN: (367,7) for_stop_core
  -> INLINE: (83,12) GRIDMAP (isz = 570) (sz = 573)
    -> EXTERN: parallel.f:(165,19) log
    -> INLINE: parallel.f:(177,33) MAP (isz = 46) (sz = 61)
    -> INLINE: parallel.f:(179,33) MAP (isz = 46) (sz = 61)
    -> INLINE: parallel.f:(181,33) MAP (isz = 46) (sz = 61)
    -> EXTERN: parallel.f:(205,17) log
    -> EXTERN: parallel.f:(206,12) mpi_barrier_
    -> EXTERN: parallel.f:(207,14) f_pow2i
    -> EXTERN: parallel.f:(208,17) log
    -> EXTERN: parallel.f:(209,14) f_pow2i
    -> EXTERN: parallel.f:(211,12) mpi_barrier_
    -> EXTERN: parallel.f:(212,21) for_write_seq_lis_xmit
    -> EXTERN: parallel.f:(212,21) for_write_seq_lis
    -> EXTERN: parallel.f:(212,21) for_write_seq_lis_xmit
    -> EXTERN: parallel.f:(212,21) for_write_seq_lis_xmit
    -> parallel.f:(230,12) MAP (isz = 46) (sz = 61)
       [[ Callee not marked with inlining directive  <1>]]
    -> parallel.f:(231,12) MAP (isz = 46) (sz = 61)
       [[ Callee not marked with inlining directive  <1>]]
    -> parallel.f:(232,12) MAP (isz = 46) (sz = 61)
       [[ Callee not marked with inlining directive  <1>]]
  -> (89,12) ALLOC (isz = 5384) (sz = 5387)
     [[ Inlining would exceed -inline-max-size value (5387>230) <2>]]
  -> (91,12) GRID (isz = 4373) (sz = 4376)
     [[ Inlining would exceed -inline-max-size value (4376>230) <2>]]
  -> INLINE: (93,12) SETIV (isz = 865) (sz = 868)
    -> EXTERN: setiv.f:(92,33) pow
    -> setiv.f:(109,12) TML (isz = 4626) (sz = 4629)
       [[ Inlining would exceed -inline-max-size value (4629>230) <2>]]
    -> INLINE: setiv.f:(115,21) THERMAL_PROPS (isz = 91) (sz = 112)
  -> (95,12) FLOWIO (isz = 2102) (sz = 2105)
     [[ Inlining would exceed -inline-max-size value (2105>230) <2>]]
  -> EXTERN: (97,12) mpi_barrier_
  -> (105,15) PARALLEL (isz = 231) (sz = 236)
     [[ Inlining would exceed -inline-max-size value (236>230) <2>]]
  -> EXTERN: (110,10) for_write_seq_fmt
  -> EXTERN: (111,10) for_write_seq_fmt
  -> EXTERN: (111,10) for_write_seq_fmt_xmit
  -> EXTERN: (111,10) for_write_seq_fmt_xmit
  -> EXTERN: (115,10) for_write_seq_fmt
  -> EXTERN: (115,10) for_write_seq_fmt_xmit
  -> EXTERN: (115,10) for_write_seq_fmt_xmit
  -> EXTERN: (119,10) for_write_seq_fmt
  -> EXTERN: (120,10) for_write_seq_fmt
  -> EXTERN: (120,10) for_write_seq_fmt_xmit
  -> EXTERN: (121,10) for_write_seq_fmt
  -> EXTERN: (121,10) for_write_seq_fmt_xmit
  -> EXTERN: (122,10) for_write_seq_fmt
  -> EXTERN: (122,10) for_write_seq_fmt_xmit
  -> EXTERN: (123,10) for_write_seq_fmt
  -> EXTERN: (123,10) for_write_seq_fmt_xmit
  -> EXTERN: (124,10) for_write_seq_fmt
  -> EXTERN: (124,10) for_write_seq_fmt_xmit
  -> EXTERN: (126,10) for_write_seq_fmt
  -> EXTERN: (127,10) for_write_seq_fmt
  -> EXTERN: (129,13) for_write_seq_fmt
  -> EXTERN: (133,10) for_write_seq_fmt
  -> EXTERN: (134,10) for_write_seq_fmt
  -> EXTERN: (135,10) for_write_seq_fmt
  -> EXTERN: (136,10) for_write_seq_fmt
  -> EXTERN: (137,10) for_write_seq_fmt
  -> EXTERN: (138,10) for_write_seq_fmt
  -> EXTERN: (139,10) for_write_seq_lis
  -> EXTERN: (152,12) mpi_barrier_
  -> (158,15) PARALLEL (isz = 231) (sz = 236)
     [[ Inlining would exceed -inline-max-size value (236>230) <2>]]
  -> (161,12) SETBC (isz = 1873) (sz = 1876)
     [[ Inlining would exceed -inline-max-size value (1876>230) <2>]]
  -> EXTERN: (166,10) for_check_mult_overflow64
  -> EXTERN: (166,10) for_alloc_allocatable
  -> EXTERN: (174,10) for_open
  -> EXTERN: (177,16) mpi_wtime_
  -> (179,12) TMSTEP (isz = 676) (sz = 683)
     [[ Inlining would exceed -inline-max-size value (683>230) <2>]]
  -> (184,36) TMSTEP (isz = 676) (sz = 683)
     [[ Inlining would exceed -inline-max-size value (683>230) <2>]]
  -> (187,17) ANALYSIS (isz = 883) (sz = 890)
     [[ Inlining would exceed -inline-max-total-size value (2789>2000) <3>]]
  -> EXTERN: (190,12) for_write_seq_fmt
  -> EXTERN: (190,12) for_write_seq_fmt_xmit
  -> EXTERN: (190,12) for_write_seq_fmt_xmit
  -> EXTERN: (190,12) for_write_seq_fmt_xmit
  -> EXTERN: (190,12) for_write_seq_fmt_xmit
  -> EXTERN: (191,12) for_write_seq_fmt
  -> EXTERN: (191,12) for_write_seq_fmt_xmit
  -> INLINE: (201,17) EJECT (isz = 24) (sz = 31)
    -> EXTERN: (364,7) for_write_seq_fmt
    -> EXTERN: (365,12) mpi_abort_
    -> EXTERN: (367,7) for_stop_core
  -> (241,17) FLUXI (isz = 1947) (sz = 1950)
     [[ Inlining would exceed -inline-max-size value (1950>230) <2>]]
  -> (243,17) FLUXJ (isz = 2691) (sz = 2694)
     [[ Inlining would exceed -inline-max-size value (2694>230) <2>]]
  -> (245,31) FLUXK (isz = 2691) (sz = 2694)
     [[ Inlining would exceed -inline-max-size value (2694>230) <2>]]
  -> INLINE: (252,17) UPDATE (isz = 423) (sz = 426)
  -> (274,20) PARALLEL (isz = 231) (sz = 236)
     [[ Inlining would exceed -inline-max-size value (236>230) <2>]]
  -> (278,17) SETBC (isz = 1873) (sz = 1876)
     [[ Inlining would exceed -inline-max-size value (1876>230) <2>]]
  -> EXTERN: (325,18) for_close
  -> EXTERN: (328,16) mpi_wtime_
  -> EXTERN: (331,12) mpi_reduce_
  -> EXTERN: (339,10) for_write_seq_lis_xmit
  -> EXTERN: (339,10) for_write_seq_lis
  -> EXTERN: (340,10) for_write_seq_fmt
  -> EXTERN: (340,10) for_write_seq_fmt_xmit
  -> EXTERN: (340,10) for_write_seq_fmt_xmit
  -> EXTERN: (340,10) for_write_seq_fmt_xmit
  -> EXTERN: (343,10) for_write_seq_fmt
  -> EXTERN: (349,27) for_dealloc_allocatable
  -> EXTERN: (350,12) mpi_finalize_


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at main.f(36,7)
   remark #15382: vectorization support: call to function for_open cannot be vectorized   [ main.f(38,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(39,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(40,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(40,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(41,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(42,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(42,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(42,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(43,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(51,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(52,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(52,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(62,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(63,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(63,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(63,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(64,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(65,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(65,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(65,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(66,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_close cannot be vectorized   [ main.f(69,19) ]
   remark #15382: vectorization support: call to function mpi_barrier_ cannot be vectorized   [ main.f(71,15) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (38:13) and at (69:19)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (69:19) and at (38:13)
LOOP END

LOOP BEGIN at parallel.f(168,7) inlined into main.f(83,12)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at parallel.f(169,10) inlined into main.f(83,12)
      remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

      LOOP BEGIN at parallel.f(170,13) inlined into main.f(83,12)
         remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

         LOOP BEGIN at parallel.f(174,19) inlined into main.f(83,12)
            remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
            remark #25452: Original Order found to be proper, but by a close margin
            remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

            LOOP BEGIN at parallel.f(175,22) inlined into main.f(83,12)
               remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
               remark #25452: Original Order found to be proper, but by a close margin
               remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

               LOOP BEGIN at parallel.f(176,25) inlined into main.f(83,12)
               <Predicate Optimized v2>
                  remark #25084: Preprocess Loopnests: Moving Out Store    [ parallel.f(178,28) ]
                  remark #25084: Preprocess Loopnests: Moving Out Store    [ parallel.f(180,28) ]
                  remark #25084: Preprocess Loopnests: Moving Out Store    [ parallel.f(182,28) ]
                  remark #25422: Invariant Condition at line 277 hoisted out of this loop
                  remark #25422: Invariant Condition at line 277 hoisted out of this loop
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (268:7) and istart (274:10)
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (274:10) and istart (268:7)
               LOOP END

               LOOP BEGIN at parallel.f(176,25) inlined into main.f(83,12)
               <Predicate Optimized v3>
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (268:7) and istart (274:10)
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (274:10) and istart (268:7)
               LOOP END

               LOOP BEGIN at parallel.f(176,25) inlined into main.f(83,12)
               <Predicate Optimized v3>
                  remark #25422: Invariant Condition at line 277 hoisted out of this loop
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (268:7) and istart (274:10)
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (274:10) and istart (268:7)
               LOOP END

               LOOP BEGIN at parallel.f(176,25) inlined into main.f(83,12)
               <Predicate Optimized v4>
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (268:7) and istart (274:10)
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (274:10) and istart (268:7)
               LOOP END
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(24,9) inlined into main.f(93,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(24,9) inlined into main.f(93,12)
      remark #25101: Loop Interchange not done due to: Original Order seems proper
      remark #25452: Original Order found to be proper, but by a close margin
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(25,11) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(26,13) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,1,ll) has unaligned access   [ setiv.f(27,15) ]
            remark #15389: vectorization support: reference dq_(i,j,k,1) has unaligned access   [ setiv.f(28,15) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: PEEL LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(26,13) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,1,ll) has unaligned access   [ setiv.f(27,15) ]
            remark #15388: vectorization support: reference dq_(i,j,k,1) has aligned access   [ setiv.f(28,15) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.722
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(26,13) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,1,ll) has unaligned access   [ setiv.f(27,15) ]
            remark #15389: vectorization support: reference dq_(i,j,k,1) has unaligned access   [ setiv.f(28,15) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END
   LOOP END

   LOOP BEGIN at setiv.f(33,11) inlined into main.f(93,12)
      remark #25461: Imperfect Loop Unroll-Jammed by 4   (pre-vector) 
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(34,13) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: PEEL LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15388: vectorization support: reference dq_(i,j,k,lm) has aligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.722
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END

      LOOP BEGIN at setiv.f(34,13) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: PEEL LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15388: vectorization support: reference dq_(i,j,k,lm) has aligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.722
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END

      LOOP BEGIN at setiv.f(34,13) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: PEEL LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15388: vectorization support: reference dq_(i,j,k,lm) has aligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.722
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END

      LOOP BEGIN at setiv.f(34,13) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: PEEL LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15388: vectorization support: reference dq_(i,j,k,lm) has aligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.722
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(44,7) inlined into main.f(93,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(45,9) inlined into main.f(93,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(46,11) inlined into main.f(93,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(47,13) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(48,13) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(49,13) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ setiv.f(50,13) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ setiv.f(51,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.644
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 16 
         remark #15477: vector cost: 3.370 
         remark #15478: estimated potential speedup: 4.340 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(46,11) inlined into main.f(93,12)
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(47,13) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(48,13) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(49,13) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ setiv.f(50,13) ]
         remark #15388: vectorization support: reference t_(i,j,k) has aligned access   [ setiv.f(51,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.463
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 16 
         remark #15477: vector cost: 3.370 
         remark #15478: estimated potential speedup: 4.340 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(46,11) inlined into main.f(93,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(47,13) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(48,13) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(49,13) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ setiv.f(50,13) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ setiv.f(51,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.644
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 16 
         remark #15477: vector cost: 3.370 
         remark #15478: estimated potential speedup: 4.340 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(98,7) inlined into main.f(93,12)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(99,9) inlined into main.f(93,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(100,11) inlined into main.f(93,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ setiv.f(101,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ setiv.f(102,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ setiv.f(103,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ setiv.f(104,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.622
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
      LOOP END

      LOOP BEGIN at setiv.f(100,11) inlined into main.f(93,12)
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ setiv.f(101,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ setiv.f(102,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ setiv.f(103,13) ]
         remark #15388: vectorization support: reference hf_(i,j,k,4) has aligned access   [ setiv.f(104,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.452
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 2.620 
         remark #15478: estimated potential speedup: 4.190 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(100,11) inlined into main.f(93,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ setiv.f(101,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ setiv.f(102,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ setiv.f(103,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ setiv.f(104,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.622
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(111,7) inlined into main.f(93,12)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between cp(:,j,k) (17:10) and hf_(i,j,k,4) (122:16)
   remark #15346: vector dependence: assumed ANTI dependence between hf_(i,j,k,4) (122:16) and cp(:,j,k) (17:10)

   LOOP BEGIN at setiv.f(112,10) inlined into main.f(93,12)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed FLOW dependence between cp(:,j,k) (17:10) and hf_(i,j,k,4) (122:16)
      remark #15346: vector dependence: assumed ANTI dependence between hf_(i,j,k,4) (122:16) and cp(:,j,k) (17:10)

      LOOP BEGIN at setiv.f(113,13) inlined into main.f(93,12)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed FLOW dependence between cp(:,j,k) (17:10) and hf_(i,j,k,4) (122:16)
         remark #15346: vector dependence: assumed ANTI dependence between hf_(i,j,k,4) (122:16) and cp(:,j,k) (17:10)

         LOOP BEGIN at props.f(17,10) inlined into main.f(93,12)
            remark #25045: Fused Loops: ( 17 18 19 )

            remark #25436: completely unrolled by 1   (pre-vector) 
         LOOP END

         LOOP BEGIN at props.f(18,10) inlined into main.f(93,12)
            remark #25046: Loop lost in Fusion 
         LOOP END

         LOOP BEGIN at props.f(19,10) inlined into main.f(93,12)
            remark #25046: Loop lost in Fusion 
         LOOP END

         LOOP BEGIN at setiv.f(128,16) inlined into main.f(93,12)
            remark #25436: completely unrolled by 5   (pre-vector) 
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at main.f(167,10)
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(167,10)
      remark #15389: vectorization support: reference WORK(:) has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 0.500
      remark #15300: LOOP WAS VECTORIZED
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 0.750 
      remark #15478: estimated potential speedup: 1.710 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at main.f(167,10)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference WORK(:) has aligned access
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.222
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 0.750 
      remark #15478: estimated potential speedup: 1.710 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(181,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(236,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at update.f(14,7) inlined into main.f(252,17)
         remark #25101: Loop Interchange not done due to: Original Order seems proper
         remark #25452: Original Order found to be proper, but by a close margin
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at update.f(15,10) inlined into main.f(252,17)
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Peeled loop for vectorization, Predicate Optimized v1>
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.156
               remark #15301: PEEL LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 28 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 233 
               remark #15477: vector cost: 36.500 
               remark #15478: estimated potential speedup: 5.920 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Predicate Optimized v1>
               remark #25422: Invariant Condition at line 18 hoisted out of this loop
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.359
               remark #15300: LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 23 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 210 
               remark #15477: vector cost: 32.750 
               remark #15478: estimated potential speedup: 5.950 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
               remark #25456: Number of Array Refs Scalar Replaced In Loop: 7

               LOOP BEGIN at update.f(19,19) inlined into main.f(252,17)
                  remark #25436: completely unrolled by 5   (pre-vector) 
               LOOP END

               LOOP BEGIN at update.f(21,19) inlined into main.f(252,17)
                  remark #25436: completely unrolled by 5   (pre-vector) 
               LOOP END
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Remainder loop for vectorization, Predicate Optimized v1>
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.156
               remark #15301: REMAINDER LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 28 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 233 
               remark #15477: vector cost: 36.500 
               remark #15478: estimated potential speedup: 5.920 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Peeled loop for vectorization, Predicate Optimized v2>
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.163
               remark #15301: PEEL LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 28 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 233 
               remark #15477: vector cost: 36.500 
               remark #15478: estimated potential speedup: 5.920 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Predicate Optimized v2>
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.373
               remark #15300: LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 28 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 233 
               remark #15477: vector cost: 36.500 
               remark #15478: estimated potential speedup: 5.920 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
               remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Remainder loop for vectorization, Predicate Optimized v2>
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.163
               remark #15301: REMAINDER LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 28 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 233 
               remark #15477: vector cost: 36.500 
               remark #15478: estimated potential speedup: 5.920 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END


Non-optimizable loops:


LOOP BEGIN at main.f(76,7)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

main.f(1,15):remark #34051: REGISTER ALLOCATION : [MAIN__] main.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdx]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: LES3D [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (LES3D) [1/38=2.6%] main.f(1,15)
  -> EXTERN: (1,15) for_set_reentrancy
  -> EXTERN: (1,15) for_set_fpe_
  -> EXTERN: (32,12) mpi_init_
  -> EXTERN: (33,12) mpi_comm_size_
  -> EXTERN: (34,12) mpi_comm_rank_
  -> EXTERN: (38,13) for_open
  -> EXTERN: (39,13) for_read_seq_lis
  -> EXTERN: (40,13) for_read_seq_lis
  -> EXTERN: (40,13) for_read_seq_lis_xmit
  -> EXTERN: (41,13) for_read_seq_lis
  -> EXTERN: (42,13) for_read_seq_lis
  -> EXTERN: (42,13) for_read_seq_lis_xmit
  -> EXTERN: (42,13) for_read_seq_lis_xmit
  -> EXTERN: (43,13) for_read_seq_lis
  -> EXTERN: (44,13) for_read_seq_lis
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (51,13) for_read_seq_lis
  -> EXTERN: (52,13) for_read_seq_lis
  -> EXTERN: (52,13) for_read_seq_lis_xmit
  -> EXTERN: (55,34) log10
  -> EXTERN: (62,13) for_read_seq_lis
  -> EXTERN: (63,13) for_read_seq_lis
  -> EXTERN: (63,13) for_read_seq_lis_xmit
  -> EXTERN: (63,13) for_read_seq_lis_xmit
  -> EXTERN: (64,13) for_read_seq_lis
  -> EXTERN: (65,13) for_read_seq_lis
  -> EXTERN: (65,13) for_read_seq_lis_xmit
  -> EXTERN: (65,13) for_read_seq_lis_xmit
  -> EXTERN: (66,13) for_read_seq_lis
  -> EXTERN: (67,13) for_read_seq_lis
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (69,19) for_close
  -> EXTERN: (71,15) mpi_barrier_
  -> INLINE: (77,12) EJECT (isz = 24) (sz = 31)
    -> EXTERN: (364,7) for_write_seq_fmt
    -> EXTERN: (365,12) mpi_abort_
    -> EXTERN: (367,7) for_stop_core
  -> INLINE: (83,12) GRIDMAP (isz = 570) (sz = 573)
    -> EXTERN: parallel.f:(165,19) log
    -> INLINE: parallel.f:(177,33) MAP (isz = 46) (sz = 61)
    -> INLINE: parallel.f:(179,33) MAP (isz = 46) (sz = 61)
    -> INLINE: parallel.f:(181,33) MAP (isz = 46) (sz = 61)
    -> EXTERN: parallel.f:(205,17) log
    -> EXTERN: parallel.f:(206,12) mpi_barrier_
    -> EXTERN: parallel.f:(207,14) f_pow2i
    -> EXTERN: parallel.f:(208,17) log
    -> EXTERN: parallel.f:(209,14) f_pow2i
    -> EXTERN: parallel.f:(211,12) mpi_barrier_
    -> EXTERN: parallel.f:(212,21) for_write_seq_lis_xmit
    -> EXTERN: parallel.f:(212,21) for_write_seq_lis
    -> EXTERN: parallel.f:(212,21) for_write_seq_lis_xmit
    -> EXTERN: parallel.f:(212,21) for_write_seq_lis_xmit
    -> parallel.f:(230,12) MAP (isz = 46) (sz = 61)
       [[ Callee not marked with inlining directive  <1>]]
    -> parallel.f:(231,12) MAP (isz = 46) (sz = 61)
       [[ Callee not marked with inlining directive  <1>]]
    -> parallel.f:(232,12) MAP (isz = 46) (sz = 61)
       [[ Callee not marked with inlining directive  <1>]]
  -> (89,12) ALLOC (isz = 5384) (sz = 5387)
     [[ Inlining would exceed -inline-max-size value (5387>230) <2>]]
  -> (91,12) GRID (isz = 4373) (sz = 4376)
     [[ Inlining would exceed -inline-max-size value (4376>230) <2>]]
  -> INLINE: (93,12) SETIV (isz = 865) (sz = 868)
    -> EXTERN: setiv.f:(92,33) pow
    -> setiv.f:(109,12) TML (isz = 4626) (sz = 4629)
       [[ Inlining would exceed -inline-max-size value (4629>230) <2>]]
    -> INLINE: setiv.f:(115,21) THERMAL_PROPS (isz = 91) (sz = 112)
  -> (95,12) FLOWIO (isz = 2102) (sz = 2105)
     [[ Inlining would exceed -inline-max-size value (2105>230) <2>]]
  -> EXTERN: (97,12) mpi_barrier_
  -> (105,15) PARALLEL (isz = 231) (sz = 236)
     [[ Inlining would exceed -inline-max-size value (236>230) <2>]]
  -> EXTERN: (110,10) for_write_seq_fmt
  -> EXTERN: (111,10) for_write_seq_fmt
  -> EXTERN: (111,10) for_write_seq_fmt_xmit
  -> EXTERN: (111,10) for_write_seq_fmt_xmit
  -> EXTERN: (115,10) for_write_seq_fmt
  -> EXTERN: (115,10) for_write_seq_fmt_xmit
  -> EXTERN: (115,10) for_write_seq_fmt_xmit
  -> EXTERN: (119,10) for_write_seq_fmt
  -> EXTERN: (120,10) for_write_seq_fmt
  -> EXTERN: (120,10) for_write_seq_fmt_xmit
  -> EXTERN: (121,10) for_write_seq_fmt
  -> EXTERN: (121,10) for_write_seq_fmt_xmit
  -> EXTERN: (122,10) for_write_seq_fmt
  -> EXTERN: (122,10) for_write_seq_fmt_xmit
  -> EXTERN: (123,10) for_write_seq_fmt
  -> EXTERN: (123,10) for_write_seq_fmt_xmit
  -> EXTERN: (124,10) for_write_seq_fmt
  -> EXTERN: (124,10) for_write_seq_fmt_xmit
  -> EXTERN: (126,10) for_write_seq_fmt
  -> EXTERN: (127,10) for_write_seq_fmt
  -> EXTERN: (129,13) for_write_seq_fmt
  -> EXTERN: (133,10) for_write_seq_fmt
  -> EXTERN: (134,10) for_write_seq_fmt
  -> EXTERN: (135,10) for_write_seq_fmt
  -> EXTERN: (136,10) for_write_seq_fmt
  -> EXTERN: (137,10) for_write_seq_fmt
  -> EXTERN: (138,10) for_write_seq_fmt
  -> EXTERN: (139,10) for_write_seq_lis
  -> EXTERN: (152,12) mpi_barrier_
  -> (158,15) PARALLEL (isz = 231) (sz = 236)
     [[ Inlining would exceed -inline-max-size value (236>230) <2>]]
  -> (161,12) SETBC (isz = 1873) (sz = 1876)
     [[ Inlining would exceed -inline-max-size value (1876>230) <2>]]
  -> EXTERN: (166,10) for_check_mult_overflow64
  -> EXTERN: (166,10) for_alloc_allocatable
  -> EXTERN: (174,10) for_open
  -> EXTERN: (177,16) mpi_wtime_
  -> (179,12) TMSTEP (isz = 676) (sz = 683)
     [[ Inlining would exceed -inline-max-size value (683>230) <2>]]
  -> (184,36) TMSTEP (isz = 676) (sz = 683)
     [[ Inlining would exceed -inline-max-size value (683>230) <2>]]
  -> (187,17) ANALYSIS (isz = 883) (sz = 890)
     [[ Inlining would exceed -inline-max-total-size value (2789>2000) <3>]]
  -> EXTERN: (190,12) for_write_seq_fmt
  -> EXTERN: (190,12) for_write_seq_fmt_xmit
  -> EXTERN: (190,12) for_write_seq_fmt_xmit
  -> EXTERN: (190,12) for_write_seq_fmt_xmit
  -> EXTERN: (190,12) for_write_seq_fmt_xmit
  -> EXTERN: (191,12) for_write_seq_fmt
  -> EXTERN: (191,12) for_write_seq_fmt_xmit
  -> INLINE: (201,17) EJECT (isz = 24) (sz = 31)
    -> EXTERN: (364,7) for_write_seq_fmt
    -> EXTERN: (365,12) mpi_abort_
    -> EXTERN: (367,7) for_stop_core
  -> (241,17) FLUXI (isz = 1947) (sz = 1950)
     [[ Inlining would exceed -inline-max-size value (1950>230) <2>]]
  -> (243,17) FLUXJ (isz = 2691) (sz = 2694)
     [[ Inlining would exceed -inline-max-size value (2694>230) <2>]]
  -> (245,31) FLUXK (isz = 2691) (sz = 2694)
     [[ Inlining would exceed -inline-max-size value (2694>230) <2>]]
  -> INLINE: (252,17) UPDATE (isz = 423) (sz = 426)
  -> (274,20) PARALLEL (isz = 231) (sz = 236)
     [[ Inlining would exceed -inline-max-size value (236>230) <2>]]
  -> (278,17) SETBC (isz = 1873) (sz = 1876)
     [[ Inlining would exceed -inline-max-size value (1876>230) <2>]]
  -> EXTERN: (325,18) for_close
  -> EXTERN: (328,16) mpi_wtime_
  -> EXTERN: (331,12) mpi_reduce_
  -> EXTERN: (339,10) for_write_seq_lis_xmit
  -> EXTERN: (339,10) for_write_seq_lis
  -> EXTERN: (340,10) for_write_seq_fmt
  -> EXTERN: (340,10) for_write_seq_fmt_xmit
  -> EXTERN: (340,10) for_write_seq_fmt_xmit
  -> EXTERN: (340,10) for_write_seq_fmt_xmit
  -> EXTERN: (343,10) for_write_seq_fmt
  -> EXTERN: (349,27) for_dealloc_allocatable
  -> EXTERN: (350,12) mpi_finalize_


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at main.f(36,7)
   remark #15382: vectorization support: call to function for_open cannot be vectorized   [ main.f(38,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(39,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(40,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(40,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(41,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(42,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(42,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(42,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(43,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(51,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(52,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(52,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(62,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(63,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(63,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(63,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(64,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(65,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(65,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(65,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(66,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_close cannot be vectorized   [ main.f(69,19) ]
   remark #15382: vectorization support: call to function mpi_barrier_ cannot be vectorized   [ main.f(71,15) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (38:13) and at (69:19)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (69:19) and at (38:13)
LOOP END

LOOP BEGIN at parallel.f(168,7) inlined into main.f(83,12)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at parallel.f(169,10) inlined into main.f(83,12)
      remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

      LOOP BEGIN at parallel.f(170,13) inlined into main.f(83,12)
         remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

         LOOP BEGIN at parallel.f(174,19) inlined into main.f(83,12)
            remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
            remark #25452: Original Order found to be proper, but by a close margin
            remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

            LOOP BEGIN at parallel.f(175,22) inlined into main.f(83,12)
               remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
               remark #25452: Original Order found to be proper, but by a close margin
               remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

               LOOP BEGIN at parallel.f(176,25) inlined into main.f(83,12)
               <Predicate Optimized v2>
                  remark #25084: Preprocess Loopnests: Moving Out Store    [ parallel.f(178,28) ]
                  remark #25084: Preprocess Loopnests: Moving Out Store    [ parallel.f(180,28) ]
                  remark #25084: Preprocess Loopnests: Moving Out Store    [ parallel.f(182,28) ]
                  remark #25422: Invariant Condition at line 277 hoisted out of this loop
                  remark #25422: Invariant Condition at line 277 hoisted out of this loop
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (268:7) and istart (274:10)
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (274:10) and istart (268:7)
               LOOP END

               LOOP BEGIN at parallel.f(176,25) inlined into main.f(83,12)
               <Predicate Optimized v3>
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (268:7) and istart (274:10)
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (274:10) and istart (268:7)
               LOOP END

               LOOP BEGIN at parallel.f(176,25) inlined into main.f(83,12)
               <Predicate Optimized v3>
                  remark #25422: Invariant Condition at line 277 hoisted out of this loop
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (268:7) and istart (274:10)
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (274:10) and istart (268:7)
               LOOP END

               LOOP BEGIN at parallel.f(176,25) inlined into main.f(83,12)
               <Predicate Optimized v4>
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (268:7) and istart (274:10)
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (274:10) and istart (268:7)
               LOOP END
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(24,9) inlined into main.f(93,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(24,9) inlined into main.f(93,12)
      remark #25101: Loop Interchange not done due to: Original Order seems proper
      remark #25452: Original Order found to be proper, but by a close margin
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(25,11) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(26,13) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,1,ll) has unaligned access   [ setiv.f(27,15) ]
            remark #15389: vectorization support: reference dq_(i,j,k,1) has unaligned access   [ setiv.f(28,15) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: PEEL LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(26,13) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,1,ll) has unaligned access   [ setiv.f(27,15) ]
            remark #15388: vectorization support: reference dq_(i,j,k,1) has aligned access   [ setiv.f(28,15) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.722
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(26,13) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,1,ll) has unaligned access   [ setiv.f(27,15) ]
            remark #15389: vectorization support: reference dq_(i,j,k,1) has unaligned access   [ setiv.f(28,15) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END
   LOOP END

   LOOP BEGIN at setiv.f(33,11) inlined into main.f(93,12)
      remark #25461: Imperfect Loop Unroll-Jammed by 4   (pre-vector) 
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(34,13) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: PEEL LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15388: vectorization support: reference dq_(i,j,k,lm) has aligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.722
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END

      LOOP BEGIN at setiv.f(34,13) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: PEEL LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15388: vectorization support: reference dq_(i,j,k,lm) has aligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.722
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END

      LOOP BEGIN at setiv.f(34,13) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: PEEL LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15388: vectorization support: reference dq_(i,j,k,lm) has aligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.722
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END

      LOOP BEGIN at setiv.f(34,13) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: PEEL LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15388: vectorization support: reference dq_(i,j,k,lm) has aligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.722
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.810
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 4.820 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(44,7) inlined into main.f(93,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(45,9) inlined into main.f(93,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(46,11) inlined into main.f(93,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(47,13) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(48,13) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(49,13) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ setiv.f(50,13) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ setiv.f(51,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.644
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 16 
         remark #15477: vector cost: 3.370 
         remark #15478: estimated potential speedup: 4.340 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(46,11) inlined into main.f(93,12)
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(47,13) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(48,13) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(49,13) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ setiv.f(50,13) ]
         remark #15388: vectorization support: reference t_(i,j,k) has aligned access   [ setiv.f(51,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.463
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 16 
         remark #15477: vector cost: 3.370 
         remark #15478: estimated potential speedup: 4.340 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(46,11) inlined into main.f(93,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(47,13) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(48,13) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(49,13) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ setiv.f(50,13) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ setiv.f(51,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.644
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 16 
         remark #15477: vector cost: 3.370 
         remark #15478: estimated potential speedup: 4.340 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(98,7) inlined into main.f(93,12)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(99,9) inlined into main.f(93,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(100,11) inlined into main.f(93,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ setiv.f(101,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ setiv.f(102,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ setiv.f(103,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ setiv.f(104,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.622
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
      LOOP END

      LOOP BEGIN at setiv.f(100,11) inlined into main.f(93,12)
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ setiv.f(101,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ setiv.f(102,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ setiv.f(103,13) ]
         remark #15388: vectorization support: reference hf_(i,j,k,4) has aligned access   [ setiv.f(104,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.452
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 2.620 
         remark #15478: estimated potential speedup: 4.190 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(100,11) inlined into main.f(93,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ setiv.f(101,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ setiv.f(102,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ setiv.f(103,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ setiv.f(104,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.622
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(111,7) inlined into main.f(93,12)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between cp(:,j,k) (17:10) and hf_(i,j,k,4) (122:16)
   remark #15346: vector dependence: assumed ANTI dependence between hf_(i,j,k,4) (122:16) and cp(:,j,k) (17:10)

   LOOP BEGIN at setiv.f(112,10) inlined into main.f(93,12)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed FLOW dependence between cp(:,j,k) (17:10) and hf_(i,j,k,4) (122:16)
      remark #15346: vector dependence: assumed ANTI dependence between hf_(i,j,k,4) (122:16) and cp(:,j,k) (17:10)

      LOOP BEGIN at setiv.f(113,13) inlined into main.f(93,12)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed FLOW dependence between cp(:,j,k) (17:10) and hf_(i,j,k,4) (122:16)
         remark #15346: vector dependence: assumed ANTI dependence between hf_(i,j,k,4) (122:16) and cp(:,j,k) (17:10)

         LOOP BEGIN at props.f(17,10) inlined into main.f(93,12)
            remark #25045: Fused Loops: ( 17 18 19 )

            remark #25436: completely unrolled by 1   (pre-vector) 
         LOOP END

         LOOP BEGIN at props.f(18,10) inlined into main.f(93,12)
            remark #25046: Loop lost in Fusion 
         LOOP END

         LOOP BEGIN at props.f(19,10) inlined into main.f(93,12)
            remark #25046: Loop lost in Fusion 
         LOOP END

         LOOP BEGIN at setiv.f(128,16) inlined into main.f(93,12)
            remark #25436: completely unrolled by 5   (pre-vector) 
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at main.f(167,10)
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(167,10)
      remark #15389: vectorization support: reference WORK(:) has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 0.500
      remark #15300: LOOP WAS VECTORIZED
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 0.750 
      remark #15478: estimated potential speedup: 1.710 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at main.f(167,10)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference WORK(:) has aligned access
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.222
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 0.750 
      remark #15478: estimated potential speedup: 1.710 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(181,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(236,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at update.f(14,7) inlined into main.f(252,17)
         remark #25101: Loop Interchange not done due to: Original Order seems proper
         remark #25452: Original Order found to be proper, but by a close margin
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at update.f(15,10) inlined into main.f(252,17)
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Peeled loop for vectorization, Predicate Optimized v1>
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.156
               remark #15301: PEEL LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 28 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 233 
               remark #15477: vector cost: 36.500 
               remark #15478: estimated potential speedup: 5.920 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Predicate Optimized v1>
               remark #25422: Invariant Condition at line 18 hoisted out of this loop
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.359
               remark #15300: LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 23 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 210 
               remark #15477: vector cost: 32.750 
               remark #15478: estimated potential speedup: 5.950 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
               remark #25456: Number of Array Refs Scalar Replaced In Loop: 7

               LOOP BEGIN at update.f(19,19) inlined into main.f(252,17)
                  remark #25436: completely unrolled by 5   (pre-vector) 
               LOOP END

               LOOP BEGIN at update.f(21,19) inlined into main.f(252,17)
                  remark #25436: completely unrolled by 5   (pre-vector) 
               LOOP END
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Remainder loop for vectorization, Predicate Optimized v1>
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.156
               remark #15301: REMAINDER LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 28 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 233 
               remark #15477: vector cost: 36.500 
               remark #15478: estimated potential speedup: 5.920 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Peeled loop for vectorization, Predicate Optimized v2>
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.163
               remark #15301: PEEL LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 28 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 233 
               remark #15477: vector cost: 36.500 
               remark #15478: estimated potential speedup: 5.920 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Predicate Optimized v2>
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.373
               remark #15300: LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 28 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 233 
               remark #15477: vector cost: 36.500 
               remark #15478: estimated potential speedup: 5.920 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
               remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Remainder loop for vectorization, Predicate Optimized v2>
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.163
               remark #15301: REMAINDER LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 28 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 233 
               remark #15477: vector cost: 36.500 
               remark #15478: estimated potential speedup: 5.920 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END


Non-optimizable loops:


LOOP BEGIN at main.f(76,7)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

main.f(167,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(167,10):remark #34026: call to memset implemented as a call to optimized library version
main.f(1,15):remark #34051: REGISTER ALLOCATION : [MAIN__.h] main.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   53[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm31 k1-k7]
        
    Routine temporaries
        Total         :    3228
            Global    :     928
            Local     :    2300
        Regenerable   :     822
        Spilled       :     541
        
    Routine stack
        Variables     :    1088 bytes*
            Reads     :       7 [6.38e+00 ~ 0.0%]
            Writes    :     148 [1.92e+02 ~ 0.0%]
        Spills        :    4240 bytes*
            Reads     :     927 [5.39e+05 ~ 24.7%]
            Writes    :     635 [7.75e+04 ~ 3.6%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: LES3D [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (LES3D) [1/38=2.6%] main.f(1,15)
  -> EXTERN: (1,15) for_set_reentrancy
  -> EXTERN: (1,15) for_set_fpe_
  -> EXTERN: (32,12) mpi_init_
  -> EXTERN: (33,12) mpi_comm_size_
  -> EXTERN: (34,12) mpi_comm_rank_
  -> EXTERN: (38,13) for_open
  -> EXTERN: (39,13) for_read_seq_lis
  -> EXTERN: (40,13) for_read_seq_lis
  -> EXTERN: (40,13) for_read_seq_lis_xmit
  -> EXTERN: (41,13) for_read_seq_lis
  -> EXTERN: (42,13) for_read_seq_lis
  -> EXTERN: (42,13) for_read_seq_lis_xmit
  -> EXTERN: (42,13) for_read_seq_lis_xmit
  -> EXTERN: (43,13) for_read_seq_lis
  -> EXTERN: (44,13) for_read_seq_lis
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (44,13) for_read_seq_lis_xmit
  -> EXTERN: (51,13) for_read_seq_lis
  -> EXTERN: (52,13) for_read_seq_lis
  -> EXTERN: (52,13) for_read_seq_lis_xmit
  -> EXTERN: (55,34) log10
  -> EXTERN: (62,13) for_read_seq_lis
  -> EXTERN: (63,13) for_read_seq_lis
  -> EXTERN: (63,13) for_read_seq_lis_xmit
  -> EXTERN: (63,13) for_read_seq_lis_xmit
  -> EXTERN: (64,13) for_read_seq_lis
  -> EXTERN: (65,13) for_read_seq_lis
  -> EXTERN: (65,13) for_read_seq_lis_xmit
  -> EXTERN: (65,13) for_read_seq_lis_xmit
  -> EXTERN: (66,13) for_read_seq_lis
  -> EXTERN: (67,13) for_read_seq_lis
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (67,13) for_read_seq_lis_xmit
  -> EXTERN: (69,19) for_close
  -> EXTERN: (71,15) mpi_barrier_
  -> INLINE: (77,12) EJECT (isz = 24) (sz = 31)
    -> EXTERN: (364,7) for_write_seq_fmt
    -> EXTERN: (365,12) mpi_abort_
    -> EXTERN: (367,7) for_stop_core
  -> INLINE: (83,12) GRIDMAP (isz = 570) (sz = 573)
    -> EXTERN: parallel.f:(165,19) log
    -> INLINE: parallel.f:(177,33) MAP (isz = 46) (sz = 61)
    -> INLINE: parallel.f:(179,33) MAP (isz = 46) (sz = 61)
    -> INLINE: parallel.f:(181,33) MAP (isz = 46) (sz = 61)
    -> EXTERN: parallel.f:(205,17) log
    -> EXTERN: parallel.f:(206,12) mpi_barrier_
    -> EXTERN: parallel.f:(207,14) f_pow2i
    -> EXTERN: parallel.f:(208,17) log
    -> EXTERN: parallel.f:(209,14) f_pow2i
    -> EXTERN: parallel.f:(211,12) mpi_barrier_
    -> EXTERN: parallel.f:(212,21) for_write_seq_lis_xmit
    -> EXTERN: parallel.f:(212,21) for_write_seq_lis
    -> EXTERN: parallel.f:(212,21) for_write_seq_lis_xmit
    -> EXTERN: parallel.f:(212,21) for_write_seq_lis_xmit
    -> parallel.f:(230,12) MAP (isz = 46) (sz = 61)
       [[ Callee not marked with inlining directive  <1>]]
    -> parallel.f:(231,12) MAP (isz = 46) (sz = 61)
       [[ Callee not marked with inlining directive  <1>]]
    -> parallel.f:(232,12) MAP (isz = 46) (sz = 61)
       [[ Callee not marked with inlining directive  <1>]]
  -> (89,12) ALLOC (isz = 5384) (sz = 5387)
     [[ Inlining would exceed -inline-max-size value (5387>230) <2>]]
  -> (91,12) GRID (isz = 4373) (sz = 4376)
     [[ Inlining would exceed -inline-max-size value (4376>230) <2>]]
  -> INLINE: (93,12) SETIV (isz = 865) (sz = 868)
    -> EXTERN: setiv.f:(92,33) pow
    -> setiv.f:(109,12) TML (isz = 4626) (sz = 4629)
       [[ Inlining would exceed -inline-max-size value (4629>230) <2>]]
    -> INLINE: setiv.f:(115,21) THERMAL_PROPS (isz = 91) (sz = 112)
  -> (95,12) FLOWIO (isz = 2102) (sz = 2105)
     [[ Inlining would exceed -inline-max-size value (2105>230) <2>]]
  -> EXTERN: (97,12) mpi_barrier_
  -> (105,15) PARALLEL (isz = 231) (sz = 236)
     [[ Inlining would exceed -inline-max-size value (236>230) <2>]]
  -> EXTERN: (110,10) for_write_seq_fmt
  -> EXTERN: (111,10) for_write_seq_fmt
  -> EXTERN: (111,10) for_write_seq_fmt_xmit
  -> EXTERN: (111,10) for_write_seq_fmt_xmit
  -> EXTERN: (115,10) for_write_seq_fmt
  -> EXTERN: (115,10) for_write_seq_fmt_xmit
  -> EXTERN: (115,10) for_write_seq_fmt_xmit
  -> EXTERN: (119,10) for_write_seq_fmt
  -> EXTERN: (120,10) for_write_seq_fmt
  -> EXTERN: (120,10) for_write_seq_fmt_xmit
  -> EXTERN: (121,10) for_write_seq_fmt
  -> EXTERN: (121,10) for_write_seq_fmt_xmit
  -> EXTERN: (122,10) for_write_seq_fmt
  -> EXTERN: (122,10) for_write_seq_fmt_xmit
  -> EXTERN: (123,10) for_write_seq_fmt
  -> EXTERN: (123,10) for_write_seq_fmt_xmit
  -> EXTERN: (124,10) for_write_seq_fmt
  -> EXTERN: (124,10) for_write_seq_fmt_xmit
  -> EXTERN: (126,10) for_write_seq_fmt
  -> EXTERN: (127,10) for_write_seq_fmt
  -> EXTERN: (129,13) for_write_seq_fmt
  -> EXTERN: (133,10) for_write_seq_fmt
  -> EXTERN: (134,10) for_write_seq_fmt
  -> EXTERN: (135,10) for_write_seq_fmt
  -> EXTERN: (136,10) for_write_seq_fmt
  -> EXTERN: (137,10) for_write_seq_fmt
  -> EXTERN: (138,10) for_write_seq_fmt
  -> EXTERN: (139,10) for_write_seq_lis
  -> EXTERN: (152,12) mpi_barrier_
  -> (158,15) PARALLEL (isz = 231) (sz = 236)
     [[ Inlining would exceed -inline-max-size value (236>230) <2>]]
  -> (161,12) SETBC (isz = 1873) (sz = 1876)
     [[ Inlining would exceed -inline-max-size value (1876>230) <2>]]
  -> EXTERN: (166,10) for_check_mult_overflow64
  -> EXTERN: (166,10) for_alloc_allocatable
  -> EXTERN: (174,10) for_open
  -> EXTERN: (177,16) mpi_wtime_
  -> (179,12) TMSTEP (isz = 676) (sz = 683)
     [[ Inlining would exceed -inline-max-size value (683>230) <2>]]
  -> (184,36) TMSTEP (isz = 676) (sz = 683)
     [[ Inlining would exceed -inline-max-size value (683>230) <2>]]
  -> (187,17) ANALYSIS (isz = 883) (sz = 890)
     [[ Inlining would exceed -inline-max-total-size value (2789>2000) <3>]]
  -> EXTERN: (190,12) for_write_seq_fmt
  -> EXTERN: (190,12) for_write_seq_fmt_xmit
  -> EXTERN: (190,12) for_write_seq_fmt_xmit
  -> EXTERN: (190,12) for_write_seq_fmt_xmit
  -> EXTERN: (190,12) for_write_seq_fmt_xmit
  -> EXTERN: (191,12) for_write_seq_fmt
  -> EXTERN: (191,12) for_write_seq_fmt_xmit
  -> INLINE: (201,17) EJECT (isz = 24) (sz = 31)
    -> EXTERN: (364,7) for_write_seq_fmt
    -> EXTERN: (365,12) mpi_abort_
    -> EXTERN: (367,7) for_stop_core
  -> (241,17) FLUXI (isz = 1947) (sz = 1950)
     [[ Inlining would exceed -inline-max-size value (1950>230) <2>]]
  -> (243,17) FLUXJ (isz = 2691) (sz = 2694)
     [[ Inlining would exceed -inline-max-size value (2694>230) <2>]]
  -> (245,31) FLUXK (isz = 2691) (sz = 2694)
     [[ Inlining would exceed -inline-max-size value (2694>230) <2>]]
  -> INLINE: (252,17) UPDATE (isz = 423) (sz = 426)
  -> (274,20) PARALLEL (isz = 231) (sz = 236)
     [[ Inlining would exceed -inline-max-size value (236>230) <2>]]
  -> (278,17) SETBC (isz = 1873) (sz = 1876)
     [[ Inlining would exceed -inline-max-size value (1876>230) <2>]]
  -> EXTERN: (325,18) for_close
  -> EXTERN: (328,16) mpi_wtime_
  -> EXTERN: (331,12) mpi_reduce_
  -> EXTERN: (339,10) for_write_seq_lis_xmit
  -> EXTERN: (339,10) for_write_seq_lis
  -> EXTERN: (340,10) for_write_seq_fmt
  -> EXTERN: (340,10) for_write_seq_fmt_xmit
  -> EXTERN: (340,10) for_write_seq_fmt_xmit
  -> EXTERN: (340,10) for_write_seq_fmt_xmit
  -> EXTERN: (343,10) for_write_seq_fmt
  -> EXTERN: (349,27) for_dealloc_allocatable
  -> EXTERN: (350,12) mpi_finalize_


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at main.f(36,7)
   remark #15382: vectorization support: call to function for_open cannot be vectorized   [ main.f(38,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(39,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(40,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(40,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(41,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(42,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(42,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(42,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(43,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(44,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(51,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(52,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(52,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(62,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(63,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(63,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(63,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(64,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(65,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(65,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(65,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(66,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_read_seq_lis_xmit cannot be vectorized   [ main.f(67,13) ]
   remark #15382: vectorization support: call to function for_close cannot be vectorized   [ main.f(69,19) ]
   remark #15382: vectorization support: call to function mpi_barrier_ cannot be vectorized   [ main.f(71,15) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (38:13) and at (69:19)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (69:19) and at (38:13)
LOOP END

LOOP BEGIN at parallel.f(168,7) inlined into main.f(83,12)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at parallel.f(169,10) inlined into main.f(83,12)
      remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

      LOOP BEGIN at parallel.f(170,13) inlined into main.f(83,12)
         remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

         LOOP BEGIN at parallel.f(174,19) inlined into main.f(83,12)
            remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
            remark #25452: Original Order found to be proper, but by a close margin
            remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

            LOOP BEGIN at parallel.f(175,22) inlined into main.f(83,12)
               remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
               remark #25452: Original Order found to be proper, but by a close margin
               remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

               LOOP BEGIN at parallel.f(176,25) inlined into main.f(83,12)
               <Predicate Optimized v2>
                  remark #25084: Preprocess Loopnests: Moving Out Store    [ parallel.f(178,28) ]
                  remark #25084: Preprocess Loopnests: Moving Out Store    [ parallel.f(180,28) ]
                  remark #25084: Preprocess Loopnests: Moving Out Store    [ parallel.f(182,28) ]
                  remark #25422: Invariant Condition at line 277 hoisted out of this loop
                  remark #25422: Invariant Condition at line 277 hoisted out of this loop
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (268:7) and istart (274:10)
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (274:10) and istart (268:7)
               LOOP END

               LOOP BEGIN at parallel.f(176,25) inlined into main.f(83,12)
               <Predicate Optimized v3>
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (268:7) and istart (274:10)
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (274:10) and istart (268:7)
               LOOP END

               LOOP BEGIN at parallel.f(176,25) inlined into main.f(83,12)
               <Predicate Optimized v3>
                  remark #25422: Invariant Condition at line 277 hoisted out of this loop
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (268:7) and istart (274:10)
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (274:10) and istart (268:7)
               LOOP END

               LOOP BEGIN at parallel.f(176,25) inlined into main.f(83,12)
               <Predicate Optimized v4>
                  remark #15344: loop was not vectorized: vector dependence prevents vectorization
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (268:7) and istart (274:10)
                  remark #15346: vector dependence: assumed OUTPUT dependence between istart (274:10) and istart (268:7)
               LOOP END
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(24,9) inlined into main.f(93,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(24,9) inlined into main.f(93,12)
      remark #25101: Loop Interchange not done due to: Original Order seems proper
      remark #25452: Original Order found to be proper, but by a close margin
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(25,11) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(26,13) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at setiv.f(26,13) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,1,ll) has unaligned access   [ setiv.f(27,15) ]
            remark #15388: vectorization support: reference dq_(i,j,k,1) has aligned access   [ setiv.f(28,15) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 0.406
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 2.000 
            remark #15478: estimated potential speedup: 2.720 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(26,13) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,1,ll) has unaligned access   [ setiv.f(27,15) ]
            remark #15389: vectorization support: reference dq_(i,j,k,1) has unaligned access   [ setiv.f(28,15) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.600
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 2.000 
            remark #15478: estimated potential speedup: 2.720 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(26,13) inlined into main.f(93,12)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END
   LOOP END

   LOOP BEGIN at setiv.f(33,11) inlined into main.f(93,12)
      remark #25461: Imperfect Loop Unroll-Jammed by 4   (pre-vector) 
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(34,13) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15388: vectorization support: reference dq_(i,j,k,lm) has aligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 0.406
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 2.000 
            remark #15478: estimated potential speedup: 2.720 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.600
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 2.000 
            remark #15478: estimated potential speedup: 2.720 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END

      LOOP BEGIN at setiv.f(34,13) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15388: vectorization support: reference dq_(i,j,k,lm) has aligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 0.406
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 2.000 
            remark #15478: estimated potential speedup: 2.720 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.600
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 2.000 
            remark #15478: estimated potential speedup: 2.720 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END

      LOOP BEGIN at setiv.f(34,13) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15388: vectorization support: reference dq_(i,j,k,lm) has aligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 0.406
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 2.000 
            remark #15478: estimated potential speedup: 2.720 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.600
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 2.000 
            remark #15478: estimated potential speedup: 2.720 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END

      LOOP BEGIN at setiv.f(34,13) inlined into main.f(93,12)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15388: vectorization support: reference dq_(i,j,k,lm) has aligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 0.406
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 2.000 
            remark #15478: estimated potential speedup: 2.720 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference q_(i,j,k,lm,ll) has unaligned access   [ setiv.f(36,17) ]
            remark #15389: vectorization support: reference dq_(i,j,k,lm) has unaligned access   [ setiv.f(37,17) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.600
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 6 
            remark #15477: vector cost: 2.000 
            remark #15478: estimated potential speedup: 2.720 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at setiv.f(35,15) inlined into main.f(93,12)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(44,7) inlined into main.f(93,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(45,9) inlined into main.f(93,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(46,11) inlined into main.f(93,12)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at setiv.f(46,11) inlined into main.f(93,12)
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(47,13) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(48,13) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(49,13) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ setiv.f(50,13) ]
         remark #15388: vectorization support: reference t_(i,j,k) has aligned access   [ setiv.f(51,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.272
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 16 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.560 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(46,11) inlined into main.f(93,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(47,13) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(48,13) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(49,13) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ setiv.f(50,13) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ setiv.f(51,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.120
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 16 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 2.560 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(46,11) inlined into main.f(93,12)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(98,7) inlined into main.f(93,12)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(99,9) inlined into main.f(93,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(100,11) inlined into main.f(93,12)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at setiv.f(100,11) inlined into main.f(93,12)
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ setiv.f(101,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ setiv.f(102,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ setiv.f(103,13) ]
         remark #15388: vectorization support: reference hf_(i,j,k,4) has aligned access   [ setiv.f(104,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.264
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 4.500 
         remark #15478: estimated potential speedup: 2.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(100,11) inlined into main.f(93,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ setiv.f(101,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ setiv.f(102,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ setiv.f(103,13) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ setiv.f(104,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.100
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
      LOOP END

      LOOP BEGIN at setiv.f(100,11) inlined into main.f(93,12)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(111,7) inlined into main.f(93,12)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between cp(:,j,k) (17:10) and hf_(i,j,k,4) (122:16)
   remark #15346: vector dependence: assumed ANTI dependence between hf_(i,j,k,4) (122:16) and cp(:,j,k) (17:10)

   LOOP BEGIN at setiv.f(112,10) inlined into main.f(93,12)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed FLOW dependence between cp(:,j,k) (17:10) and hf_(i,j,k,4) (122:16)
      remark #15346: vector dependence: assumed ANTI dependence between hf_(i,j,k,4) (122:16) and cp(:,j,k) (17:10)

      LOOP BEGIN at setiv.f(113,13) inlined into main.f(93,12)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed FLOW dependence between cp(:,j,k) (17:10) and hf_(i,j,k,4) (122:16)
         remark #15346: vector dependence: assumed ANTI dependence between hf_(i,j,k,4) (122:16) and cp(:,j,k) (17:10)

         LOOP BEGIN at props.f(17,10) inlined into main.f(93,12)
            remark #25045: Fused Loops: ( 17 18 19 )

            remark #25436: completely unrolled by 1   (pre-vector) 
         LOOP END

         LOOP BEGIN at props.f(18,10) inlined into main.f(93,12)
            remark #25046: Loop lost in Fusion 
         LOOP END

         LOOP BEGIN at props.f(19,10) inlined into main.f(93,12)
            remark #25046: Loop lost in Fusion 
         LOOP END

         LOOP BEGIN at setiv.f(128,16) inlined into main.f(93,12)
            remark #25436: completely unrolled by 5   (pre-vector) 
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at main.f(167,10)
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(167,10)
      remark #15388: vectorization support: reference WORK(:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 2
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.000 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at main.f(167,10)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(181,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(236,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at update.f(14,7) inlined into main.f(252,17)
         remark #25101: Loop Interchange not done due to: Original Order seems proper
         remark #25452: Original Order found to be proper, but by a close margin
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at update.f(15,10) inlined into main.f(252,17)
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Peeled loop for vectorization, Predicate Optimized v1>
               remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
               remark #25015: Estimate of max trip count of loop=3
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Predicate Optimized v1>
               remark #25422: Invariant Condition at line 18 hoisted out of this loop
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,1) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(19,19) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 4
               remark #15309: vectorization support: normalized vectorization overhead 0.402
               remark #15300: LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 23 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 210 
               remark #15477: vector cost: 58.500 
               remark #15478: estimated potential speedup: 3.450 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
               remark #25456: Number of Array Refs Scalar Replaced In Loop: 7

               LOOP BEGIN at update.f(19,19) inlined into main.f(252,17)
                  remark #25436: completely unrolled by 5   (pre-vector) 
               LOOP END

               LOOP BEGIN at update.f(21,19) inlined into main.f(252,17)
                  remark #25436: completely unrolled by 5   (pre-vector) 
               LOOP END
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Remainder loop for vectorization, Predicate Optimized v1>
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Peeled loop for vectorization, Predicate Optimized v2>
               remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
               remark #25015: Estimate of max trip count of loop=3
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Predicate Optimized v2>
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,m) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference q_(i,j,k,:,n) has unaligned access   [ update.f(21,19) ]
               remark #15389: vectorization support: reference dq_(i,j,k,:) has unaligned access   [ update.f(21,62) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(25,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ update.f(25,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(25,42) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(26,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ update.f(26,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(26,42) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(27,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ update.f(27,27) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(27,42) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(33,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ update.f(33,28) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(33,43) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,32) ]
               remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ update.f(29,43) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,32) ]
               remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ update.f(30,43) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,32) ]
               remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ update.f(31,43) ]
               remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ update.f(34,16) ]
               remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ update.f(34,27) ]
               remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ update.f(34,50) ]
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 4
               remark #15309: vectorization support: normalized vectorization overhead 0.421
               remark #15300: LOOP WAS VECTORIZED
               remark #15442: entire loop may be executed in remainder
               remark #15450: unmasked unaligned unit stride loads: 28 
               remark #15451: unmasked unaligned unit stride stores: 10 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 233 
               remark #15477: vector cost: 64.750 
               remark #15478: estimated potential speedup: 3.450 
               remark #15486: divides: 4 
               remark #15488: --- end vector cost summary ---
               remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
            LOOP END

            LOOP BEGIN at update.f(16,13) inlined into main.f(252,17)
            <Remainder loop for vectorization, Predicate Optimized v2>
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END


Non-optimizable loops:


LOOP BEGIN at main.f(76,7)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

main.f(167,10):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(167,10):remark #34026: call to memset implemented as a call to optimized library version
main.f(1,15):remark #34051: REGISTER ALLOCATION : [MAIN__.A] main.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :    2447
            Global    :     725
            Local     :    1722
        Regenerable   :     789
        Spilled       :     399
        
    Routine stack
        Variables     :    1088 bytes*
            Reads     :       7 [6.38e+00 ~ 0.0%]
            Writes    :     148 [1.92e+02 ~ 0.0%]
        Spills        :    3136 bytes*
            Reads     :     834 [5.20e+05 ~ 31.2%]
            Writes    :     511 [6.64e+04 ~ 4.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ANALYSIS

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ANALYSIS) [2/38=5.3%] main.f(370,18)
  -> EXTERN: (387,7) for_alloc_allocatable
  -> EXTERN: (387,7) for_check_mult_overflow64
  -> EXTERN: (387,7) for_alloc_allocatable
  -> EXTERN: (387,7) for_check_mult_overflow64
  -> EXTERN: (387,7) for_alloc_allocatable
  -> EXTERN: (387,7) for_check_mult_overflow64
  -> EXTERN: (406,12) mpi_allreduce_
  -> EXTERN: (408,7) for_dealloc_allocatable
  -> EXTERN: (408,7) for_realloc_lhs
  -> EXTERN: (410,12) mpi_allreduce_
  -> EXTERN: (412,7) for_dealloc_allocatable
  -> EXTERN: (412,7) for_realloc_lhs
  -> EXTERN: (422,7) for_dealloc_allocatable
  -> EXTERN: (422,7) for_dealloc_allocatable
  -> EXTERN: (422,7) for_dealloc_allocatable
  -> EXTERN: (425,7) for_dealloc_allocatable
  -> EXTERN: (425,7) for_dealloc_allocatable
  -> EXTERN: (425,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at main.f(389,7)
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(389,7)
      remark #15389: vectorization support: reference UB(:) has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 0.500
      remark #15300: LOOP WAS VECTORIZED
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 0.750 
      remark #15478: estimated potential speedup: 1.710 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at main.f(389,7)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference UB(:) has aligned access
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.222
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 0.750 
      remark #15478: estimated potential speedup: 1.710 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(390,7)
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(390,7)
      remark #15389: vectorization support: reference RB(:) has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 0.500
      remark #15300: LOOP WAS VECTORIZED
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 0.750 
      remark #15478: estimated potential speedup: 1.710 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at main.f(390,7)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference RB(:) has aligned access
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.222
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 0.750 
      remark #15478: estimated potential speedup: 1.710 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(396,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(397,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at main.f(399,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ main.f(400,34) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ main.f(401,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.543
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 21 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 9.610 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at main.f(399,13)
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ main.f(400,34) ]
         remark #15388: vectorization support: reference q_(i,j,k,1,1) has aligned access   [ main.f(401,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.469
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 21 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 9.610 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at main.f(399,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ main.f(400,34) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ main.f(401,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.543
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 21 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 9.610 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at main.f(408,7)
   remark #25399: memcopy generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(408,7)
      remark #15388: vectorization support: reference UB(:) has aligned access
      remark #15388: vectorization support: reference BUF(:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.000 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at main.f(408,7)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference UB(:) has aligned access
      remark #15388: vectorization support: reference BUF(:) has aligned access
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.100
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.000 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(412,7)
   remark #25399: memcopy generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(412,7)
      remark #15388: vectorization support: reference RB(:) has aligned access
      remark #15388: vectorization support: reference BUF(:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.000 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at main.f(412,7)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference RB(:) has aligned access
      remark #15388: vectorization support: reference BUF(:) has aligned access
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.100
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.000 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(415,7)
<Peeled loop for vectorization>
   remark #15389: vectorization support: reference UB(j) has unaligned access   [ main.f(416,10) ]
   remark #15389: vectorization support: reference UB(j) has unaligned access   [ main.f(416,18) ]
   remark #15389: vectorization support: reference RB(j) has unaligned access   [ main.f(416,33) ]
   remark #15389: vectorization support: reference UB(j) has unaligned access   [ main.f(417,36) ]
   remark #15389: vectorization support: reference UB(j) has unaligned access   [ main.f(417,44) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 0.215
   remark #15301: PEEL LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 72 
   remark #15477: vector cost: 6.500 
   remark #15478: estimated potential speedup: 10.180 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at main.f(415,7)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ main.f(417,10) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(416,10) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(416,18) ]
   remark #15389: vectorization support: reference RB(j) has unaligned access   [ main.f(416,33) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(417,36) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(417,44) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.385
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 72 
   remark #15477: vector cost: 6.500 
   remark #15478: estimated potential speedup: 10.180 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
LOOP END

LOOP BEGIN at main.f(415,7)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(416,10) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(416,18) ]
   remark #15389: vectorization support: reference RB(j) has unaligned access   [ main.f(416,33) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(417,36) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(417,44) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 0.198
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 72 
   remark #15477: vector cost: 6.500 
   remark #15478: estimated potential speedup: 10.180 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

    Report from: Code generation optimizations [cg]

main.f(370,18):remark #34051: REGISTER ALLOCATION : [analysis_] main.f:370

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      18
            Global    :       9
            Local     :       9
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ANALYSIS [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ANALYSIS) [2/38=5.3%] main.f(370,18)
  -> EXTERN: (387,7) for_alloc_allocatable
  -> EXTERN: (387,7) for_check_mult_overflow64
  -> EXTERN: (387,7) for_alloc_allocatable
  -> EXTERN: (387,7) for_check_mult_overflow64
  -> EXTERN: (387,7) for_alloc_allocatable
  -> EXTERN: (387,7) for_check_mult_overflow64
  -> EXTERN: (406,12) mpi_allreduce_
  -> EXTERN: (408,7) for_dealloc_allocatable
  -> EXTERN: (408,7) for_realloc_lhs
  -> EXTERN: (410,12) mpi_allreduce_
  -> EXTERN: (412,7) for_dealloc_allocatable
  -> EXTERN: (412,7) for_realloc_lhs
  -> EXTERN: (422,7) for_dealloc_allocatable
  -> EXTERN: (422,7) for_dealloc_allocatable
  -> EXTERN: (422,7) for_dealloc_allocatable
  -> EXTERN: (425,7) for_dealloc_allocatable
  -> EXTERN: (425,7) for_dealloc_allocatable
  -> EXTERN: (425,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at main.f(389,7)
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(389,7)
      remark #15389: vectorization support: reference UB(:) has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 0.500
      remark #15300: LOOP WAS VECTORIZED
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 0.750 
      remark #15478: estimated potential speedup: 1.710 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at main.f(389,7)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference UB(:) has aligned access
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.222
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 0.750 
      remark #15478: estimated potential speedup: 1.710 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(390,7)
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(390,7)
      remark #15389: vectorization support: reference RB(:) has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15305: vectorization support: vector length 8
      remark #15309: vectorization support: normalized vectorization overhead 0.500
      remark #15300: LOOP WAS VECTORIZED
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 0.750 
      remark #15478: estimated potential speedup: 1.710 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at main.f(390,7)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference RB(:) has aligned access
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.222
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 0.750 
      remark #15478: estimated potential speedup: 1.710 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(396,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(397,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at main.f(399,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ main.f(400,34) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ main.f(401,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.543
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 21 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 9.610 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at main.f(399,13)
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ main.f(400,34) ]
         remark #15388: vectorization support: reference q_(i,j,k,1,1) has aligned access   [ main.f(401,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.469
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 21 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 9.610 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at main.f(399,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ main.f(400,34) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ main.f(401,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.543
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 21 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 9.610 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at main.f(408,7)
   remark #25399: memcopy generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(408,7)
      remark #15388: vectorization support: reference UB(:) has aligned access
      remark #15388: vectorization support: reference BUF(:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.000 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at main.f(408,7)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference UB(:) has aligned access
      remark #15388: vectorization support: reference BUF(:) has aligned access
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.100
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.000 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(412,7)
   remark #25399: memcopy generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(412,7)
      remark #15388: vectorization support: reference RB(:) has aligned access
      remark #15388: vectorization support: reference BUF(:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.000 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at main.f(412,7)
   <Remainder loop for vectorization>
      remark #15388: vectorization support: reference RB(:) has aligned access
      remark #15388: vectorization support: reference BUF(:) has aligned access
      remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 1.100
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.000 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(415,7)
<Peeled loop for vectorization>
   remark #15389: vectorization support: reference UB(j) has unaligned access   [ main.f(416,10) ]
   remark #15389: vectorization support: reference UB(j) has unaligned access   [ main.f(416,18) ]
   remark #15389: vectorization support: reference RB(j) has unaligned access   [ main.f(416,33) ]
   remark #15389: vectorization support: reference UB(j) has unaligned access   [ main.f(417,36) ]
   remark #15389: vectorization support: reference UB(j) has unaligned access   [ main.f(417,44) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 0.215
   remark #15301: PEEL LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 72 
   remark #15477: vector cost: 6.500 
   remark #15478: estimated potential speedup: 10.180 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at main.f(415,7)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ main.f(417,10) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(416,10) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(416,18) ]
   remark #15389: vectorization support: reference RB(j) has unaligned access   [ main.f(416,33) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(417,36) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(417,44) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.385
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 72 
   remark #15477: vector cost: 6.500 
   remark #15478: estimated potential speedup: 10.180 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
LOOP END

LOOP BEGIN at main.f(415,7)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(416,10) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(416,18) ]
   remark #15389: vectorization support: reference RB(j) has unaligned access   [ main.f(416,33) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(417,36) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(417,44) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 0.198
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 72 
   remark #15477: vector cost: 6.500 
   remark #15478: estimated potential speedup: 10.180 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

    Report from: Code generation optimizations [cg]

main.f(389,7):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(389,7):remark #34026: call to memset implemented as a call to optimized library version
main.f(390,7):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(390,7):remark #34026: call to memset implemented as a call to optimized library version
main.f(408,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(408,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(408,7):remark #34026: call to memcpy implemented as a call to optimized library version
main.f(412,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(412,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(412,7):remark #34026: call to memcpy implemented as a call to optimized library version
main.f(370,18):remark #34051: REGISTER ALLOCATION : [analysis_.h] main.f:370

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   44[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm13 zmm16-zmm25 k1-k6]
        
    Routine temporaries
        Total         :     602
            Global    :     165
            Local     :     437
        Regenerable   :      71
        Spilled       :      30
        
    Routine stack
        Variables     :     252 bytes*
            Reads     :      35 [2.12e+01 ~ 0.2%]
            Writes    :      56 [5.21e+01 ~ 0.4%]
        Spills        :     200 bytes*
            Reads     :      31 [2.31e+02 ~ 1.8%]
            Writes    :      26 [6.03e+01 ~ 0.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ANALYSIS [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ANALYSIS) [2/38=5.3%] main.f(370,18)
  -> EXTERN: (387,7) for_alloc_allocatable
  -> EXTERN: (387,7) for_check_mult_overflow64
  -> EXTERN: (387,7) for_alloc_allocatable
  -> EXTERN: (387,7) for_check_mult_overflow64
  -> EXTERN: (387,7) for_alloc_allocatable
  -> EXTERN: (387,7) for_check_mult_overflow64
  -> EXTERN: (406,12) mpi_allreduce_
  -> EXTERN: (408,7) for_dealloc_allocatable
  -> EXTERN: (408,7) for_realloc_lhs
  -> EXTERN: (410,12) mpi_allreduce_
  -> EXTERN: (412,7) for_dealloc_allocatable
  -> EXTERN: (412,7) for_realloc_lhs
  -> EXTERN: (422,7) for_dealloc_allocatable
  -> EXTERN: (422,7) for_dealloc_allocatable
  -> EXTERN: (422,7) for_dealloc_allocatable
  -> EXTERN: (425,7) for_dealloc_allocatable
  -> EXTERN: (425,7) for_dealloc_allocatable
  -> EXTERN: (425,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at main.f(389,7)
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(389,7)
      remark #15388: vectorization support: reference UB(:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 2
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.000 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at main.f(389,7)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(390,7)
   remark #25408: memset generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(390,7)
      remark #15388: vectorization support: reference RB(:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 2
      remark #15300: LOOP WAS VECTORIZED
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 3 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.000 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=3
   LOOP END

   LOOP BEGIN at main.f(390,7)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(396,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(397,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at main.f(399,13)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at main.f(399,13)
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ main.f(400,34) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ main.f(401,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.250
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 21 
         remark #15477: vector cost: 3.750 
         remark #15478: estimated potential speedup: 4.670 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at main.f(399,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ main.f(400,34) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ main.f(401,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 3.500
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 21 
         remark #15477: vector cost: 3.750 
         remark #15478: estimated potential speedup: 4.670 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at main.f(399,13)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at main.f(408,7)
   remark #25399: memcopy generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(408,7)
      remark #15388: vectorization support: reference UB(:) has aligned access
      remark #15388: vectorization support: reference BUF(:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.660 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at main.f(408,7)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(412,7)
   remark #25399: memcopy generated
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at main.f(412,7)
      remark #15388: vectorization support: reference RB(:) has aligned access
      remark #15388: vectorization support: reference BUF(:) has aligned access
      remark #15305: vectorization support: vector length 2
      remark #15300: LOOP WAS VECTORIZED
      remark #15448: unmasked aligned unit stride loads: 1 
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 1.500 
      remark #15478: estimated potential speedup: 2.660 
      remark #15488: --- end vector cost summary ---
      remark #25015: Estimate of max trip count of loop=6
   LOOP END

   LOOP BEGIN at main.f(412,7)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=12
   LOOP END
LOOP END

LOOP BEGIN at main.f(415,7)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at main.f(415,7)
   remark #25084: Preprocess Loopnests: Moving Out Store    [ main.f(417,10) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(416,10) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(416,18) ]
   remark #15389: vectorization support: reference RB(j) has unaligned access   [ main.f(416,33) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(417,36) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(417,44) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.167
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 72 
   remark #15477: vector cost: 12.750 
   remark #15478: estimated potential speedup: 4.720 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 8
LOOP END

LOOP BEGIN at main.f(415,7)
<Remainder loop for vectorization>
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(416,10) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(416,18) ]
   remark #15389: vectorization support: reference RB(j) has unaligned access   [ main.f(416,33) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(417,36) ]
   remark #15388: vectorization support: reference UB(j) has aligned access   [ main.f(417,44) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.667
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 72 
   remark #15477: vector cost: 12.750 
   remark #15478: estimated potential speedup: 4.720 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
LOOP END

LOOP BEGIN at main.f(415,7)
<Remainder loop for vectorization>
LOOP END

    Report from: Code generation optimizations [cg]

main.f(389,7):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(389,7):remark #34026: call to memset implemented as a call to optimized library version
main.f(390,7):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(390,7):remark #34026: call to memset implemented as a call to optimized library version
main.f(408,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(408,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(408,7):remark #34026: call to memcpy implemented as a call to optimized library version
main.f(412,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(412,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
main.f(412,7):remark #34026: call to memcpy implemented as a call to optimized library version
main.f(370,18):remark #34051: REGISTER ALLOCATION : [analysis_.A] main.f:370

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   29[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm14]
        
    Routine temporaries
        Total         :     535
            Global    :     139
            Local     :     396
        Regenerable   :      58
        Spilled       :      29
        
    Routine stack
        Variables     :     252 bytes*
            Reads     :      35 [2.12e+01 ~ 0.2%]
            Writes    :      56 [5.21e+01 ~ 0.6%]
        Spills        :     192 bytes*
            Reads     :      33 [2.95e+02 ~ 3.4%]
            Writes    :      26 [6.03e+01 ~ 0.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: TMSTEP

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (TMSTEP) [3/38=7.9%] tmstep.f(1,18)
  -> EXTERN: (63,12) mpi_allreduce_
  -> EXTERN: (77,27) for_write_seq_lis
  -> EXTERN: (77,27) for_write_seq_lis_xmit
  -> EXTERN: (80,27) for_write_seq_lis_xmit
  -> EXTERN: (80,27) for_write_seq_lis
  -> EXTERN: (80,27) for_write_seq_lis_xmit
  -> EXTERN: (84,27) for_write_seq_lis
  -> EXTERN: (84,27) for_write_seq_lis_xmit
  -> EXTERN: (85,27) for_write_seq_lis


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at tmstep.f(23,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at tmstep.f(24,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at tmstep.f(25,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(27,22) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ tmstep.f(27,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(28,22) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ tmstep.f(28,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(29,22) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ tmstep.f(29,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(30,22) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ tmstep.f(30,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(31,22) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ tmstep.f(31,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(32,22) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ tmstep.f(32,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(33,22) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ tmstep.f(33,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(34,22) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ tmstep.f(34,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(35,22) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ tmstep.f(35,33) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ tmstep.f(37,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ tmstep.f(37,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ tmstep.f(39,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(39,49) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,28) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,44) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(41,42) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ tmstep.f(42,42) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(46,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(48,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,52) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(44,46) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(49,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,53) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,36) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,36) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.308
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 19 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 427 
         remark #15477: vector cost: 56.000 
         remark #15478: estimated potential speedup: 7.080 
         remark #15486: divides: 6 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at tmstep.f(25,13)
         remark #25084: Preprocess Loopnests: Moving Out Store    [ tmstep.f(49,16) ]
         remark #25084: Preprocess Loopnests: Moving Out Store    [ tmstep.f(51,16) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(27,22) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ tmstep.f(27,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(28,22) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ tmstep.f(28,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(29,22) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ tmstep.f(29,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(30,22) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ tmstep.f(30,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(31,22) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ tmstep.f(31,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(32,22) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ tmstep.f(32,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(33,22) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ tmstep.f(33,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(34,22) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ tmstep.f(34,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(35,22) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ tmstep.f(35,33) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ tmstep.f(37,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ tmstep.f(37,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ tmstep.f(39,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(39,49) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,28) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,44) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(41,42) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ tmstep.f(42,42) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(46,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(48,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,52) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(44,46) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(49,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,53) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,36) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,36) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.333
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 19 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 427 
         remark #15477: vector cost: 56.000 
         remark #15478: estimated potential speedup: 7.080 
         remark #15486: divides: 6 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 19
      LOOP END

      LOOP BEGIN at tmstep.f(25,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(27,22) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ tmstep.f(27,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(28,22) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ tmstep.f(28,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(29,22) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ tmstep.f(29,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(30,22) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ tmstep.f(30,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(31,22) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ tmstep.f(31,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(32,22) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ tmstep.f(32,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(33,22) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ tmstep.f(33,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(34,22) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ tmstep.f(34,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(35,22) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ tmstep.f(35,33) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ tmstep.f(37,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ tmstep.f(37,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ tmstep.f(39,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(39,49) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,28) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,44) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(41,42) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ tmstep.f(42,42) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(46,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(48,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,52) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(44,46) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(49,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,53) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,36) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,36) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.308
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 19 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 427 
         remark #15477: vector cost: 56.000 
         remark #15478: estimated potential speedup: 7.080 
         remark #15486: divides: 6 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at tmstep.f(88,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at tmstep.f(89,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at tmstep.f(90,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference dtv_(i,j,k) has unaligned access   [ tmstep.f(91,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(91,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.327
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 4.870 
         remark #15478: estimated potential speedup: 6.090 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at tmstep.f(90,13)
         remark #15388: vectorization support: reference dtv_(i,j,k) has aligned access   [ tmstep.f(91,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(91,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.179
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 4.870 
         remark #15478: estimated potential speedup: 6.090 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at tmstep.f(90,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference dtv_(i,j,k) has unaligned access   [ tmstep.f(91,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(91,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.327
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 4.870 
         remark #15478: estimated potential speedup: 6.090 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

tmstep.f(1,18):remark #34051: REGISTER ALLOCATION : [tmstep_] tmstep.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      18
            Global    :       9
            Local     :       9
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: TMSTEP [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (TMSTEP) [3/38=7.9%] tmstep.f(1,18)
  -> EXTERN: (63,12) mpi_allreduce_
  -> EXTERN: (77,27) for_write_seq_lis
  -> EXTERN: (77,27) for_write_seq_lis_xmit
  -> EXTERN: (80,27) for_write_seq_lis_xmit
  -> EXTERN: (80,27) for_write_seq_lis
  -> EXTERN: (80,27) for_write_seq_lis_xmit
  -> EXTERN: (84,27) for_write_seq_lis
  -> EXTERN: (84,27) for_write_seq_lis_xmit
  -> EXTERN: (85,27) for_write_seq_lis


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at tmstep.f(23,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at tmstep.f(24,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at tmstep.f(25,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(27,22) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ tmstep.f(27,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(28,22) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ tmstep.f(28,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(29,22) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ tmstep.f(29,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(30,22) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ tmstep.f(30,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(31,22) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ tmstep.f(31,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(32,22) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ tmstep.f(32,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(33,22) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ tmstep.f(33,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(34,22) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ tmstep.f(34,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(35,22) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ tmstep.f(35,33) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ tmstep.f(37,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ tmstep.f(37,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ tmstep.f(39,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(39,49) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,28) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,44) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(41,42) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ tmstep.f(42,42) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(46,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(48,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,52) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(44,46) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(49,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,53) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,36) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,36) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.308
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 19 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 427 
         remark #15477: vector cost: 56.000 
         remark #15478: estimated potential speedup: 7.080 
         remark #15486: divides: 6 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at tmstep.f(25,13)
         remark #25084: Preprocess Loopnests: Moving Out Store    [ tmstep.f(49,16) ]
         remark #25084: Preprocess Loopnests: Moving Out Store    [ tmstep.f(51,16) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(27,22) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ tmstep.f(27,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(28,22) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ tmstep.f(28,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(29,22) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ tmstep.f(29,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(30,22) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ tmstep.f(30,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(31,22) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ tmstep.f(31,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(32,22) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ tmstep.f(32,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(33,22) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ tmstep.f(33,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(34,22) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ tmstep.f(34,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(35,22) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ tmstep.f(35,33) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ tmstep.f(37,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ tmstep.f(37,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ tmstep.f(39,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(39,49) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,28) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,44) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(41,42) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ tmstep.f(42,42) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(46,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(48,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,52) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(44,46) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(49,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,53) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,36) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,36) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.333
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 19 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 427 
         remark #15477: vector cost: 56.000 
         remark #15478: estimated potential speedup: 7.080 
         remark #15486: divides: 6 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 19
      LOOP END

      LOOP BEGIN at tmstep.f(25,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(27,22) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ tmstep.f(27,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(28,22) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ tmstep.f(28,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(29,22) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ tmstep.f(29,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(30,22) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ tmstep.f(30,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(31,22) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ tmstep.f(31,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(32,22) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ tmstep.f(32,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(33,22) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ tmstep.f(33,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(34,22) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ tmstep.f(34,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(35,22) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ tmstep.f(35,33) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ tmstep.f(37,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ tmstep.f(37,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ tmstep.f(39,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(39,49) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,28) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,44) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(41,42) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ tmstep.f(42,42) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(46,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(48,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,52) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(44,46) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(49,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,53) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,36) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,36) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.308
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 19 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 427 
         remark #15477: vector cost: 56.000 
         remark #15478: estimated potential speedup: 7.080 
         remark #15486: divides: 6 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at tmstep.f(88,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at tmstep.f(89,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at tmstep.f(90,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference dtv_(i,j,k) has unaligned access   [ tmstep.f(91,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(91,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.327
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 4.870 
         remark #15478: estimated potential speedup: 6.090 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at tmstep.f(90,13)
         remark #15388: vectorization support: reference dtv_(i,j,k) has aligned access   [ tmstep.f(91,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(91,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.179
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 4.870 
         remark #15478: estimated potential speedup: 6.090 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at tmstep.f(90,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference dtv_(i,j,k) has unaligned access   [ tmstep.f(91,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(91,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.327
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 4.870 
         remark #15478: estimated potential speedup: 6.090 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

tmstep.f(1,18):remark #34051: REGISTER ALLOCATION : [tmstep_.h] tmstep.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   52[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm14 zmm16-zmm31 k1-k7]
        
    Routine temporaries
        Total         :    1052
            Global    :     280
            Local     :     772
        Regenerable   :      96
        Spilled       :     177
        
    Routine stack
        Variables     :     172 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :      17 [2.03e+00 ~ 0.0%]
        Spills        :    1368 bytes*
            Reads     :     261 [8.08e+03 ~ 9.8%]
            Writes    :     196 [1.43e+03 ~ 1.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: TMSTEP [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (TMSTEP) [3/38=7.9%] tmstep.f(1,18)
  -> EXTERN: (63,12) mpi_allreduce_
  -> EXTERN: (77,27) for_write_seq_lis
  -> EXTERN: (77,27) for_write_seq_lis_xmit
  -> EXTERN: (80,27) for_write_seq_lis_xmit
  -> EXTERN: (80,27) for_write_seq_lis
  -> EXTERN: (80,27) for_write_seq_lis_xmit
  -> EXTERN: (84,27) for_write_seq_lis
  -> EXTERN: (84,27) for_write_seq_lis_xmit
  -> EXTERN: (85,27) for_write_seq_lis


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at tmstep.f(23,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at tmstep.f(24,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at tmstep.f(25,13)
      <Peeled loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 19
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at tmstep.f(25,13)
         remark #25084: Preprocess Loopnests: Moving Out Store    [ tmstep.f(49,16) ]
         remark #25084: Preprocess Loopnests: Moving Out Store    [ tmstep.f(51,16) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(27,22) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ tmstep.f(27,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(28,22) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ tmstep.f(28,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(29,22) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ tmstep.f(29,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(30,22) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ tmstep.f(30,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(31,22) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ tmstep.f(31,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(32,22) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ tmstep.f(32,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(33,22) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ tmstep.f(33,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(34,22) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ tmstep.f(34,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(35,22) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ tmstep.f(35,33) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ tmstep.f(37,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ tmstep.f(37,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ tmstep.f(39,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(39,49) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,28) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(40,44) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(41,42) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ tmstep.f(42,42) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(46,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(48,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,36) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ tmstep.f(43,52) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(44,46) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ tmstep.f(49,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ tmstep.f(51,53) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,36) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ tmstep.f(52,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,36) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ tmstep.f(53,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.305
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 19 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 427 
         remark #15477: vector cost: 107.500 
         remark #15478: estimated potential speedup: 3.800 
         remark #15486: divides: 6 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 19
      LOOP END

      LOOP BEGIN at tmstep.f(25,13)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at tmstep.f(88,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at tmstep.f(89,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at tmstep.f(90,13)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at tmstep.f(90,13)
         remark #15388: vectorization support: reference dtv_(i,j,k) has aligned access   [ tmstep.f(91,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(91,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.092
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 9.500 
         remark #15478: estimated potential speedup: 3.060 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at tmstep.f(90,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference dtv_(i,j,k) has unaligned access   [ tmstep.f(91,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ tmstep.f(91,34) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.425
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 9.500 
         remark #15478: estimated potential speedup: 3.060 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at tmstep.f(90,13)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

tmstep.f(1,18):remark #34051: REGISTER ALLOCATION : [tmstep_.A] tmstep.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :     695
            Global    :     198
            Local     :     497
        Regenerable   :      85
        Spilled       :     137
        
    Routine stack
        Variables     :     172 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :      17 [2.03e+00 ~ 0.0%]
        Spills        :    1048 bytes*
            Reads     :     236 [6.97e+03 ~ 17.4%]
            Writes    :     150 [8.81e+02 ~ 2.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: FLUXI

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (FLUXI) [4/38=10.5%] fluxi.f(1,18)
  -> EXTERN: (18,7) for_check_mult_overflow64
  -> EXTERN: (18,7) for_alloc_allocatable
  -> EXTERN: (18,7) for_check_mult_overflow64
  -> EXTERN: (18,7) for_check_mult_overflow64
  -> EXTERN: (18,7) for_alloc_allocatable
  -> EXTERN: (18,7) for_check_mult_overflow64
  -> INLINE: (19,27) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> INLINE: (21,12) EXTRAPI (isz = 1124) (sz = 1127)
    -> INLINE: (116,24) EXI4 (isz = 791) (sz = 802)
      -> EXTERN: (185,18) _alloca
      -> EXTERN: (185,18) _alloca
      -> EXTERN: (185,18) _alloca
      -> EXTERN: (185,18) __getsp_inlined
      -> EXTERN: (246,7) __resetsp_inlined
  -> (51,28) VISCI (isz = 1805) (sz = 1818)
     [[ Inlining would exceed -inline-max-total-size value (2953>2000) <3>]]
  -> EXTERN: (64,7) for_dealloc_allocatable
  -> EXTERN: (64,7) for_dealloc_allocatable
  -> EXTERN: (67,7) for_dealloc_allocatable
  -> EXTERN: (67,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxi.f(109,7) inlined into fluxi.f(21,12)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxi.f(110,10) inlined into fluxi.f(21,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxi.f(201,10) inlined into fluxi.f(21,12)
         remark #15388: vectorization support: reference af(i) has aligned access   [ fluxi.f(202,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(202,36) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(202,50) ]
         remark #15388: vectorization support: reference bf(i) has aligned access   [ fluxi.f(203,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(203,36) ]
         remark #15389: vectorization support: reference ds1_(i+1,j,k,1) has unaligned access   [ fluxi.f(203,52) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(204,34) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(204,48) ]
         remark #15388: vectorization support: reference cf(i) has aligned access   [ fluxi.f(205,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(205,28) ]
         remark #15389: vectorization support: reference ds1_(i+1,j,k,1) has unaligned access   [ fluxi.f(205,44) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 5.000 
         remark #15478: estimated potential speedup: 7.060 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(208,10) inlined into fluxi.f(21,12)
         remark #15388: vectorization support: reference af(i) has aligned access   [ fluxi.f(209,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(209,36) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(209,52) ]
         remark #15388: vectorization support: reference bf(i) has aligned access   [ fluxi.f(210,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(210,36) ]
         remark #15389: vectorization support: reference ds1_(i-1,j,k,1) has unaligned access   [ fluxi.f(210,50) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(211,38) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(211,54) ]
         remark #15388: vectorization support: reference cf(i) has aligned access   [ fluxi.f(212,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(212,28) ]
         remark #15389: vectorization support: reference ds1_(i-1,j,k,1) has unaligned access   [ fluxi.f(212,42) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 5.000 
         remark #15478: estimated potential speedup: 7.060 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(225,7) inlined into fluxi.f(21,12)
         remark #25045: Fused Loops: ( 225 229 233 237 241 )

         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access   [ fluxi.f(225,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(225,40) ]
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access   [ fluxi.f(225,61) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(225,61) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxi.f(229,7) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(229,7) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(229,40) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(229,57) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxi.f(233,7) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(233,7) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(233,40) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(233,57) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxi.f(237,7) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(237,7) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(237,40) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(237,57) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxi.f(241,7) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(241,7) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(241,40) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(241,57) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.545
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 11 
         remark #15450: unmasked unaligned unit stride loads: 15 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 83 
         remark #15477: vector cost: 13.750 
         remark #15478: estimated potential speedup: 5.720 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 12
      LOOP END

      LOOP BEGIN at fluxi.f(229,7) inlined into fluxi.f(21,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(233,7) inlined into fluxi.f(21,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(237,7) inlined into fluxi.f(21,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(241,7) inlined into fluxi.f(21,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(201,10) inlined into fluxi.f(21,12)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference af(i) has aligned access   [ fluxi.f(202,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(202,36) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(202,50) ]
         remark #15388: vectorization support: reference bf(i) has aligned access   [ fluxi.f(203,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(203,36) ]
         remark #15389: vectorization support: reference ds1_(i+1,j,k,1) has unaligned access   [ fluxi.f(203,52) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(204,34) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(204,48) ]
         remark #15388: vectorization support: reference cf(i) has aligned access   [ fluxi.f(205,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(205,28) ]
         remark #15389: vectorization support: reference ds1_(i+1,j,k,1) has unaligned access   [ fluxi.f(205,44) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.354
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 8.620 
         remark #15478: estimated potential speedup: 5.890 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(208,10) inlined into fluxi.f(21,12)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference af(i) has aligned access   [ fluxi.f(209,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(209,36) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(209,52) ]
         remark #15388: vectorization support: reference bf(i) has aligned access   [ fluxi.f(210,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(210,36) ]
         remark #15389: vectorization support: reference ds1_(i-1,j,k,1) has unaligned access   [ fluxi.f(210,50) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(211,38) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(211,54) ]
         remark #15388: vectorization support: reference cf(i) has aligned access   [ fluxi.f(212,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(212,28) ]
         remark #15389: vectorization support: reference ds1_(i-1,j,k,1) has unaligned access   [ fluxi.f(212,42) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.354
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 8.620 
         remark #15478: estimated potential speedup: 5.890 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(225,7) inlined into fluxi.f(21,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access   [ fluxi.f(225,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(225,40) ]
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access   [ fluxi.f(225,61) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(225,61) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxi.f(229,7) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(229,7) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(229,40) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(229,57) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxi.f(233,7) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(233,7) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(233,40) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(233,57) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxi.f(237,7) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(237,7) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(237,40) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(237,57) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxi.f(241,7) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(241,7) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(241,40) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(241,57) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.406
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 8.620 
         remark #15478: estimated potential speedup: 5.890 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at fluxi.f(135,7) inlined into fluxi.f(21,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxi.f(136,10) inlined into fluxi.f(21,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxi.f(137,13) inlined into fluxi.f(21,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference qav_(i,j,k,2) has unaligned access   [ fluxi.f(142,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(142,31) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(142,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,3) has unaligned access   [ fluxi.f(143,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(143,31) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(143,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,4) has unaligned access   [ fluxi.f(144,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(144,31) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(144,46) ]
         remark #15389: vectorization support: reference pav_(i,j,k) has unaligned access   [ fluxi.f(147,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(147,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(147,54) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,32) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,45) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,32) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,45) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,32) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,45) ]
         remark #15389: vectorization support: reference qav_(i,j,k,5) has unaligned access   [ fluxi.f(145,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(145,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(145,55) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.446
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 8.620 
         remark #15478: estimated potential speedup: 5.890 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(137,13) inlined into fluxi.f(21,12)
         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference qav_(i,j,k,2) has unaligned access   [ fluxi.f(142,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(142,31) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(142,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,3) has unaligned access   [ fluxi.f(143,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(143,31) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(143,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,4) has unaligned access   [ fluxi.f(144,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(144,31) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(144,46) ]
         remark #15389: vectorization support: reference pav_(i,j,k) has unaligned access   [ fluxi.f(147,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(147,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(147,54) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,32) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,45) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,32) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,45) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,32) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,45) ]
         remark #15389: vectorization support: reference qav_(i,j,k,5) has unaligned access   [ fluxi.f(145,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(145,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(145,55) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.551
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 8.620 
         remark #15478: estimated potential speedup: 5.890 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(137,13) inlined into fluxi.f(21,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference qav_(i,j,k,2) has unaligned access   [ fluxi.f(142,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(142,31) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(142,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,3) has unaligned access   [ fluxi.f(143,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(143,31) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(143,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,4) has unaligned access   [ fluxi.f(144,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(144,31) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(144,46) ]
         remark #15389: vectorization support: reference pav_(i,j,k) has unaligned access   [ fluxi.f(147,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(147,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(147,54) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,32) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,45) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,32) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,45) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,32) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,45) ]
         remark #15389: vectorization support: reference qav_(i,j,k,5) has unaligned access   [ fluxi.f(145,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(145,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(145,55) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.446
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 8.620 
         remark #15478: estimated potential speedup: 5.890 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at fluxi.f(23,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxi.f(24,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxi.f(26,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference FSI(:,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference FSI(:,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.434
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 10 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 5.180 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(26,13)
         remark #25045: Fused Loops: ( 26 41 42 )

         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference FSI(:,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference FSI(:,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.843
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15450: unmasked unaligned unit stride loads: 10 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 35 
         remark #15477: vector cost: 6.370 
         remark #15478: estimated potential speedup: 5.040 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 3
      LOOP END

      LOOP BEGIN at fluxi.f(41,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(42,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(44,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference FSI(:,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference FSI(:,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference FSI(:,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(48,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.639
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 10 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 5.180 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(44,13)
         remark #25045: Fused Loops: ( 44 46 48 )

         remark #15389: vectorization support: reference FSI(:,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference FSI(:,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference FSI(:,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(48,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.804
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 7 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 5.110 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxi.f(46,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(48,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(44,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference FSI(:,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference FSI(:,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference FSI(:,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(48,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.639
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 10 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 5.180 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(55,13)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxi.f(56,16)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference dq_(i,j,k,l) has unaligned access   [ fluxi.f(57,19) ]
            remark #15389: vectorization support: reference dtv_(i,j,k) has unaligned access   [ fluxi.f(57,34) ]
            remark #15389: vectorization support: reference FSI(i,l) has unaligned access   [ fluxi.f(57,48) ]
            remark #15389: vectorization support: reference FSI(i-1,l) has unaligned access   [ fluxi.f(57,59) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.639
            remark #15301: PEEL LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 10 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 5.180 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxi.f(56,16)
            remark #15388: vectorization support: reference dq_(i,j,k,l) has aligned access   [ fluxi.f(57,19) ]
            remark #15389: vectorization support: reference dtv_(i,j,k) has unaligned access   [ fluxi.f(57,34) ]
            remark #15389: vectorization support: reference FSI(i,l) has unaligned access   [ fluxi.f(57,48) ]
            remark #15389: vectorization support: reference FSI(i-1,l) has unaligned access   [ fluxi.f(57,59) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.679
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 10 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 5.180 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxi.f(56,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference dq_(i,j,k,l) has unaligned access   [ fluxi.f(57,19) ]
            remark #15389: vectorization support: reference dtv_(i,j,k) has unaligned access   [ fluxi.f(57,34) ]
            remark #15389: vectorization support: reference FSI(i,l) has unaligned access   [ fluxi.f(57,48) ]
            remark #15389: vectorization support: reference FSI(i-1,l) has unaligned access   [ fluxi.f(57,59) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.639
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 10 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 5.180 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END

      LOOP BEGIN at fluxi.f(26,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference FSI(:,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference FSI(:,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.434
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 10 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 5.180 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxi.f(1,18):remark #34051: REGISTER ALLOCATION : [fluxi_] fluxi.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdx]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: FLUXI [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (FLUXI) [4/38=10.5%] fluxi.f(1,18)
  -> EXTERN: (18,7) for_check_mult_overflow64
  -> EXTERN: (18,7) for_alloc_allocatable
  -> EXTERN: (18,7) for_check_mult_overflow64
  -> EXTERN: (18,7) for_check_mult_overflow64
  -> EXTERN: (18,7) for_alloc_allocatable
  -> EXTERN: (18,7) for_check_mult_overflow64
  -> INLINE: (19,27) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> INLINE: (21,12) EXTRAPI (isz = 1124) (sz = 1127)
    -> INLINE: (116,24) EXI4 (isz = 791) (sz = 802)
      -> EXTERN: (185,18) _alloca
      -> EXTERN: (185,18) _alloca
      -> EXTERN: (185,18) _alloca
      -> EXTERN: (185,18) __getsp_inlined
      -> EXTERN: (246,7) __resetsp_inlined
  -> (51,28) VISCI (isz = 1805) (sz = 1818)
     [[ Inlining would exceed -inline-max-total-size value (2953>2000) <3>]]
  -> EXTERN: (64,7) for_dealloc_allocatable
  -> EXTERN: (64,7) for_dealloc_allocatable
  -> EXTERN: (67,7) for_dealloc_allocatable
  -> EXTERN: (67,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxi.f(109,7) inlined into fluxi.f(21,12)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxi.f(110,10) inlined into fluxi.f(21,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxi.f(201,10) inlined into fluxi.f(21,12)
         remark #15388: vectorization support: reference af(i) has aligned access   [ fluxi.f(202,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(202,36) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(202,50) ]
         remark #15388: vectorization support: reference bf(i) has aligned access   [ fluxi.f(203,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(203,36) ]
         remark #15389: vectorization support: reference ds1_(i+1,j,k,1) has unaligned access   [ fluxi.f(203,52) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(204,34) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(204,48) ]
         remark #15388: vectorization support: reference cf(i) has aligned access   [ fluxi.f(205,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(205,28) ]
         remark #15389: vectorization support: reference ds1_(i+1,j,k,1) has unaligned access   [ fluxi.f(205,44) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 5.000 
         remark #15478: estimated potential speedup: 7.060 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(208,10) inlined into fluxi.f(21,12)
         remark #15388: vectorization support: reference af(i) has aligned access   [ fluxi.f(209,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(209,36) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(209,52) ]
         remark #15388: vectorization support: reference bf(i) has aligned access   [ fluxi.f(210,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(210,36) ]
         remark #15389: vectorization support: reference ds1_(i-1,j,k,1) has unaligned access   [ fluxi.f(210,50) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(211,38) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(211,54) ]
         remark #15388: vectorization support: reference cf(i) has aligned access   [ fluxi.f(212,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(212,28) ]
         remark #15389: vectorization support: reference ds1_(i-1,j,k,1) has unaligned access   [ fluxi.f(212,42) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 5.000 
         remark #15478: estimated potential speedup: 7.060 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(225,7) inlined into fluxi.f(21,12)
         remark #25045: Fused Loops: ( 225 229 233 237 241 )

         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access   [ fluxi.f(225,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(225,40) ]
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access   [ fluxi.f(225,61) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(225,61) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxi.f(229,7) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(229,7) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(229,40) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(229,57) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxi.f(233,7) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(233,7) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(233,40) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(233,57) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxi.f(237,7) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(237,7) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(237,40) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(237,57) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxi.f(241,7) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(241,7) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(241,40) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(241,57) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.545
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 11 
         remark #15450: unmasked unaligned unit stride loads: 15 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 83 
         remark #15477: vector cost: 13.750 
         remark #15478: estimated potential speedup: 5.720 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 12
      LOOP END

      LOOP BEGIN at fluxi.f(229,7) inlined into fluxi.f(21,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(233,7) inlined into fluxi.f(21,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(237,7) inlined into fluxi.f(21,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(241,7) inlined into fluxi.f(21,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(201,10) inlined into fluxi.f(21,12)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference af(i) has aligned access   [ fluxi.f(202,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(202,36) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(202,50) ]
         remark #15388: vectorization support: reference bf(i) has aligned access   [ fluxi.f(203,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(203,36) ]
         remark #15389: vectorization support: reference ds1_(i+1,j,k,1) has unaligned access   [ fluxi.f(203,52) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(204,34) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(204,48) ]
         remark #15388: vectorization support: reference cf(i) has aligned access   [ fluxi.f(205,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(205,28) ]
         remark #15389: vectorization support: reference ds1_(i+1,j,k,1) has unaligned access   [ fluxi.f(205,44) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.354
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 8.620 
         remark #15478: estimated potential speedup: 5.890 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(208,10) inlined into fluxi.f(21,12)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference af(i) has aligned access   [ fluxi.f(209,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(209,36) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(209,52) ]
         remark #15388: vectorization support: reference bf(i) has aligned access   [ fluxi.f(210,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(210,36) ]
         remark #15389: vectorization support: reference ds1_(i-1,j,k,1) has unaligned access   [ fluxi.f(210,50) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(211,38) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(211,54) ]
         remark #15388: vectorization support: reference cf(i) has aligned access   [ fluxi.f(212,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(212,28) ]
         remark #15389: vectorization support: reference ds1_(i-1,j,k,1) has unaligned access   [ fluxi.f(212,42) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.354
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 8.620 
         remark #15478: estimated potential speedup: 5.890 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(225,7) inlined into fluxi.f(21,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access   [ fluxi.f(225,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(225,40) ]
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access   [ fluxi.f(225,61) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(225,61) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxi.f(229,7) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(229,7) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(229,40) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(229,57) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxi.f(233,7) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(233,7) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(233,40) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(233,57) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxi.f(237,7) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(237,7) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(237,40) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(237,57) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxi.f(241,7) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(241,7) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(241,40) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(241,57) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.406
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 8.620 
         remark #15478: estimated potential speedup: 5.890 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at fluxi.f(135,7) inlined into fluxi.f(21,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxi.f(136,10) inlined into fluxi.f(21,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxi.f(137,13) inlined into fluxi.f(21,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference qav_(i,j,k,2) has unaligned access   [ fluxi.f(142,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(142,31) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(142,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,3) has unaligned access   [ fluxi.f(143,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(143,31) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(143,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,4) has unaligned access   [ fluxi.f(144,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(144,31) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(144,46) ]
         remark #15389: vectorization support: reference pav_(i,j,k) has unaligned access   [ fluxi.f(147,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(147,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(147,54) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,32) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,45) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,32) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,45) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,32) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,45) ]
         remark #15389: vectorization support: reference qav_(i,j,k,5) has unaligned access   [ fluxi.f(145,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(145,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(145,55) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.446
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 8.620 
         remark #15478: estimated potential speedup: 5.890 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(137,13) inlined into fluxi.f(21,12)
         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference qav_(i,j,k,2) has unaligned access   [ fluxi.f(142,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(142,31) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(142,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,3) has unaligned access   [ fluxi.f(143,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(143,31) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(143,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,4) has unaligned access   [ fluxi.f(144,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(144,31) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(144,46) ]
         remark #15389: vectorization support: reference pav_(i,j,k) has unaligned access   [ fluxi.f(147,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(147,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(147,54) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,32) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,45) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,32) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,45) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,32) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,45) ]
         remark #15389: vectorization support: reference qav_(i,j,k,5) has unaligned access   [ fluxi.f(145,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(145,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(145,55) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.551
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 8.620 
         remark #15478: estimated potential speedup: 5.890 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(137,13) inlined into fluxi.f(21,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference qav_(i,j,k,2) has unaligned access   [ fluxi.f(142,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(142,31) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(142,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,3) has unaligned access   [ fluxi.f(143,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(143,31) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(143,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,4) has unaligned access   [ fluxi.f(144,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(144,31) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(144,46) ]
         remark #15389: vectorization support: reference pav_(i,j,k) has unaligned access   [ fluxi.f(147,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(147,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(147,54) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,32) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,45) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,32) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,45) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,32) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,45) ]
         remark #15389: vectorization support: reference qav_(i,j,k,5) has unaligned access   [ fluxi.f(145,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(145,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(145,55) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.446
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 8.620 
         remark #15478: estimated potential speedup: 5.890 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at fluxi.f(23,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxi.f(24,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxi.f(26,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference FSI(:,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference FSI(:,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.434
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 10 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 5.180 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(26,13)
         remark #25045: Fused Loops: ( 26 41 42 )

         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference FSI(:,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference FSI(:,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.843
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15450: unmasked unaligned unit stride loads: 10 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 35 
         remark #15477: vector cost: 6.370 
         remark #15478: estimated potential speedup: 5.040 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 3
      LOOP END

      LOOP BEGIN at fluxi.f(41,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(42,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(44,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference FSI(:,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference FSI(:,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference FSI(:,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(48,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.639
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 10 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 5.180 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(44,13)
         remark #25045: Fused Loops: ( 44 46 48 )

         remark #15389: vectorization support: reference FSI(:,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference FSI(:,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference FSI(:,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(48,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.804
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 7 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 5.110 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxi.f(46,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(48,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(44,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference FSI(:,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference FSI(:,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference FSI(:,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(48,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.639
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 10 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 5.180 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(55,13)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxi.f(56,16)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference dq_(i,j,k,l) has unaligned access   [ fluxi.f(57,19) ]
            remark #15389: vectorization support: reference dtv_(i,j,k) has unaligned access   [ fluxi.f(57,34) ]
            remark #15389: vectorization support: reference FSI(i,l) has unaligned access   [ fluxi.f(57,48) ]
            remark #15389: vectorization support: reference FSI(i-1,l) has unaligned access   [ fluxi.f(57,59) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.639
            remark #15301: PEEL LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 10 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 5.180 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxi.f(56,16)
            remark #15388: vectorization support: reference dq_(i,j,k,l) has aligned access   [ fluxi.f(57,19) ]
            remark #15389: vectorization support: reference dtv_(i,j,k) has unaligned access   [ fluxi.f(57,34) ]
            remark #15389: vectorization support: reference FSI(i,l) has unaligned access   [ fluxi.f(57,48) ]
            remark #15389: vectorization support: reference FSI(i-1,l) has unaligned access   [ fluxi.f(57,59) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.679
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 10 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 5.180 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxi.f(56,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference dq_(i,j,k,l) has unaligned access   [ fluxi.f(57,19) ]
            remark #15389: vectorization support: reference dtv_(i,j,k) has unaligned access   [ fluxi.f(57,34) ]
            remark #15389: vectorization support: reference FSI(i,l) has unaligned access   [ fluxi.f(57,48) ]
            remark #15389: vectorization support: reference FSI(i-1,l) has unaligned access   [ fluxi.f(57,59) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.639
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 10 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 5.180 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END

      LOOP BEGIN at fluxi.f(26,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference FSI(:,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference FSI(:,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.434
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 10 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 5.180 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxi.f(209,36):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(209,36):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(209,36):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(209,36):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(209,52):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(209,52):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(209,52):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(209,52):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(202,36):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(202,36):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(202,36):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(202,36):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(202,50):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(202,50):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(202,50):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(202,50):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(57,48):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(57,48):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(57,48):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(57,48):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(57,48):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(57,48):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(57,48):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(57,48):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(209,36):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
fluxi.f(209,52):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
fluxi.f(57,48):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
fluxi.f(57,48):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
fluxi.f(202,36):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
fluxi.f(202,50):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
fluxi.f(1,18):remark #34051: REGISTER ALLOCATION : [fluxi_.h] fluxi.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   40[ rax rdx rcx rsi rdi r8-r15 zmm0-zmm3 zmm16-zmm31 k1-k7]
        
    Routine temporaries
        Total         :    1710
            Global    :     482
            Local     :    1228
        Regenerable   :     100
        Spilled       :     327
        
    Routine stack
        Variables     :     292 bytes*
            Reads     :      12 [1.02e+01 ~ 0.0%]
            Writes    :      53 [7.01e+01 ~ 0.0%]
        Spills        :    2512 bytes*
            Reads     :     536 [1.89e+04 ~ 9.0%]
            Writes    :     359 [3.10e+03 ~ 1.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: FLUXI [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (FLUXI) [4/38=10.5%] fluxi.f(1,18)
  -> EXTERN: (18,7) for_check_mult_overflow64
  -> EXTERN: (18,7) for_alloc_allocatable
  -> EXTERN: (18,7) for_check_mult_overflow64
  -> EXTERN: (18,7) for_check_mult_overflow64
  -> EXTERN: (18,7) for_alloc_allocatable
  -> EXTERN: (18,7) for_check_mult_overflow64
  -> INLINE: (19,27) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> INLINE: (21,12) EXTRAPI (isz = 1124) (sz = 1127)
    -> INLINE: (116,24) EXI4 (isz = 791) (sz = 802)
      -> EXTERN: (185,18) _alloca
      -> EXTERN: (185,18) _alloca
      -> EXTERN: (185,18) _alloca
      -> EXTERN: (185,18) __getsp_inlined
      -> EXTERN: (246,7) __resetsp_inlined
  -> (51,28) VISCI (isz = 1805) (sz = 1818)
     [[ Inlining would exceed -inline-max-total-size value (2953>2000) <3>]]
  -> EXTERN: (64,7) for_dealloc_allocatable
  -> EXTERN: (64,7) for_dealloc_allocatable
  -> EXTERN: (67,7) for_dealloc_allocatable
  -> EXTERN: (67,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxi.f(109,7) inlined into fluxi.f(21,12)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxi.f(110,10) inlined into fluxi.f(21,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxi.f(201,10) inlined into fluxi.f(21,12)
         remark #15388: vectorization support: reference af(i) has aligned access   [ fluxi.f(202,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(202,36) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(202,50) ]
         remark #15388: vectorization support: reference bf(i) has aligned access   [ fluxi.f(203,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(203,36) ]
         remark #15389: vectorization support: reference ds1_(i+1,j,k,1) has unaligned access   [ fluxi.f(203,52) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(204,34) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(204,48) ]
         remark #15388: vectorization support: reference cf(i) has aligned access   [ fluxi.f(205,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(205,28) ]
         remark #15389: vectorization support: reference ds1_(i+1,j,k,1) has unaligned access   [ fluxi.f(205,44) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.333
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 4.090 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(201,10) inlined into fluxi.f(21,12)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxi.f(208,10) inlined into fluxi.f(21,12)
         remark #15388: vectorization support: reference af(i) has aligned access   [ fluxi.f(209,13) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(209,36) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(209,52) ]
         remark #15388: vectorization support: reference bf(i) has aligned access   [ fluxi.f(210,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(210,36) ]
         remark #15389: vectorization support: reference ds1_(i-1,j,k,1) has unaligned access   [ fluxi.f(210,50) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ fluxi.f(211,38) ]
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ fluxi.f(211,54) ]
         remark #15388: vectorization support: reference cf(i) has aligned access   [ fluxi.f(212,13) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ fluxi.f(212,28) ]
         remark #15389: vectorization support: reference ds1_(i-1,j,k,1) has unaligned access   [ fluxi.f(212,42) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.333
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 4.090 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(208,10) inlined into fluxi.f(21,12)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxi.f(225,7) inlined into fluxi.f(21,12)
         remark #25045: Fused Loops: ( 225 229 233 237 241 )

         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access   [ fluxi.f(225,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(225,40) ]
         remark #15389: vectorization support: reference q_(:,j,k,1,n) has unaligned access   [ fluxi.f(225,61) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(225,61) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxi.f(229,7) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(229,7) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(229,40) ]
         remark #15389: vectorization support: reference u_(:,j,k) has unaligned access   [ fluxi.f(229,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(229,57) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxi.f(233,7) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(233,7) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(233,40) ]
         remark #15389: vectorization support: reference v_(:,j,k) has unaligned access   [ fluxi.f(233,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(233,57) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxi.f(237,7) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(237,7) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(237,40) ]
         remark #15389: vectorization support: reference w_(:,j,k) has unaligned access   [ fluxi.f(237,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(237,57) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxi.f(241,7) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxi.f(241,7) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,40) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxi.f(241,40) ]
         remark #15389: vectorization support: reference t_(:,j,k) has unaligned access   [ fluxi.f(241,57) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxi.f(241,57) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.667
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 11 
         remark #15450: unmasked unaligned unit stride loads: 15 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 83 
         remark #15477: vector cost: 22.500 
         remark #15478: estimated potential speedup: 3.650 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 12
      LOOP END

      LOOP BEGIN at fluxi.f(229,7) inlined into fluxi.f(21,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(233,7) inlined into fluxi.f(21,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(237,7) inlined into fluxi.f(21,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(241,7) inlined into fluxi.f(21,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(225,7) inlined into fluxi.f(21,12)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at fluxi.f(135,7) inlined into fluxi.f(21,12)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxi.f(136,10) inlined into fluxi.f(21,12)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxi.f(137,13) inlined into fluxi.f(21,12)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at fluxi.f(137,13) inlined into fluxi.f(21,12)
         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference qav_(i,j,k,2) has unaligned access   [ fluxi.f(142,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(142,31) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(142,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,3) has unaligned access   [ fluxi.f(143,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(143,31) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(143,46) ]
         remark #15389: vectorization support: reference qav_(i,j,k,4) has unaligned access   [ fluxi.f(144,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(144,31) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(144,46) ]
         remark #15389: vectorization support: reference pav_(i,j,k) has unaligned access   [ fluxi.f(147,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(147,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(147,54) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,32) ]
         remark #15389: vectorization support: reference uav_(i,j,k) has unaligned access   [ fluxi.f(138,45) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,32) ]
         remark #15389: vectorization support: reference vav_(i,j,k) has unaligned access   [ fluxi.f(139,45) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,32) ]
         remark #15389: vectorization support: reference wav_(i,j,k) has unaligned access   [ fluxi.f(140,45) ]
         remark #15389: vectorization support: reference qav_(i,j,k,5) has unaligned access   [ fluxi.f(145,16) ]
         remark #15389: vectorization support: reference qav_(i,j,k,1) has unaligned access   [ fluxi.f(145,31) ]
         remark #15389: vectorization support: reference tav_(i,j,k) has unaligned access   [ fluxi.f(145,55) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.633
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 15.000 
         remark #15478: estimated potential speedup: 3.510 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxi.f(137,13) inlined into fluxi.f(21,12)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at fluxi.f(23,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxi.f(24,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxi.f(26,13)
      <Peeled loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 3
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at fluxi.f(26,13)
         remark #25045: Fused Loops: ( 26 41 42 )

         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(26,44) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(26,63) ]
         remark #15389: vectorization support: reference FSI(:,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(41,13) ]
         remark #15389: vectorization support: reference FSI(:,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(42,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15389: vectorization support: reference six_(:,j,k) has unaligned access   [ fluxi.f(42,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.075
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15450: unmasked unaligned unit stride loads: 10 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 35 
         remark #15477: vector cost: 10.000 
         remark #15478: estimated potential speedup: 3.340 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 3
      LOOP END

      LOOP BEGIN at fluxi.f(41,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(42,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(26,13)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxi.f(44,13)
      <Peeled loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at fluxi.f(44,13)
         remark #25045: Fused Loops: ( 44 46 48 )

         remark #15389: vectorization support: reference FSI(:,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference siy_(:,j,k) has unaligned access   [ fluxi.f(44,50) ]
         remark #15389: vectorization support: reference FSI(:,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(46,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference siz_(:,j,k) has unaligned access   [ fluxi.f(46,50) ]
         remark #15389: vectorization support: reference FSI(:,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxi.f(48,13) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxi.f(48,50) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.000
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 7 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 3.300 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxi.f(46,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(48,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxi.f(44,13)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxi.f(55,13)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxi.f(56,16)
         <Peeled loop for vectorization>
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at fluxi.f(56,16)
            remark #15388: vectorization support: reference dq_(i,j,k,l) has aligned access   [ fluxi.f(57,19) ]
            remark #15389: vectorization support: reference dtv_(i,j,k) has unaligned access   [ fluxi.f(57,34) ]
            remark #15389: vectorization support: reference FSI(i,l) has unaligned access   [ fluxi.f(57,48) ]
            remark #15389: vectorization support: reference FSI(i-1,l) has unaligned access   [ fluxi.f(57,59) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 0.432
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 10 
            remark #15477: vector cost: 2.750 
            remark #15478: estimated potential speedup: 3.220 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxi.f(56,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference dq_(i,j,k,l) has unaligned access   [ fluxi.f(57,19) ]
            remark #15389: vectorization support: reference dtv_(i,j,k) has unaligned access   [ fluxi.f(57,34) ]
            remark #15389: vectorization support: reference FSI(i,l) has unaligned access   [ fluxi.f(57,48) ]
            remark #15389: vectorization support: reference FSI(i-1,l) has unaligned access   [ fluxi.f(57,59) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.692
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 10 
            remark #15477: vector cost: 2.750 
            remark #15478: estimated potential speedup: 3.220 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxi.f(56,16)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxi.f(1,18):remark #34051: REGISTER ALLOCATION : [fluxi_.A] fluxi.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   29[ rax rdx rcx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :    1238
            Global    :     404
            Local     :     834
        Regenerable   :      79
        Spilled       :     268
        
    Routine stack
        Variables     :     292 bytes*
            Reads     :      12 [1.02e+01 ~ 0.0%]
            Writes    :      53 [7.01e+01 ~ 0.1%]
        Spills        :    2096 bytes*
            Reads     :     479 [1.35e+04 ~ 12.6%]
            Writes    :     293 [2.42e+03 ~ 2.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: VISCI

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (VISCI) [5/38=13.2%] fluxi.f(248,18)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxi.f(280,7)
<Peeled loop for vectorization>
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(294,29) ]
   remark #15389: vectorization support: reference u_(ii,jg,kg) has unaligned access   [ fluxi.f(295,37) ]
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(295,50) ]
   remark #15389: vectorization support: reference u_(icd,jg,kg) has unaligned access   [ fluxi.f(294,42) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(296,29) ]
   remark #15389: vectorization support: reference v_(ii,jg,kg) has unaligned access   [ fluxi.f(297,37) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(297,50) ]
   remark #15389: vectorization support: reference v_(icd,jg,kg) has unaligned access   [ fluxi.f(296,42) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(298,29) ]
   remark #15389: vectorization support: reference w_(ii,jg,kg) has unaligned access   [ fluxi.f(299,37) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(299,50) ]
   remark #15389: vectorization support: reference w_(icd,jg,kg) has unaligned access   [ fluxi.f(298,42) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(300,29) ]
   remark #15389: vectorization support: reference t_(ii,jg,kg) has unaligned access   [ fluxi.f(301,37) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(301,50) ]
   remark #15389: vectorization support: reference t_(icd,jg,kg) has unaligned access   [ fluxi.f(300,42) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(304,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(305,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(306,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(307,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(309,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(310,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(311,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(312,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(314,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(315,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(316,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(317,17) ]
   remark #15389: vectorization support: reference uav_(i,jg-2,kg) has unaligned access   [ fluxi.f(326,29) ]
   remark #15389: vectorization support: reference uav_(i,jg+2,kg) has unaligned access   [ fluxi.f(326,44) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(327,37) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(327,52) ]
   remark #15389: vectorization support: reference vav_(i,jg-2,kg) has unaligned access   [ fluxi.f(328,29) ]
   remark #15389: vectorization support: reference vav_(i,jg+2,kg) has unaligned access   [ fluxi.f(328,44) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(329,37) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(329,52) ]
   remark #15389: vectorization support: reference wav_(i,jg-2,kg) has unaligned access   [ fluxi.f(330,29) ]
   remark #15389: vectorization support: reference wav_(i,jg+2,kg) has unaligned access   [ fluxi.f(330,44) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(331,37) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(331,52) ]
   remark #15389: vectorization support: reference tav_(i,jg-2,kg) has unaligned access   [ fluxi.f(332,29) ]
   remark #15389: vectorization support: reference tav_(i,jg+2,kg) has unaligned access   [ fluxi.f(332,44) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(333,37) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(333,52) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(321,22) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(321,37) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(322,22) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(322,37) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(323,22) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(323,37) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(324,22) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(324,37) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(336,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(337,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(338,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(339,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(341,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(342,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(343,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(344,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(346,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(347,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(348,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(349,24) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(353,22) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(353,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(354,22) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(354,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(355,22) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(355,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(356,22) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(356,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-2) has unaligned access   [ fluxi.f(358,29) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+2) has unaligned access   [ fluxi.f(358,44) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(359,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(359,52) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-2) has unaligned access   [ fluxi.f(360,29) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+2) has unaligned access   [ fluxi.f(360,44) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(361,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(361,52) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-2) has unaligned access   [ fluxi.f(362,29) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+2) has unaligned access   [ fluxi.f(362,44) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(363,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(363,52) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-2) has unaligned access   [ fluxi.f(364,29) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+2) has unaligned access   [ fluxi.f(364,44) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(365,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(365,52) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(368,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(369,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(370,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(371,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(373,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(374,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(375,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(376,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(378,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(379,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(380,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(381,24) ]
   remark #15389: vectorization support: reference t_(i,jg,kg) has unaligned access   [ fluxi.f(383,28) ]
   remark #15389: vectorization support: reference t_(i+1,jg,kg) has unaligned access   [ fluxi.f(383,42) ]
   remark #15389: vectorization support: reference u_(i,jg,kg) has unaligned access   [ fluxi.f(384,28) ]
   remark #15389: vectorization support: reference u_(i+1,jg,kg) has unaligned access   [ fluxi.f(384,42) ]
   remark #15389: vectorization support: reference v_(i,jg,kg) has unaligned access   [ fluxi.f(385,28) ]
   remark #15389: vectorization support: reference v_(i+1,jg,kg) has unaligned access   [ fluxi.f(385,42) ]
   remark #15389: vectorization support: reference w_(i,jg,kg) has unaligned access   [ fluxi.f(386,28) ]
   remark #15389: vectorization support: reference w_(i+1,jg,kg) has unaligned access   [ fluxi.f(386,42) ]
   remark #15389: vectorization support: reference hf_(i,jg,kg,2) has unaligned access   [ fluxi.f(387,28) ]
   remark #15389: vectorization support: reference hf_(i+1,jg,kg,2) has unaligned access   [ fluxi.f(387,42) ]
   remark #15389: vectorization support: reference six_(i,jg,kg) has unaligned access   [ fluxi.f(408,10) ]
   remark #15389: vectorization support: reference siy_(i,jg,kg) has unaligned access   [ fluxi.f(409,10) ]
   remark #15389: vectorization support: reference siz_(i,jg,kg) has unaligned access   [ fluxi.f(410,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,21) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,10) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,21) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,10) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,21) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,10) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,21) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 0.267
   remark #15301: PEEL LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15450: unmasked unaligned unit stride loads: 54 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15456: masked unaligned unit stride loads: 16 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 678 
   remark #15477: vector cost: 165.870 
   remark #15478: estimated potential speedup: 3.800 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at fluxi.f(280,7)
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(294,29) ]
   remark #15389: vectorization support: reference u_(ii,jg,kg) has unaligned access   [ fluxi.f(295,37) ]
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(295,50) ]
   remark #15389: vectorization support: reference u_(icd,jg,kg) has unaligned access   [ fluxi.f(294,42) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(296,29) ]
   remark #15389: vectorization support: reference v_(ii,jg,kg) has unaligned access   [ fluxi.f(297,37) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(297,50) ]
   remark #15389: vectorization support: reference v_(icd,jg,kg) has unaligned access   [ fluxi.f(296,42) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(298,29) ]
   remark #15389: vectorization support: reference w_(ii,jg,kg) has unaligned access   [ fluxi.f(299,37) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(299,50) ]
   remark #15389: vectorization support: reference w_(icd,jg,kg) has unaligned access   [ fluxi.f(298,42) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(300,29) ]
   remark #15389: vectorization support: reference t_(ii,jg,kg) has unaligned access   [ fluxi.f(301,37) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(301,50) ]
   remark #15389: vectorization support: reference t_(icd,jg,kg) has unaligned access   [ fluxi.f(300,42) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(304,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(305,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(306,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(307,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(309,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(310,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(311,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(312,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(314,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(315,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(316,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(317,17) ]
   remark #15389: vectorization support: reference uav_(i,jg-2,kg) has unaligned access   [ fluxi.f(326,29) ]
   remark #15389: vectorization support: reference uav_(i,jg+2,kg) has unaligned access   [ fluxi.f(326,44) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(327,37) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(327,52) ]
   remark #15389: vectorization support: reference vav_(i,jg-2,kg) has unaligned access   [ fluxi.f(328,29) ]
   remark #15389: vectorization support: reference vav_(i,jg+2,kg) has unaligned access   [ fluxi.f(328,44) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(329,37) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(329,52) ]
   remark #15389: vectorization support: reference wav_(i,jg-2,kg) has unaligned access   [ fluxi.f(330,29) ]
   remark #15389: vectorization support: reference wav_(i,jg+2,kg) has unaligned access   [ fluxi.f(330,44) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(331,37) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(331,52) ]
   remark #15389: vectorization support: reference tav_(i,jg-2,kg) has unaligned access   [ fluxi.f(332,29) ]
   remark #15389: vectorization support: reference tav_(i,jg+2,kg) has unaligned access   [ fluxi.f(332,44) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(333,37) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(333,52) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(321,22) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(321,37) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(322,22) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(322,37) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(323,22) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(323,37) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(324,22) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(324,37) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(336,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(337,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(338,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(339,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(341,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(342,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(343,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(344,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(346,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(347,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(348,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(349,24) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(353,22) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(353,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(354,22) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(354,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(355,22) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(355,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(356,22) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(356,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-2) has unaligned access   [ fluxi.f(358,29) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+2) has unaligned access   [ fluxi.f(358,44) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(359,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(359,52) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-2) has unaligned access   [ fluxi.f(360,29) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+2) has unaligned access   [ fluxi.f(360,44) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(361,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(361,52) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-2) has unaligned access   [ fluxi.f(362,29) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+2) has unaligned access   [ fluxi.f(362,44) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(363,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(363,52) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-2) has unaligned access   [ fluxi.f(364,29) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+2) has unaligned access   [ fluxi.f(364,44) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(365,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(365,52) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(368,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(369,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(370,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(371,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(373,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(374,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(375,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(376,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(378,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(379,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(380,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(381,24) ]
   remark #15389: vectorization support: reference t_(i,jg,kg) has unaligned access   [ fluxi.f(383,28) ]
   remark #15389: vectorization support: reference t_(i+1,jg,kg) has unaligned access   [ fluxi.f(383,42) ]
   remark #15389: vectorization support: reference u_(i,jg,kg) has unaligned access   [ fluxi.f(384,28) ]
   remark #15389: vectorization support: reference u_(i+1,jg,kg) has unaligned access   [ fluxi.f(384,42) ]
   remark #15389: vectorization support: reference v_(i,jg,kg) has unaligned access   [ fluxi.f(385,28) ]
   remark #15389: vectorization support: reference v_(i+1,jg,kg) has unaligned access   [ fluxi.f(385,42) ]
   remark #15389: vectorization support: reference w_(i,jg,kg) has unaligned access   [ fluxi.f(386,28) ]
   remark #15389: vectorization support: reference w_(i+1,jg,kg) has unaligned access   [ fluxi.f(386,42) ]
   remark #15389: vectorization support: reference hf_(i,jg,kg,2) has unaligned access   [ fluxi.f(387,28) ]
   remark #15389: vectorization support: reference hf_(i+1,jg,kg,2) has unaligned access   [ fluxi.f(387,42) ]
   remark #15389: vectorization support: reference six_(i,jg,kg) has unaligned access   [ fluxi.f(408,10) ]
   remark #15389: vectorization support: reference siy_(i,jg,kg) has unaligned access   [ fluxi.f(409,10) ]
   remark #15389: vectorization support: reference siz_(i,jg,kg) has unaligned access   [ fluxi.f(410,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,21) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,10) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,21) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,10) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,21) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,10) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,21) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 0.290
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15450: unmasked unaligned unit stride loads: 54 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15456: masked unaligned unit stride loads: 16 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 678 
   remark #15477: vector cost: 165.870 
   remark #15478: estimated potential speedup: 3.800 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at fluxi.f(280,7)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(294,29) ]
   remark #15389: vectorization support: reference u_(ii,jg,kg) has unaligned access   [ fluxi.f(295,37) ]
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(295,50) ]
   remark #15389: vectorization support: reference u_(icd,jg,kg) has unaligned access   [ fluxi.f(294,42) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(296,29) ]
   remark #15389: vectorization support: reference v_(ii,jg,kg) has unaligned access   [ fluxi.f(297,37) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(297,50) ]
   remark #15389: vectorization support: reference v_(icd,jg,kg) has unaligned access   [ fluxi.f(296,42) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(298,29) ]
   remark #15389: vectorization support: reference w_(ii,jg,kg) has unaligned access   [ fluxi.f(299,37) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(299,50) ]
   remark #15389: vectorization support: reference w_(icd,jg,kg) has unaligned access   [ fluxi.f(298,42) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(300,29) ]
   remark #15389: vectorization support: reference t_(ii,jg,kg) has unaligned access   [ fluxi.f(301,37) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(301,50) ]
   remark #15389: vectorization support: reference t_(icd,jg,kg) has unaligned access   [ fluxi.f(300,42) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(304,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(305,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(306,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(307,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(309,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(310,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(311,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(312,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(314,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(315,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(316,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(317,17) ]
   remark #15389: vectorization support: reference uav_(i,jg-2,kg) has unaligned access   [ fluxi.f(326,29) ]
   remark #15389: vectorization support: reference uav_(i,jg+2,kg) has unaligned access   [ fluxi.f(326,44) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(327,37) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(327,52) ]
   remark #15389: vectorization support: reference vav_(i,jg-2,kg) has unaligned access   [ fluxi.f(328,29) ]
   remark #15389: vectorization support: reference vav_(i,jg+2,kg) has unaligned access   [ fluxi.f(328,44) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(329,37) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(329,52) ]
   remark #15389: vectorization support: reference wav_(i,jg-2,kg) has unaligned access   [ fluxi.f(330,29) ]
   remark #15389: vectorization support: reference wav_(i,jg+2,kg) has unaligned access   [ fluxi.f(330,44) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(331,37) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(331,52) ]
   remark #15389: vectorization support: reference tav_(i,jg-2,kg) has unaligned access   [ fluxi.f(332,29) ]
   remark #15389: vectorization support: reference tav_(i,jg+2,kg) has unaligned access   [ fluxi.f(332,44) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(333,37) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(333,52) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(321,22) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(321,37) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(322,22) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(322,37) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(323,22) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(323,37) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(324,22) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(324,37) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(336,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(337,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(338,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(339,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(341,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(342,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(343,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(344,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(346,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(347,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(348,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(349,24) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(353,22) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(353,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(354,22) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(354,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(355,22) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(355,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(356,22) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(356,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-2) has unaligned access   [ fluxi.f(358,29) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+2) has unaligned access   [ fluxi.f(358,44) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(359,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(359,52) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-2) has unaligned access   [ fluxi.f(360,29) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+2) has unaligned access   [ fluxi.f(360,44) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(361,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(361,52) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-2) has unaligned access   [ fluxi.f(362,29) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+2) has unaligned access   [ fluxi.f(362,44) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(363,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(363,52) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-2) has unaligned access   [ fluxi.f(364,29) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+2) has unaligned access   [ fluxi.f(364,44) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(365,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(365,52) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(368,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(369,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(370,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(371,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(373,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(374,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(375,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(376,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(378,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(379,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(380,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(381,24) ]
   remark #15389: vectorization support: reference t_(i,jg,kg) has unaligned access   [ fluxi.f(383,28) ]
   remark #15389: vectorization support: reference t_(i+1,jg,kg) has unaligned access   [ fluxi.f(383,42) ]
   remark #15389: vectorization support: reference u_(i,jg,kg) has unaligned access   [ fluxi.f(384,28) ]
   remark #15389: vectorization support: reference u_(i+1,jg,kg) has unaligned access   [ fluxi.f(384,42) ]
   remark #15389: vectorization support: reference v_(i,jg,kg) has unaligned access   [ fluxi.f(385,28) ]
   remark #15389: vectorization support: reference v_(i+1,jg,kg) has unaligned access   [ fluxi.f(385,42) ]
   remark #15389: vectorization support: reference w_(i,jg,kg) has unaligned access   [ fluxi.f(386,28) ]
   remark #15389: vectorization support: reference w_(i+1,jg,kg) has unaligned access   [ fluxi.f(386,42) ]
   remark #15389: vectorization support: reference hf_(i,jg,kg,2) has unaligned access   [ fluxi.f(387,28) ]
   remark #15389: vectorization support: reference hf_(i+1,jg,kg,2) has unaligned access   [ fluxi.f(387,42) ]
   remark #15389: vectorization support: reference six_(i,jg,kg) has unaligned access   [ fluxi.f(408,10) ]
   remark #15389: vectorization support: reference siy_(i,jg,kg) has unaligned access   [ fluxi.f(409,10) ]
   remark #15389: vectorization support: reference siz_(i,jg,kg) has unaligned access   [ fluxi.f(410,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,21) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,10) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,21) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,10) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,21) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,10) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,21) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 0.267
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15450: unmasked unaligned unit stride loads: 54 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15456: masked unaligned unit stride loads: 16 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 678 
   remark #15477: vector cost: 165.870 
   remark #15478: estimated potential speedup: 3.800 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

    Report from: Code generation optimizations [cg]

fluxi.f(248,18):remark #34051: REGISTER ALLOCATION : [visci_] fluxi.f:248

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rbx rsi rdi r8]
        
    Routine temporaries
        Total         :      30
            Global    :      12
            Local     :      18
        Regenerable   :       1
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: VISCI [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (VISCI) [5/38=13.2%] fluxi.f(248,18)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxi.f(280,7)
<Peeled loop for vectorization>
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(294,29) ]
   remark #15389: vectorization support: reference u_(ii,jg,kg) has unaligned access   [ fluxi.f(295,37) ]
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(295,50) ]
   remark #15389: vectorization support: reference u_(icd,jg,kg) has unaligned access   [ fluxi.f(294,42) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(296,29) ]
   remark #15389: vectorization support: reference v_(ii,jg,kg) has unaligned access   [ fluxi.f(297,37) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(297,50) ]
   remark #15389: vectorization support: reference v_(icd,jg,kg) has unaligned access   [ fluxi.f(296,42) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(298,29) ]
   remark #15389: vectorization support: reference w_(ii,jg,kg) has unaligned access   [ fluxi.f(299,37) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(299,50) ]
   remark #15389: vectorization support: reference w_(icd,jg,kg) has unaligned access   [ fluxi.f(298,42) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(300,29) ]
   remark #15389: vectorization support: reference t_(ii,jg,kg) has unaligned access   [ fluxi.f(301,37) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(301,50) ]
   remark #15389: vectorization support: reference t_(icd,jg,kg) has unaligned access   [ fluxi.f(300,42) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(304,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(305,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(306,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(307,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(309,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(310,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(311,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(312,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(314,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(315,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(316,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(317,17) ]
   remark #15389: vectorization support: reference uav_(i,jg-2,kg) has unaligned access   [ fluxi.f(326,29) ]
   remark #15389: vectorization support: reference uav_(i,jg+2,kg) has unaligned access   [ fluxi.f(326,44) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(327,37) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(327,52) ]
   remark #15389: vectorization support: reference vav_(i,jg-2,kg) has unaligned access   [ fluxi.f(328,29) ]
   remark #15389: vectorization support: reference vav_(i,jg+2,kg) has unaligned access   [ fluxi.f(328,44) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(329,37) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(329,52) ]
   remark #15389: vectorization support: reference wav_(i,jg-2,kg) has unaligned access   [ fluxi.f(330,29) ]
   remark #15389: vectorization support: reference wav_(i,jg+2,kg) has unaligned access   [ fluxi.f(330,44) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(331,37) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(331,52) ]
   remark #15389: vectorization support: reference tav_(i,jg-2,kg) has unaligned access   [ fluxi.f(332,29) ]
   remark #15389: vectorization support: reference tav_(i,jg+2,kg) has unaligned access   [ fluxi.f(332,44) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(333,37) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(333,52) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(321,22) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(321,37) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(322,22) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(322,37) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(323,22) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(323,37) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(324,22) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(324,37) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(336,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(337,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(338,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(339,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(341,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(342,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(343,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(344,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(346,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(347,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(348,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(349,24) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(353,22) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(353,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(354,22) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(354,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(355,22) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(355,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(356,22) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(356,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-2) has unaligned access   [ fluxi.f(358,29) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+2) has unaligned access   [ fluxi.f(358,44) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(359,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(359,52) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-2) has unaligned access   [ fluxi.f(360,29) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+2) has unaligned access   [ fluxi.f(360,44) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(361,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(361,52) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-2) has unaligned access   [ fluxi.f(362,29) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+2) has unaligned access   [ fluxi.f(362,44) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(363,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(363,52) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-2) has unaligned access   [ fluxi.f(364,29) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+2) has unaligned access   [ fluxi.f(364,44) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(365,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(365,52) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(368,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(369,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(370,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(371,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(373,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(374,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(375,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(376,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(378,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(379,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(380,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(381,24) ]
   remark #15389: vectorization support: reference t_(i,jg,kg) has unaligned access   [ fluxi.f(383,28) ]
   remark #15389: vectorization support: reference t_(i+1,jg,kg) has unaligned access   [ fluxi.f(383,42) ]
   remark #15389: vectorization support: reference u_(i,jg,kg) has unaligned access   [ fluxi.f(384,28) ]
   remark #15389: vectorization support: reference u_(i+1,jg,kg) has unaligned access   [ fluxi.f(384,42) ]
   remark #15389: vectorization support: reference v_(i,jg,kg) has unaligned access   [ fluxi.f(385,28) ]
   remark #15389: vectorization support: reference v_(i+1,jg,kg) has unaligned access   [ fluxi.f(385,42) ]
   remark #15389: vectorization support: reference w_(i,jg,kg) has unaligned access   [ fluxi.f(386,28) ]
   remark #15389: vectorization support: reference w_(i+1,jg,kg) has unaligned access   [ fluxi.f(386,42) ]
   remark #15389: vectorization support: reference hf_(i,jg,kg,2) has unaligned access   [ fluxi.f(387,28) ]
   remark #15389: vectorization support: reference hf_(i+1,jg,kg,2) has unaligned access   [ fluxi.f(387,42) ]
   remark #15389: vectorization support: reference six_(i,jg,kg) has unaligned access   [ fluxi.f(408,10) ]
   remark #15389: vectorization support: reference siy_(i,jg,kg) has unaligned access   [ fluxi.f(409,10) ]
   remark #15389: vectorization support: reference siz_(i,jg,kg) has unaligned access   [ fluxi.f(410,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,21) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,10) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,21) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,10) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,21) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,10) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,21) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 0.267
   remark #15301: PEEL LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15450: unmasked unaligned unit stride loads: 54 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15456: masked unaligned unit stride loads: 16 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 678 
   remark #15477: vector cost: 165.870 
   remark #15478: estimated potential speedup: 3.800 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at fluxi.f(280,7)
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(294,29) ]
   remark #15389: vectorization support: reference u_(ii,jg,kg) has unaligned access   [ fluxi.f(295,37) ]
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(295,50) ]
   remark #15389: vectorization support: reference u_(icd,jg,kg) has unaligned access   [ fluxi.f(294,42) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(296,29) ]
   remark #15389: vectorization support: reference v_(ii,jg,kg) has unaligned access   [ fluxi.f(297,37) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(297,50) ]
   remark #15389: vectorization support: reference v_(icd,jg,kg) has unaligned access   [ fluxi.f(296,42) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(298,29) ]
   remark #15389: vectorization support: reference w_(ii,jg,kg) has unaligned access   [ fluxi.f(299,37) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(299,50) ]
   remark #15389: vectorization support: reference w_(icd,jg,kg) has unaligned access   [ fluxi.f(298,42) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(300,29) ]
   remark #15389: vectorization support: reference t_(ii,jg,kg) has unaligned access   [ fluxi.f(301,37) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(301,50) ]
   remark #15389: vectorization support: reference t_(icd,jg,kg) has unaligned access   [ fluxi.f(300,42) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(304,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(305,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(306,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(307,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(309,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(310,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(311,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(312,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(314,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(315,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(316,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(317,17) ]
   remark #15389: vectorization support: reference uav_(i,jg-2,kg) has unaligned access   [ fluxi.f(326,29) ]
   remark #15389: vectorization support: reference uav_(i,jg+2,kg) has unaligned access   [ fluxi.f(326,44) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(327,37) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(327,52) ]
   remark #15389: vectorization support: reference vav_(i,jg-2,kg) has unaligned access   [ fluxi.f(328,29) ]
   remark #15389: vectorization support: reference vav_(i,jg+2,kg) has unaligned access   [ fluxi.f(328,44) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(329,37) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(329,52) ]
   remark #15389: vectorization support: reference wav_(i,jg-2,kg) has unaligned access   [ fluxi.f(330,29) ]
   remark #15389: vectorization support: reference wav_(i,jg+2,kg) has unaligned access   [ fluxi.f(330,44) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(331,37) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(331,52) ]
   remark #15389: vectorization support: reference tav_(i,jg-2,kg) has unaligned access   [ fluxi.f(332,29) ]
   remark #15389: vectorization support: reference tav_(i,jg+2,kg) has unaligned access   [ fluxi.f(332,44) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(333,37) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(333,52) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(321,22) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(321,37) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(322,22) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(322,37) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(323,22) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(323,37) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(324,22) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(324,37) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(336,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(337,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(338,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(339,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(341,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(342,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(343,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(344,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(346,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(347,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(348,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(349,24) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(353,22) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(353,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(354,22) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(354,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(355,22) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(355,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(356,22) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(356,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-2) has unaligned access   [ fluxi.f(358,29) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+2) has unaligned access   [ fluxi.f(358,44) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(359,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(359,52) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-2) has unaligned access   [ fluxi.f(360,29) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+2) has unaligned access   [ fluxi.f(360,44) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(361,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(361,52) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-2) has unaligned access   [ fluxi.f(362,29) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+2) has unaligned access   [ fluxi.f(362,44) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(363,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(363,52) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-2) has unaligned access   [ fluxi.f(364,29) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+2) has unaligned access   [ fluxi.f(364,44) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(365,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(365,52) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(368,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(369,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(370,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(371,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(373,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(374,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(375,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(376,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(378,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(379,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(380,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(381,24) ]
   remark #15389: vectorization support: reference t_(i,jg,kg) has unaligned access   [ fluxi.f(383,28) ]
   remark #15389: vectorization support: reference t_(i+1,jg,kg) has unaligned access   [ fluxi.f(383,42) ]
   remark #15389: vectorization support: reference u_(i,jg,kg) has unaligned access   [ fluxi.f(384,28) ]
   remark #15389: vectorization support: reference u_(i+1,jg,kg) has unaligned access   [ fluxi.f(384,42) ]
   remark #15389: vectorization support: reference v_(i,jg,kg) has unaligned access   [ fluxi.f(385,28) ]
   remark #15389: vectorization support: reference v_(i+1,jg,kg) has unaligned access   [ fluxi.f(385,42) ]
   remark #15389: vectorization support: reference w_(i,jg,kg) has unaligned access   [ fluxi.f(386,28) ]
   remark #15389: vectorization support: reference w_(i+1,jg,kg) has unaligned access   [ fluxi.f(386,42) ]
   remark #15389: vectorization support: reference hf_(i,jg,kg,2) has unaligned access   [ fluxi.f(387,28) ]
   remark #15389: vectorization support: reference hf_(i+1,jg,kg,2) has unaligned access   [ fluxi.f(387,42) ]
   remark #15389: vectorization support: reference six_(i,jg,kg) has unaligned access   [ fluxi.f(408,10) ]
   remark #15389: vectorization support: reference siy_(i,jg,kg) has unaligned access   [ fluxi.f(409,10) ]
   remark #15389: vectorization support: reference siz_(i,jg,kg) has unaligned access   [ fluxi.f(410,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,21) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,10) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,21) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,10) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,21) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,10) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,21) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 0.290
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15450: unmasked unaligned unit stride loads: 54 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15456: masked unaligned unit stride loads: 16 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 678 
   remark #15477: vector cost: 165.870 
   remark #15478: estimated potential speedup: 3.800 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at fluxi.f(280,7)
<Remainder loop for vectorization>
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(294,29) ]
   remark #15389: vectorization support: reference u_(ii,jg,kg) has unaligned access   [ fluxi.f(295,37) ]
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(295,50) ]
   remark #15389: vectorization support: reference u_(icd,jg,kg) has unaligned access   [ fluxi.f(294,42) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(296,29) ]
   remark #15389: vectorization support: reference v_(ii,jg,kg) has unaligned access   [ fluxi.f(297,37) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(297,50) ]
   remark #15389: vectorization support: reference v_(icd,jg,kg) has unaligned access   [ fluxi.f(296,42) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(298,29) ]
   remark #15389: vectorization support: reference w_(ii,jg,kg) has unaligned access   [ fluxi.f(299,37) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(299,50) ]
   remark #15389: vectorization support: reference w_(icd,jg,kg) has unaligned access   [ fluxi.f(298,42) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(300,29) ]
   remark #15389: vectorization support: reference t_(ii,jg,kg) has unaligned access   [ fluxi.f(301,37) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(301,50) ]
   remark #15389: vectorization support: reference t_(icd,jg,kg) has unaligned access   [ fluxi.f(300,42) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(304,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(305,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(306,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(307,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(309,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(310,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(311,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(312,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(314,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(315,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(316,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(317,17) ]
   remark #15389: vectorization support: reference uav_(i,jg-2,kg) has unaligned access   [ fluxi.f(326,29) ]
   remark #15389: vectorization support: reference uav_(i,jg+2,kg) has unaligned access   [ fluxi.f(326,44) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(327,37) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(327,52) ]
   remark #15389: vectorization support: reference vav_(i,jg-2,kg) has unaligned access   [ fluxi.f(328,29) ]
   remark #15389: vectorization support: reference vav_(i,jg+2,kg) has unaligned access   [ fluxi.f(328,44) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(329,37) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(329,52) ]
   remark #15389: vectorization support: reference wav_(i,jg-2,kg) has unaligned access   [ fluxi.f(330,29) ]
   remark #15389: vectorization support: reference wav_(i,jg+2,kg) has unaligned access   [ fluxi.f(330,44) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(331,37) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(331,52) ]
   remark #15389: vectorization support: reference tav_(i,jg-2,kg) has unaligned access   [ fluxi.f(332,29) ]
   remark #15389: vectorization support: reference tav_(i,jg+2,kg) has unaligned access   [ fluxi.f(332,44) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(333,37) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(333,52) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(321,22) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(321,37) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(322,22) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(322,37) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(323,22) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(323,37) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(324,22) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(324,37) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(336,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(337,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(338,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(339,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(341,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(342,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(343,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(344,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(346,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(347,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(348,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(349,24) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(353,22) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(353,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(354,22) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(354,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(355,22) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(355,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(356,22) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(356,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-2) has unaligned access   [ fluxi.f(358,29) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+2) has unaligned access   [ fluxi.f(358,44) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(359,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(359,52) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-2) has unaligned access   [ fluxi.f(360,29) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+2) has unaligned access   [ fluxi.f(360,44) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(361,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(361,52) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-2) has unaligned access   [ fluxi.f(362,29) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+2) has unaligned access   [ fluxi.f(362,44) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(363,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(363,52) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-2) has unaligned access   [ fluxi.f(364,29) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+2) has unaligned access   [ fluxi.f(364,44) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(365,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(365,52) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(368,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(369,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(370,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(371,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(373,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(374,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(375,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(376,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(378,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(379,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(380,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(381,24) ]
   remark #15389: vectorization support: reference t_(i,jg,kg) has unaligned access   [ fluxi.f(383,28) ]
   remark #15389: vectorization support: reference t_(i+1,jg,kg) has unaligned access   [ fluxi.f(383,42) ]
   remark #15389: vectorization support: reference u_(i,jg,kg) has unaligned access   [ fluxi.f(384,28) ]
   remark #15389: vectorization support: reference u_(i+1,jg,kg) has unaligned access   [ fluxi.f(384,42) ]
   remark #15389: vectorization support: reference v_(i,jg,kg) has unaligned access   [ fluxi.f(385,28) ]
   remark #15389: vectorization support: reference v_(i+1,jg,kg) has unaligned access   [ fluxi.f(385,42) ]
   remark #15389: vectorization support: reference w_(i,jg,kg) has unaligned access   [ fluxi.f(386,28) ]
   remark #15389: vectorization support: reference w_(i+1,jg,kg) has unaligned access   [ fluxi.f(386,42) ]
   remark #15389: vectorization support: reference hf_(i,jg,kg,2) has unaligned access   [ fluxi.f(387,28) ]
   remark #15389: vectorization support: reference hf_(i+1,jg,kg,2) has unaligned access   [ fluxi.f(387,42) ]
   remark #15389: vectorization support: reference six_(i,jg,kg) has unaligned access   [ fluxi.f(408,10) ]
   remark #15389: vectorization support: reference siy_(i,jg,kg) has unaligned access   [ fluxi.f(409,10) ]
   remark #15389: vectorization support: reference siz_(i,jg,kg) has unaligned access   [ fluxi.f(410,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,21) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,10) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,21) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,10) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,21) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,10) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,21) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 8
   remark #15309: vectorization support: normalized vectorization overhead 0.267
   remark #15301: REMAINDER LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15450: unmasked unaligned unit stride loads: 54 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15456: masked unaligned unit stride loads: 16 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 678 
   remark #15477: vector cost: 165.870 
   remark #15478: estimated potential speedup: 3.800 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

    Report from: Code generation optimizations [cg]

fluxi.f(383,28):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(383,28):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(383,28):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(383,28):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(384,28):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(384,28):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(384,28):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(384,28):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(385,28):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(385,28):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(385,28):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(385,28):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(386,28):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(386,28):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(386,28):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(386,28):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(387,28):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(387,28):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(387,28):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
fluxi.f(387,28):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
fluxi.f(383,28):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
fluxi.f(384,28):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
fluxi.f(385,28):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
fluxi.f(386,28):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
fluxi.f(387,28):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
fluxi.f(248,18):remark #34051: REGISTER ALLOCATION : [visci_.h] fluxi.f:248

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   53[ rax rdx rcx rsi rdi r8-r15 zmm0-zmm31 k0-k7]
        
    Routine temporaries
        Total         :    2317
            Global    :     488
            Local     :    1829
        Regenerable   :      30
        Spilled       :     330
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :    2664 bytes*
            Reads     :     630 [8.89e+02 ~ 13.7%]
            Writes    :     387 [1.90e+02 ~ 2.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: VISCI [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (VISCI) [5/38=13.2%] fluxi.f(248,18)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxi.f(280,7)
<Peeled loop for vectorization>
   remark #25015: Estimate of max trip count of loop=3
LOOP END

LOOP BEGIN at fluxi.f(280,7)
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(294,29) ]
   remark #15389: vectorization support: reference u_(ii,jg,kg) has unaligned access   [ fluxi.f(295,37) ]
   remark #15389: vectorization support: reference u_(ibd,jg,kg) has unaligned access   [ fluxi.f(295,50) ]
   remark #15389: vectorization support: reference u_(icd,jg,kg) has unaligned access   [ fluxi.f(294,42) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(296,29) ]
   remark #15389: vectorization support: reference v_(ii,jg,kg) has unaligned access   [ fluxi.f(297,37) ]
   remark #15389: vectorization support: reference v_(ibd,jg,kg) has unaligned access   [ fluxi.f(297,50) ]
   remark #15389: vectorization support: reference v_(icd,jg,kg) has unaligned access   [ fluxi.f(296,42) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(298,29) ]
   remark #15389: vectorization support: reference w_(ii,jg,kg) has unaligned access   [ fluxi.f(299,37) ]
   remark #15389: vectorization support: reference w_(ibd,jg,kg) has unaligned access   [ fluxi.f(299,50) ]
   remark #15389: vectorization support: reference w_(icd,jg,kg) has unaligned access   [ fluxi.f(298,42) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(300,29) ]
   remark #15389: vectorization support: reference t_(ii,jg,kg) has unaligned access   [ fluxi.f(301,37) ]
   remark #15389: vectorization support: reference t_(ibd,jg,kg) has unaligned access   [ fluxi.f(301,50) ]
   remark #15389: vectorization support: reference t_(icd,jg,kg) has unaligned access   [ fluxi.f(300,42) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(304,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(305,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(306,17) ]
   remark #15389: vectorization support: reference t11_(i,jg,kg,1) has unaligned access   [ fluxi.f(307,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(309,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(310,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(311,17) ]
   remark #15389: vectorization support: reference t21_(i,jg,kg,1) has unaligned access   [ fluxi.f(312,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(314,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(315,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(316,17) ]
   remark #15389: vectorization support: reference t31_(i,jg,kg,1) has unaligned access   [ fluxi.f(317,17) ]
   remark #15389: vectorization support: reference uav_(i,jg-2,kg) has unaligned access   [ fluxi.f(326,29) ]
   remark #15389: vectorization support: reference uav_(i,jg+2,kg) has unaligned access   [ fluxi.f(326,44) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(327,37) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(327,52) ]
   remark #15389: vectorization support: reference vav_(i,jg-2,kg) has unaligned access   [ fluxi.f(328,29) ]
   remark #15389: vectorization support: reference vav_(i,jg+2,kg) has unaligned access   [ fluxi.f(328,44) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(329,37) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(329,52) ]
   remark #15389: vectorization support: reference wav_(i,jg-2,kg) has unaligned access   [ fluxi.f(330,29) ]
   remark #15389: vectorization support: reference wav_(i,jg+2,kg) has unaligned access   [ fluxi.f(330,44) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(331,37) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(331,52) ]
   remark #15389: vectorization support: reference tav_(i,jg-2,kg) has unaligned access   [ fluxi.f(332,29) ]
   remark #15389: vectorization support: reference tav_(i,jg+2,kg) has unaligned access   [ fluxi.f(332,44) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(333,37) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(333,52) ]
   remark #15389: vectorization support: reference uav_(i,jg+1,kg) has unaligned access   [ fluxi.f(321,22) ]
   remark #15389: vectorization support: reference uav_(i,jg-1,kg) has unaligned access   [ fluxi.f(321,37) ]
   remark #15389: vectorization support: reference vav_(i,jg+1,kg) has unaligned access   [ fluxi.f(322,22) ]
   remark #15389: vectorization support: reference vav_(i,jg-1,kg) has unaligned access   [ fluxi.f(322,37) ]
   remark #15389: vectorization support: reference wav_(i,jg+1,kg) has unaligned access   [ fluxi.f(323,22) ]
   remark #15389: vectorization support: reference wav_(i,jg-1,kg) has unaligned access   [ fluxi.f(323,37) ]
   remark #15389: vectorization support: reference tav_(i,jg+1,kg) has unaligned access   [ fluxi.f(324,22) ]
   remark #15389: vectorization support: reference tav_(i,jg-1,kg) has unaligned access   [ fluxi.f(324,37) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(336,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(337,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(338,24) ]
   remark #15389: vectorization support: reference t12_(i,jg,kg,1) has unaligned access   [ fluxi.f(339,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(341,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(342,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(343,24) ]
   remark #15389: vectorization support: reference t22_(i,jg,kg,1) has unaligned access   [ fluxi.f(344,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(346,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(347,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(348,24) ]
   remark #15389: vectorization support: reference t32_(i,jg,kg,1) has unaligned access   [ fluxi.f(349,24) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(353,22) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(353,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(354,22) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(354,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(355,22) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(355,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(356,22) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(356,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-2) has unaligned access   [ fluxi.f(358,29) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+2) has unaligned access   [ fluxi.f(358,44) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg+1) has unaligned access   [ fluxi.f(359,37) ]
   remark #15389: vectorization support: reference uav_(i,jg,kg-1) has unaligned access   [ fluxi.f(359,52) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-2) has unaligned access   [ fluxi.f(360,29) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+2) has unaligned access   [ fluxi.f(360,44) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg+1) has unaligned access   [ fluxi.f(361,37) ]
   remark #15389: vectorization support: reference vav_(i,jg,kg-1) has unaligned access   [ fluxi.f(361,52) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-2) has unaligned access   [ fluxi.f(362,29) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+2) has unaligned access   [ fluxi.f(362,44) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg+1) has unaligned access   [ fluxi.f(363,37) ]
   remark #15389: vectorization support: reference wav_(i,jg,kg-1) has unaligned access   [ fluxi.f(363,52) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-2) has unaligned access   [ fluxi.f(364,29) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+2) has unaligned access   [ fluxi.f(364,44) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg+1) has unaligned access   [ fluxi.f(365,37) ]
   remark #15389: vectorization support: reference tav_(i,jg,kg-1) has unaligned access   [ fluxi.f(365,52) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(368,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(369,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(370,24) ]
   remark #15389: vectorization support: reference t13_(i,jg,kg,1) has unaligned access   [ fluxi.f(371,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(373,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(374,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(375,24) ]
   remark #15389: vectorization support: reference t23_(i,jg,kg,1) has unaligned access   [ fluxi.f(376,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(378,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(379,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(380,24) ]
   remark #15389: vectorization support: reference t33_(i,jg,kg,1) has unaligned access   [ fluxi.f(381,24) ]
   remark #15389: vectorization support: reference t_(i,jg,kg) has unaligned access   [ fluxi.f(383,28) ]
   remark #15389: vectorization support: reference t_(i+1,jg,kg) has unaligned access   [ fluxi.f(383,42) ]
   remark #15389: vectorization support: reference u_(i,jg,kg) has unaligned access   [ fluxi.f(384,28) ]
   remark #15389: vectorization support: reference u_(i+1,jg,kg) has unaligned access   [ fluxi.f(384,42) ]
   remark #15389: vectorization support: reference v_(i,jg,kg) has unaligned access   [ fluxi.f(385,28) ]
   remark #15389: vectorization support: reference v_(i+1,jg,kg) has unaligned access   [ fluxi.f(385,42) ]
   remark #15389: vectorization support: reference w_(i,jg,kg) has unaligned access   [ fluxi.f(386,28) ]
   remark #15389: vectorization support: reference w_(i+1,jg,kg) has unaligned access   [ fluxi.f(386,42) ]
   remark #15389: vectorization support: reference hf_(i,jg,kg,2) has unaligned access   [ fluxi.f(387,28) ]
   remark #15389: vectorization support: reference hf_(i+1,jg,kg,2) has unaligned access   [ fluxi.f(387,42) ]
   remark #15389: vectorization support: reference six_(i,jg,kg) has unaligned access   [ fluxi.f(408,10) ]
   remark #15389: vectorization support: reference siy_(i,jg,kg) has unaligned access   [ fluxi.f(409,10) ]
   remark #15389: vectorization support: reference siz_(i,jg,kg) has unaligned access   [ fluxi.f(410,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,10) ]
   remark #15389: vectorization support: reference fsi(i,2) has unaligned access   [ fluxi.f(412,21) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,10) ]
   remark #15389: vectorization support: reference fsi(i,3) has unaligned access   [ fluxi.f(413,21) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,10) ]
   remark #15389: vectorization support: reference fsi(i,4) has unaligned access   [ fluxi.f(414,21) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,10) ]
   remark #15389: vectorization support: reference fsi(i,5) has unaligned access   [ fluxi.f(415,21) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.318
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15450: unmasked unaligned unit stride loads: 54 
   remark #15451: unmasked unaligned unit stride stores: 4 
   remark #15456: masked unaligned unit stride loads: 16 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 678 
   remark #15477: vector cost: 302.250 
   remark #15478: estimated potential speedup: 2.190 
   remark #15486: divides: 1 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at fluxi.f(280,7)
<Remainder loop for vectorization>
LOOP END

    Report from: Code generation optimizations [cg]

fluxi.f(248,18):remark #34051: REGISTER ALLOCATION : [visci_.A] fluxi.f:248

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   29[ rax rdx rcx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :    1671
            Global    :     364
            Local     :    1307
        Regenerable   :      20
        Spilled       :     291
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :    2680 bytes*
            Reads     :     650 [1.20e+03 ~ 24.3%]
            Writes    :     439 [4.46e+02 ~ 9.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: FLUXJ

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (FLUXJ) [6/38=15.8%] fluxj.f(1,18)
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_alloc_allocatable
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_alloc_allocatable
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> INLINE: (25,27) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> (28,12) EXTRAPJ (isz = 2058) (sz = 2061)
     [[ Inlining would exceed -inline-max-size value (2061>230) <2>]]
  -> INLINE: (58,27) VISCJ (isz = 1807) (sz = 1820)
  -> EXTERN: (69,7) for_dealloc_allocatable
  -> EXTERN: (69,7) for_dealloc_allocatable
  -> EXTERN: (72,7) for_dealloc_allocatable
  -> EXTERN: (72,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxj.f(30,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxj.f(31,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxj.f(33,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.711
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(33,13)
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.560
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 17 
         remark #15477: vector cost: 3.120 
         remark #15478: estimated potential speedup: 4.960 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(33,13)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.690
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(48,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference FSJ(:,j,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference FSJ(:,j,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.606
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(48,12)
         remark #25045: Fused Loops: ( 48 49 51 53 55 )

         remark #15389: vectorization support: reference FSJ(:,j,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference FSJ(:,j,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.722
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15450: unmasked unaligned unit stride loads: 10 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 50 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 5.110 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
      LOOP END

      LOOP BEGIN at fluxj.f(49,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(51,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(53,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(55,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(276,7) inlined into fluxj.f(58,27)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxj.f(296,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxj.f(296,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxj.f(297,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxj.f(297,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxj.f(298,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxj.f(298,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxj.f(299,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxj.f(299,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxj.f(300,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxj.f(300,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxj.f(301,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxj.f(301,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxj.f(302,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxj.f(302,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxj.f(303,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxj.f(303,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(306,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(307,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(308,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(309,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(311,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(312,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(313,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(314,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(316,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(317,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(318,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(319,17) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(329,29) ]
         remark #15389: vectorization support: reference u_(i,jcd,k) has unaligned access   [ fluxj.f(329,42) ]
         remark #15389: vectorization support: reference u_(i,jj,k) has unaligned access   [ fluxj.f(330,32) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(330,45) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(331,29) ]
         remark #15389: vectorization support: reference v_(i,jcd,k) has unaligned access   [ fluxj.f(331,42) ]
         remark #15389: vectorization support: reference v_(i,jj,k) has unaligned access   [ fluxj.f(332,32) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(332,45) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(333,29) ]
         remark #15389: vectorization support: reference w_(i,jcd,k) has unaligned access   [ fluxj.f(333,42) ]
         remark #15389: vectorization support: reference w_(i,jj,k) has unaligned access   [ fluxj.f(334,32) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(334,45) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(335,29) ]
         remark #15389: vectorization support: reference t_(i,jcd,k) has unaligned access   [ fluxj.f(335,42) ]
         remark #15389: vectorization support: reference t_(i,jj,k) has unaligned access   [ fluxj.f(336,32) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(336,45) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(324,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(324,34) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(325,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(325,34) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(326,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(326,34) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(327,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(327,34) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(339,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(340,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(341,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(342,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(344,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(345,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(346,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(347,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(349,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(350,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(351,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(352,24) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(357,22) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(357,37) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(358,22) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(358,37) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(359,22) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(359,37) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(360,22) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(360,37) ]
         remark #15389: vectorization support: reference uav_(i,j,k-2) has unaligned access   [ fluxj.f(362,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k+2) has unaligned access   [ fluxj.f(362,44) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(363,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(363,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k-2) has unaligned access   [ fluxj.f(364,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k+2) has unaligned access   [ fluxj.f(364,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(365,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(365,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k-2) has unaligned access   [ fluxj.f(366,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k+2) has unaligned access   [ fluxj.f(366,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(367,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(367,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k-2) has unaligned access   [ fluxj.f(368,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k+2) has unaligned access   [ fluxj.f(368,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(369,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(369,44) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(372,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(373,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(374,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(375,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(377,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(378,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(379,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(380,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(382,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(383,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(384,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(385,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(387,24) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(387,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(388,24) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(388,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(389,24) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(389,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(390,24) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(390,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxj.f(391,24) ]
         remark #15389: vectorization support: reference hf_(i,j+1,k,2) has unaligned access   [ fluxj.f(391,38) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ fluxj.f(412,10) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ fluxj.f(413,10) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ fluxj.f(414,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.269
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(276,7) inlined into fluxj.f(58,27)
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxj.f(296,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxj.f(296,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxj.f(297,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxj.f(297,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxj.f(298,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxj.f(298,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxj.f(299,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxj.f(299,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxj.f(300,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxj.f(300,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxj.f(301,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxj.f(301,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxj.f(302,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxj.f(302,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxj.f(303,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxj.f(303,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(306,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(307,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(308,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(309,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(311,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(312,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(313,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(314,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(316,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(317,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(318,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(319,17) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(329,29) ]
         remark #15389: vectorization support: reference u_(i,jcd,k) has unaligned access   [ fluxj.f(329,42) ]
         remark #15389: vectorization support: reference u_(i,jj,k) has unaligned access   [ fluxj.f(330,32) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(330,45) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(331,29) ]
         remark #15389: vectorization support: reference v_(i,jcd,k) has unaligned access   [ fluxj.f(331,42) ]
         remark #15389: vectorization support: reference v_(i,jj,k) has unaligned access   [ fluxj.f(332,32) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(332,45) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(333,29) ]
         remark #15389: vectorization support: reference w_(i,jcd,k) has unaligned access   [ fluxj.f(333,42) ]
         remark #15389: vectorization support: reference w_(i,jj,k) has unaligned access   [ fluxj.f(334,32) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(334,45) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(335,29) ]
         remark #15389: vectorization support: reference t_(i,jcd,k) has unaligned access   [ fluxj.f(335,42) ]
         remark #15389: vectorization support: reference t_(i,jj,k) has unaligned access   [ fluxj.f(336,32) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(336,45) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(324,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(324,34) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(325,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(325,34) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(326,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(326,34) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(327,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(327,34) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(339,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(340,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(341,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(342,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(344,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(345,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(346,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(347,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(349,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(350,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(351,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(352,24) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(357,22) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(357,37) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(358,22) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(358,37) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(359,22) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(359,37) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(360,22) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(360,37) ]
         remark #15389: vectorization support: reference uav_(i,j,k-2) has unaligned access   [ fluxj.f(362,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k+2) has unaligned access   [ fluxj.f(362,44) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(363,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(363,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k-2) has unaligned access   [ fluxj.f(364,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k+2) has unaligned access   [ fluxj.f(364,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(365,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(365,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k-2) has unaligned access   [ fluxj.f(366,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k+2) has unaligned access   [ fluxj.f(366,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(367,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(367,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k-2) has unaligned access   [ fluxj.f(368,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k+2) has unaligned access   [ fluxj.f(368,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(369,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(369,44) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(372,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(373,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(374,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(375,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(377,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(378,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(379,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(380,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(382,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(383,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(384,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(385,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(387,24) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(387,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(388,24) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(388,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(389,24) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(389,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(390,24) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(390,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxj.f(391,24) ]
         remark #15389: vectorization support: reference hf_(i,j+1,k,2) has unaligned access   [ fluxj.f(391,38) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ fluxj.f(412,10) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ fluxj.f(413,10) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ fluxj.f(414,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.298
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 50 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15456: masked unaligned unit stride loads: 24 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 658 
         remark #15477: vector cost: 166.370 
         remark #15478: estimated potential speedup: 3.680 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 27
      LOOP END

      LOOP BEGIN at fluxj.f(276,7) inlined into fluxj.f(58,27)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxj.f(296,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxj.f(296,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxj.f(297,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxj.f(297,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxj.f(298,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxj.f(298,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxj.f(299,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxj.f(299,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxj.f(300,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxj.f(300,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxj.f(301,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxj.f(301,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxj.f(302,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxj.f(302,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxj.f(303,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxj.f(303,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(306,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(307,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(308,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(309,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(311,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(312,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(313,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(314,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(316,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(317,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(318,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(319,17) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(329,29) ]
         remark #15389: vectorization support: reference u_(i,jcd,k) has unaligned access   [ fluxj.f(329,42) ]
         remark #15389: vectorization support: reference u_(i,jj,k) has unaligned access   [ fluxj.f(330,32) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(330,45) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(331,29) ]
         remark #15389: vectorization support: reference v_(i,jcd,k) has unaligned access   [ fluxj.f(331,42) ]
         remark #15389: vectorization support: reference v_(i,jj,k) has unaligned access   [ fluxj.f(332,32) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(332,45) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(333,29) ]
         remark #15389: vectorization support: reference w_(i,jcd,k) has unaligned access   [ fluxj.f(333,42) ]
         remark #15389: vectorization support: reference w_(i,jj,k) has unaligned access   [ fluxj.f(334,32) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(334,45) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(335,29) ]
         remark #15389: vectorization support: reference t_(i,jcd,k) has unaligned access   [ fluxj.f(335,42) ]
         remark #15389: vectorization support: reference t_(i,jj,k) has unaligned access   [ fluxj.f(336,32) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(336,45) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(324,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(324,34) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(325,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(325,34) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(326,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(326,34) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(327,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(327,34) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(339,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(340,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(341,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(342,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(344,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(345,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(346,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(347,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(349,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(350,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(351,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(352,24) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(357,22) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(357,37) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(358,22) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(358,37) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(359,22) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(359,37) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(360,22) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(360,37) ]
         remark #15389: vectorization support: reference uav_(i,j,k-2) has unaligned access   [ fluxj.f(362,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k+2) has unaligned access   [ fluxj.f(362,44) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(363,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(363,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k-2) has unaligned access   [ fluxj.f(364,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k+2) has unaligned access   [ fluxj.f(364,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(365,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(365,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k-2) has unaligned access   [ fluxj.f(366,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k+2) has unaligned access   [ fluxj.f(366,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(367,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(367,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k-2) has unaligned access   [ fluxj.f(368,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k+2) has unaligned access   [ fluxj.f(368,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(369,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(369,44) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(372,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(373,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(374,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(375,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(377,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(378,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(379,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(380,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(382,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(383,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(384,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(385,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(387,24) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(387,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(388,24) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(388,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(389,24) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(389,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(390,24) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(390,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxj.f(391,24) ]
         remark #15389: vectorization support: reference hf_(i,j+1,k,2) has unaligned access   [ fluxj.f(391,38) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ fluxj.f(412,10) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ fluxj.f(413,10) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ fluxj.f(414,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.269
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(48,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference FSJ(:,j,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference FSJ(:,j,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.606
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END

   LOOP BEGIN at fluxj.f(61,9)
   <Distributed chunk1>
      remark #25426: Loop Distributed (2 way) 
      remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
      remark #25452: Original Order found to be proper, but by a close margin
      remark #25084: Preprocess Loopnests: Moving Out Store    [ fluxj.f(65,12) ]
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between l (62:12) and l (65:12)
      remark #15346: vector dependence: assumed OUTPUT dependence between l (65:12) and l (62:12)

      LOOP BEGIN at fluxj.f(63,15)
      <Distributed chunk2>
         remark #25436: completely unrolled by 5   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at fluxj.f(61,9)
   <Distributed chunk2>
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxj.f(63,15)
      <Distributed chunk1>
         remark #25426: Loop Distributed (2 way) 
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(63,15)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j,l) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: peel loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 0.356
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 1.870 
            remark #15478: estimated potential speedup: 5.810 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=7
         LOOP END

         LOOP BEGIN at fluxj.f(63,15)
            remark #15388: vectorization support: reference dq_(:,j,k,l) has aligned access
            remark #15388: vectorization support: reference dq_(:,j,k,l) has aligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j,l) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.633
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 1.870 
            remark #15478: estimated potential speedup: 5.810 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxj.f(63,15)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j,l) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.788
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 1.870 
            remark #15478: estimated potential speedup: 5.810 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxj.f(1,18):remark #34051: REGISTER ALLOCATION : [fluxj_] fluxj.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdx]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: FLUXJ [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (FLUXJ) [6/38=15.8%] fluxj.f(1,18)
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_alloc_allocatable
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_alloc_allocatable
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> INLINE: (25,27) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> (28,12) EXTRAPJ (isz = 2058) (sz = 2061)
     [[ Inlining would exceed -inline-max-size value (2061>230) <2>]]
  -> INLINE: (58,27) VISCJ (isz = 1807) (sz = 1820)
  -> EXTERN: (69,7) for_dealloc_allocatable
  -> EXTERN: (69,7) for_dealloc_allocatable
  -> EXTERN: (72,7) for_dealloc_allocatable
  -> EXTERN: (72,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxj.f(30,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxj.f(31,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxj.f(33,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.711
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(33,13)
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.560
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 17 
         remark #15477: vector cost: 3.120 
         remark #15478: estimated potential speedup: 4.960 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(33,13)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.690
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(48,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference FSJ(:,j,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference FSJ(:,j,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.606
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(48,12)
         remark #25045: Fused Loops: ( 48 49 51 53 55 )

         remark #15389: vectorization support: reference FSJ(:,j,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference FSJ(:,j,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.722
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15450: unmasked unaligned unit stride loads: 10 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 50 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 5.110 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
      LOOP END

      LOOP BEGIN at fluxj.f(49,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(51,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(53,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(55,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(276,7) inlined into fluxj.f(58,27)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxj.f(296,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxj.f(296,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxj.f(297,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxj.f(297,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxj.f(298,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxj.f(298,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxj.f(299,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxj.f(299,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxj.f(300,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxj.f(300,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxj.f(301,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxj.f(301,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxj.f(302,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxj.f(302,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxj.f(303,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxj.f(303,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(306,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(307,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(308,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(309,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(311,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(312,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(313,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(314,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(316,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(317,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(318,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(319,17) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(329,29) ]
         remark #15389: vectorization support: reference u_(i,jcd,k) has unaligned access   [ fluxj.f(329,42) ]
         remark #15389: vectorization support: reference u_(i,jj,k) has unaligned access   [ fluxj.f(330,32) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(330,45) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(331,29) ]
         remark #15389: vectorization support: reference v_(i,jcd,k) has unaligned access   [ fluxj.f(331,42) ]
         remark #15389: vectorization support: reference v_(i,jj,k) has unaligned access   [ fluxj.f(332,32) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(332,45) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(333,29) ]
         remark #15389: vectorization support: reference w_(i,jcd,k) has unaligned access   [ fluxj.f(333,42) ]
         remark #15389: vectorization support: reference w_(i,jj,k) has unaligned access   [ fluxj.f(334,32) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(334,45) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(335,29) ]
         remark #15389: vectorization support: reference t_(i,jcd,k) has unaligned access   [ fluxj.f(335,42) ]
         remark #15389: vectorization support: reference t_(i,jj,k) has unaligned access   [ fluxj.f(336,32) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(336,45) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(324,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(324,34) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(325,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(325,34) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(326,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(326,34) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(327,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(327,34) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(339,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(340,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(341,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(342,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(344,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(345,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(346,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(347,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(349,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(350,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(351,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(352,24) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(357,22) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(357,37) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(358,22) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(358,37) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(359,22) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(359,37) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(360,22) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(360,37) ]
         remark #15389: vectorization support: reference uav_(i,j,k-2) has unaligned access   [ fluxj.f(362,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k+2) has unaligned access   [ fluxj.f(362,44) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(363,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(363,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k-2) has unaligned access   [ fluxj.f(364,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k+2) has unaligned access   [ fluxj.f(364,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(365,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(365,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k-2) has unaligned access   [ fluxj.f(366,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k+2) has unaligned access   [ fluxj.f(366,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(367,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(367,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k-2) has unaligned access   [ fluxj.f(368,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k+2) has unaligned access   [ fluxj.f(368,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(369,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(369,44) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(372,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(373,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(374,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(375,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(377,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(378,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(379,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(380,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(382,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(383,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(384,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(385,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(387,24) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(387,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(388,24) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(388,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(389,24) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(389,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(390,24) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(390,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxj.f(391,24) ]
         remark #15389: vectorization support: reference hf_(i,j+1,k,2) has unaligned access   [ fluxj.f(391,38) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ fluxj.f(412,10) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ fluxj.f(413,10) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ fluxj.f(414,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.269
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(276,7) inlined into fluxj.f(58,27)
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxj.f(296,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxj.f(296,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxj.f(297,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxj.f(297,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxj.f(298,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxj.f(298,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxj.f(299,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxj.f(299,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxj.f(300,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxj.f(300,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxj.f(301,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxj.f(301,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxj.f(302,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxj.f(302,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxj.f(303,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxj.f(303,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(306,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(307,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(308,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(309,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(311,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(312,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(313,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(314,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(316,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(317,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(318,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(319,17) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(329,29) ]
         remark #15389: vectorization support: reference u_(i,jcd,k) has unaligned access   [ fluxj.f(329,42) ]
         remark #15389: vectorization support: reference u_(i,jj,k) has unaligned access   [ fluxj.f(330,32) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(330,45) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(331,29) ]
         remark #15389: vectorization support: reference v_(i,jcd,k) has unaligned access   [ fluxj.f(331,42) ]
         remark #15389: vectorization support: reference v_(i,jj,k) has unaligned access   [ fluxj.f(332,32) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(332,45) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(333,29) ]
         remark #15389: vectorization support: reference w_(i,jcd,k) has unaligned access   [ fluxj.f(333,42) ]
         remark #15389: vectorization support: reference w_(i,jj,k) has unaligned access   [ fluxj.f(334,32) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(334,45) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(335,29) ]
         remark #15389: vectorization support: reference t_(i,jcd,k) has unaligned access   [ fluxj.f(335,42) ]
         remark #15389: vectorization support: reference t_(i,jj,k) has unaligned access   [ fluxj.f(336,32) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(336,45) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(324,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(324,34) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(325,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(325,34) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(326,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(326,34) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(327,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(327,34) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(339,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(340,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(341,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(342,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(344,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(345,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(346,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(347,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(349,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(350,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(351,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(352,24) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(357,22) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(357,37) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(358,22) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(358,37) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(359,22) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(359,37) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(360,22) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(360,37) ]
         remark #15389: vectorization support: reference uav_(i,j,k-2) has unaligned access   [ fluxj.f(362,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k+2) has unaligned access   [ fluxj.f(362,44) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(363,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(363,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k-2) has unaligned access   [ fluxj.f(364,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k+2) has unaligned access   [ fluxj.f(364,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(365,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(365,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k-2) has unaligned access   [ fluxj.f(366,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k+2) has unaligned access   [ fluxj.f(366,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(367,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(367,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k-2) has unaligned access   [ fluxj.f(368,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k+2) has unaligned access   [ fluxj.f(368,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(369,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(369,44) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(372,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(373,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(374,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(375,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(377,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(378,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(379,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(380,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(382,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(383,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(384,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(385,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(387,24) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(387,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(388,24) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(388,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(389,24) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(389,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(390,24) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(390,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxj.f(391,24) ]
         remark #15389: vectorization support: reference hf_(i,j+1,k,2) has unaligned access   [ fluxj.f(391,38) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ fluxj.f(412,10) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ fluxj.f(413,10) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ fluxj.f(414,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.298
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 50 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15456: masked unaligned unit stride loads: 24 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 658 
         remark #15477: vector cost: 166.370 
         remark #15478: estimated potential speedup: 3.680 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 27
      LOOP END

      LOOP BEGIN at fluxj.f(276,7) inlined into fluxj.f(58,27)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxj.f(296,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxj.f(296,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxj.f(297,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxj.f(297,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxj.f(298,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxj.f(298,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxj.f(299,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxj.f(299,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxj.f(300,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxj.f(300,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxj.f(301,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxj.f(301,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxj.f(302,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxj.f(302,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxj.f(303,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxj.f(303,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(306,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(307,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(308,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(309,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(311,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(312,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(313,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(314,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(316,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(317,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(318,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(319,17) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(329,29) ]
         remark #15389: vectorization support: reference u_(i,jcd,k) has unaligned access   [ fluxj.f(329,42) ]
         remark #15389: vectorization support: reference u_(i,jj,k) has unaligned access   [ fluxj.f(330,32) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(330,45) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(331,29) ]
         remark #15389: vectorization support: reference v_(i,jcd,k) has unaligned access   [ fluxj.f(331,42) ]
         remark #15389: vectorization support: reference v_(i,jj,k) has unaligned access   [ fluxj.f(332,32) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(332,45) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(333,29) ]
         remark #15389: vectorization support: reference w_(i,jcd,k) has unaligned access   [ fluxj.f(333,42) ]
         remark #15389: vectorization support: reference w_(i,jj,k) has unaligned access   [ fluxj.f(334,32) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(334,45) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(335,29) ]
         remark #15389: vectorization support: reference t_(i,jcd,k) has unaligned access   [ fluxj.f(335,42) ]
         remark #15389: vectorization support: reference t_(i,jj,k) has unaligned access   [ fluxj.f(336,32) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(336,45) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(324,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(324,34) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(325,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(325,34) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(326,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(326,34) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(327,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(327,34) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(339,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(340,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(341,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(342,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(344,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(345,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(346,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(347,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(349,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(350,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(351,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(352,24) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(357,22) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(357,37) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(358,22) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(358,37) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(359,22) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(359,37) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(360,22) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(360,37) ]
         remark #15389: vectorization support: reference uav_(i,j,k-2) has unaligned access   [ fluxj.f(362,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k+2) has unaligned access   [ fluxj.f(362,44) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(363,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(363,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k-2) has unaligned access   [ fluxj.f(364,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k+2) has unaligned access   [ fluxj.f(364,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(365,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(365,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k-2) has unaligned access   [ fluxj.f(366,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k+2) has unaligned access   [ fluxj.f(366,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(367,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(367,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k-2) has unaligned access   [ fluxj.f(368,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k+2) has unaligned access   [ fluxj.f(368,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(369,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(369,44) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(372,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(373,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(374,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(375,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(377,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(378,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(379,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(380,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(382,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(383,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(384,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(385,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(387,24) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(387,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(388,24) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(388,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(389,24) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(389,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(390,24) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(390,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxj.f(391,24) ]
         remark #15389: vectorization support: reference hf_(i,j+1,k,2) has unaligned access   [ fluxj.f(391,38) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ fluxj.f(412,10) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ fluxj.f(413,10) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ fluxj.f(414,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.269
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(48,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference FSJ(:,j,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference FSJ(:,j,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.606
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END

   LOOP BEGIN at fluxj.f(61,9)
   <Distributed chunk1>
      remark #25426: Loop Distributed (2 way) 
      remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
      remark #25452: Original Order found to be proper, but by a close margin
      remark #25084: Preprocess Loopnests: Moving Out Store    [ fluxj.f(65,12) ]
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between l (62:12) and l (65:12)
      remark #15346: vector dependence: assumed OUTPUT dependence between l (65:12) and l (62:12)

      LOOP BEGIN at fluxj.f(63,15)
      <Distributed chunk2>
         remark #25436: completely unrolled by 5   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at fluxj.f(61,9)
   <Distributed chunk2>
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxj.f(63,15)
      <Distributed chunk1>
         remark #25426: Loop Distributed (2 way) 
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(63,15)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j,l) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: peel loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 0.356
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 1.870 
            remark #15478: estimated potential speedup: 5.810 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=7
         LOOP END

         LOOP BEGIN at fluxj.f(63,15)
            remark #15388: vectorization support: reference dq_(:,j,k,l) has aligned access
            remark #15388: vectorization support: reference dq_(:,j,k,l) has aligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j,l) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.633
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 1.870 
            remark #15478: estimated potential speedup: 5.810 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxj.f(63,15)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j,l) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.788
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 1.870 
            remark #15478: estimated potential speedup: 5.810 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxj.f(1,18):remark #34051: REGISTER ALLOCATION : [fluxj_.h] fluxj.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   54[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm31 k0-k7]
        
    Routine temporaries
        Total         :    2752
            Global    :     775
            Local     :    1977
        Regenerable   :      83
        Spilled       :     573
        
    Routine stack
        Variables     :     312 bytes*
            Reads     :      17 [9.93e+01 ~ 0.0%]
            Writes    :      55 [4.32e+01 ~ 0.0%]
        Spills        :    5184 bytes*
            Reads     :     901 [3.58e+04 ~ 11.4%]
            Writes    :     631 [1.04e+04 ~ 3.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: FLUXJ [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (FLUXJ) [6/38=15.8%] fluxj.f(1,18)
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_alloc_allocatable
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_alloc_allocatable
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> INLINE: (25,27) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> (28,12) EXTRAPJ (isz = 2058) (sz = 2061)
     [[ Inlining would exceed -inline-max-size value (2061>230) <2>]]
  -> INLINE: (58,27) VISCJ (isz = 1807) (sz = 1820)
  -> EXTERN: (69,7) for_dealloc_allocatable
  -> EXTERN: (69,7) for_dealloc_allocatable
  -> EXTERN: (72,7) for_dealloc_allocatable
  -> EXTERN: (72,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxj.f(30,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxj.f(31,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxj.f(33,13)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at fluxj.f(33,13)
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.368
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 17 
         remark #15477: vector cost: 4.750 
         remark #15478: estimated potential speedup: 3.180 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(33,13)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(33,40) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(33,57) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.474
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 3.000 
         remark #15478: estimated potential speedup: 3.500 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(33,13)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(48,12)
      <Peeled loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at fluxj.f(48,12)
         remark #25045: Fused Loops: ( 48 49 51 53 55 )

         remark #15389: vectorization support: reference FSJ(:,j,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference FSJ(:,j,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference sjx_(:,j,k) has unaligned access   [ fluxj.f(49,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(51,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference sjy_(:,j,k) has unaligned access   [ fluxj.f(51,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference sjz_(:,j,k) has unaligned access   [ fluxj.f(53,47) ]
         remark #15389: vectorization support: reference FSJ(:,j,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxj.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.897
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15450: unmasked unaligned unit stride loads: 10 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 50 
         remark #15477: vector cost: 14.500 
         remark #15478: estimated potential speedup: 3.300 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
      LOOP END

      LOOP BEGIN at fluxj.f(49,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(51,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(53,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(55,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(48,12)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(276,7) inlined into fluxj.f(58,27)
      <Peeled loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 9
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at fluxj.f(276,7) inlined into fluxj.f(58,27)
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxj.f(296,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxj.f(296,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxj.f(297,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxj.f(297,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxj.f(298,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxj.f(298,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxj.f(299,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxj.f(299,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxj.f(300,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxj.f(300,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxj.f(301,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxj.f(301,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxj.f(302,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxj.f(302,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxj.f(303,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxj.f(303,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(306,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(307,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(308,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ fluxj.f(309,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(311,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(312,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(313,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ fluxj.f(314,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(316,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(317,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(318,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ fluxj.f(319,17) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(329,29) ]
         remark #15389: vectorization support: reference u_(i,jcd,k) has unaligned access   [ fluxj.f(329,42) ]
         remark #15389: vectorization support: reference u_(i,jj,k) has unaligned access   [ fluxj.f(330,32) ]
         remark #15389: vectorization support: reference u_(i,jbd,k) has unaligned access   [ fluxj.f(330,45) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(331,29) ]
         remark #15389: vectorization support: reference v_(i,jcd,k) has unaligned access   [ fluxj.f(331,42) ]
         remark #15389: vectorization support: reference v_(i,jj,k) has unaligned access   [ fluxj.f(332,32) ]
         remark #15389: vectorization support: reference v_(i,jbd,k) has unaligned access   [ fluxj.f(332,45) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(333,29) ]
         remark #15389: vectorization support: reference w_(i,jcd,k) has unaligned access   [ fluxj.f(333,42) ]
         remark #15389: vectorization support: reference w_(i,jj,k) has unaligned access   [ fluxj.f(334,32) ]
         remark #15389: vectorization support: reference w_(i,jbd,k) has unaligned access   [ fluxj.f(334,45) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(335,29) ]
         remark #15389: vectorization support: reference t_(i,jcd,k) has unaligned access   [ fluxj.f(335,42) ]
         remark #15389: vectorization support: reference t_(i,jj,k) has unaligned access   [ fluxj.f(336,32) ]
         remark #15389: vectorization support: reference t_(i,jbd,k) has unaligned access   [ fluxj.f(336,45) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(324,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(324,34) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(325,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(325,34) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(326,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(326,34) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(327,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(327,34) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(339,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(340,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(341,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ fluxj.f(342,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(344,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(345,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(346,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ fluxj.f(347,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(349,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(350,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(351,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ fluxj.f(352,24) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(357,22) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(357,37) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(358,22) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(358,37) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(359,22) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(359,37) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(360,22) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(360,37) ]
         remark #15389: vectorization support: reference uav_(i,j,k-2) has unaligned access   [ fluxj.f(362,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k+2) has unaligned access   [ fluxj.f(362,44) ]
         remark #15389: vectorization support: reference uav_(i,j,k+1) has unaligned access   [ fluxj.f(363,29) ]
         remark #15389: vectorization support: reference uav_(i,j,k-1) has unaligned access   [ fluxj.f(363,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k-2) has unaligned access   [ fluxj.f(364,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k+2) has unaligned access   [ fluxj.f(364,44) ]
         remark #15389: vectorization support: reference vav_(i,j,k+1) has unaligned access   [ fluxj.f(365,29) ]
         remark #15389: vectorization support: reference vav_(i,j,k-1) has unaligned access   [ fluxj.f(365,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k-2) has unaligned access   [ fluxj.f(366,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k+2) has unaligned access   [ fluxj.f(366,44) ]
         remark #15389: vectorization support: reference wav_(i,j,k+1) has unaligned access   [ fluxj.f(367,29) ]
         remark #15389: vectorization support: reference wav_(i,j,k-1) has unaligned access   [ fluxj.f(367,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k-2) has unaligned access   [ fluxj.f(368,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k+2) has unaligned access   [ fluxj.f(368,44) ]
         remark #15389: vectorization support: reference tav_(i,j,k+1) has unaligned access   [ fluxj.f(369,29) ]
         remark #15389: vectorization support: reference tav_(i,j,k-1) has unaligned access   [ fluxj.f(369,44) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(372,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(373,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(374,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ fluxj.f(375,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(377,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(378,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(379,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ fluxj.f(380,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(382,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(383,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(384,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ fluxj.f(385,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxj.f(387,24) ]
         remark #15389: vectorization support: reference t_(i,j+1,k) has unaligned access   [ fluxj.f(387,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxj.f(388,24) ]
         remark #15389: vectorization support: reference u_(i,j+1,k) has unaligned access   [ fluxj.f(388,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxj.f(389,24) ]
         remark #15389: vectorization support: reference v_(i,j+1,k) has unaligned access   [ fluxj.f(389,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxj.f(390,24) ]
         remark #15389: vectorization support: reference w_(i,j+1,k) has unaligned access   [ fluxj.f(390,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxj.f(391,24) ]
         remark #15389: vectorization support: reference hf_(i,j+1,k,2) has unaligned access   [ fluxj.f(391,38) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ fluxj.f(412,10) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ fluxj.f(413,10) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ fluxj.f(414,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,2) has unaligned access   [ fluxj.f(416,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,3) has unaligned access   [ fluxj.f(417,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,4) has unaligned access   [ fluxj.f(418,23) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,10) ]
         remark #15389: vectorization support: reference FSJ(i,j,5) has unaligned access   [ fluxj.f(419,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.327
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 50 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15456: masked unaligned unit stride loads: 24 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 658 
         remark #15477: vector cost: 303.250 
         remark #15478: estimated potential speedup: 2.120 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 27
      LOOP END

      LOOP BEGIN at fluxj.f(276,7) inlined into fluxj.f(58,27)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END

   LOOP BEGIN at fluxj.f(61,9)
   <Distributed chunk1>
      remark #25426: Loop Distributed (2 way) 
      remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
      remark #25452: Original Order found to be proper, but by a close margin
      remark #25084: Preprocess Loopnests: Moving Out Store    [ fluxj.f(65,12) ]
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between l (62:12) and l (65:12)
      remark #15346: vector dependence: assumed OUTPUT dependence between l (65:12) and l (62:12)

      LOOP BEGIN at fluxj.f(63,15)
      <Distributed chunk2>
         remark #25436: completely unrolled by 5   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at fluxj.f(61,9)
   <Distributed chunk2>
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxj.f(63,15)
      <Distributed chunk1>
         remark #25426: Loop Distributed (2 way) 
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(63,15)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at fluxj.f(63,15)
            remark #15388: vectorization support: reference dq_(:,j,k,l) has aligned access
            remark #15388: vectorization support: reference dq_(:,j,k,l) has aligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j,l) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 0.396
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 3.000 
            remark #15478: estimated potential speedup: 3.500 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxj.f(63,15)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j,l) has unaligned access
            remark #15389: vectorization support: reference FSJ(:,j-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.667
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 3.000 
            remark #15478: estimated potential speedup: 3.500 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxj.f(63,15)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxj.f(1,18):remark #34051: REGISTER ALLOCATION : [fluxj_.A] fluxj.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :    1895
            Global    :     628
            Local     :    1267
        Regenerable   :      73
        Spilled       :     477
        
    Routine stack
        Variables     :     312 bytes*
            Reads     :      17 [1.67e+02 ~ 0.1%]
            Writes    :      55 [4.32e+01 ~ 0.0%]
        Spills        :    4416 bytes*
            Reads     :     933 [4.31e+04 ~ 20.2%]
            Writes    :     591 [1.92e+04 ~ 9.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: SETBC

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (SETBC) [7/38=18.4%] setbc.f(1,18)
  -> INLINE: (247,15) WALLBC (isz = 1708) (sz = 1727)
    -> INLINE: (469,21) INTERNAL_ENERGY (isz = 21) (sz = 40)
    -> INLINE: (505,21) INTERNAL_ENERGY (isz = 21) (sz = 40)
    -> INLINE: (541,21) INTERNAL_ENERGY (isz = 21) (sz = 40)
    -> INLINE: (557,15) EJECT (isz = 24) (sz = 31)
      -> EXTERN: main.f:(364,7) for_write_seq_fmt
      -> EXTERN: main.f:(365,12) mpi_abort_
      -> EXTERN: main.f:(367,7) for_stop_core
  -> CP_CLONE (307,15) WALLBC..0 (isz = 1708) (sz = 1727)
     [[ Inlining would exceed -inline-max-total-size value (3416>2000) <3>]]
  -> CP_CLONE (367,15) WALLBC..1 (isz = 1708) (sz = 1727)
     [[ Inlining would exceed -inline-max-total-size value (3416>2000) <3>]]
  -> CP_CLONE (427,15) WALLBC..1 (isz = 1708) (sz = 1727)
     [[ Inlining would exceed -inline-max-total-size value (3416>2000) <3>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at setbc.f(485,10) inlined into setbc.f(247,15)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between t_(i,j,k) (494:16) and t(:) (40:7)
   remark #15346: vector dependence: assumed ANTI dependence between t(:) (40:7) and t_(i,j,k) (494:16)

   LOOP BEGIN at setbc.f(486,13) inlined into setbc.f(247,15)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed FLOW dependence between t_(i,j,k) (494:16) and t(:) (40:7)
      remark #15346: vector dependence: assumed ANTI dependence between t(:) (40:7) and t_(i,j,k) (494:16)

      LOOP BEGIN at setbc.f(497,16) inlined into setbc.f(247,15)
         remark #25436: completely unrolled by 4   (pre-vector) 
      LOOP END

      LOOP BEGIN at props.f(40,7) inlined into setbc.f(247,15)
         remark #25436: completely unrolled by 1   (pre-vector) 
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

setbc.f(1,18):remark #34051: REGISTER ALLOCATION : [setbc_] setbc.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   31[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :     312
            Global    :      83
            Local     :     229
        Regenerable   :      41
        Spilled       :      71
        
    Routine stack
        Variables     :      44 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :      33 [4.84e+00 ~ 1.1%]
        Spills        :     520 bytes*
            Reads     :      71 [7.29e+01 ~ 17.3%]
            Writes    :      71 [3.54e+01 ~ 8.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: WALLBC..1

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (WALLBC..1) [8/38=21.1%] setbc.f(433,18)
  CLONED FROM: WALLBC(3,-1,X,X,X,X,X,0x00000000,0x3ff00000)
  -> INLINE: (469,21) INTERNAL_ENERGY (isz = 21) (sz = 40)
  -> INLINE: (505,21) INTERNAL_ENERGY (isz = 21) (sz = 40)
  -> INLINE: (541,21) INTERNAL_ENERGY (isz = 21) (sz = 40)
  -> INLINE: (557,15) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at setbc.f(521,10)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between t_(i,j,kst) (530:16) and t(:) (40:7)
   remark #15346: vector dependence: assumed ANTI dependence between t(:) (40:7) and t_(i,j,kst) (530:16)

   LOOP BEGIN at setbc.f(522,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed FLOW dependence between t_(i,j,kst) (530:16) and t(:) (40:7)
      remark #15346: vector dependence: assumed ANTI dependence between t(:) (40:7) and t_(i,j,kst) (530:16)

      LOOP BEGIN at setbc.f(533,16)
         remark #25436: completely unrolled by 4   (pre-vector) 
      LOOP END

      LOOP BEGIN at props.f(40,7) inlined into setbc.f(541,21)
         remark #25436: completely unrolled by 1   (pre-vector) 
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

setbc.f(433,18):remark #34051: REGISTER ALLOCATION : [wallbc_..1] setbc.f:433

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   31[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :     241
            Global    :      78
            Local     :     163
        Regenerable   :       3
        Spilled       :      70
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :     512 bytes*
            Reads     :      68 [1.43e+02 ~ 19.1%]
            Writes    :      68 [6.80e+01 ~ 9.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: WALLBC..0

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (WALLBC..0) [9/38=23.7%] setbc.f(433,18)
  CLONED FROM: WALLBC(2,-1,X,X,X,X,X,0x00000000,0x3ff00000)
  -> INLINE: (469,21) INTERNAL_ENERGY (isz = 21) (sz = 40)
  -> INLINE: (505,21) INTERNAL_ENERGY (isz = 21) (sz = 40)
  -> INLINE: (541,21) INTERNAL_ENERGY (isz = 21) (sz = 40)
  -> INLINE: (557,15) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at setbc.f(485,10)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between t_(i,jst,k) (494:16) and t(:) (40:7)
   remark #15346: vector dependence: assumed ANTI dependence between t(:) (40:7) and t_(i,jst,k) (494:16)

   LOOP BEGIN at setbc.f(486,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed FLOW dependence between t_(i,jst,k) (494:16) and t(:) (40:7)
      remark #15346: vector dependence: assumed ANTI dependence between t(:) (40:7) and t_(i,jst,k) (494:16)

      LOOP BEGIN at setbc.f(497,16)
         remark #25436: completely unrolled by 4   (pre-vector) 
      LOOP END

      LOOP BEGIN at props.f(40,7) inlined into setbc.f(505,21)
         remark #25436: completely unrolled by 1   (pre-vector) 
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

setbc.f(433,18):remark #34051: REGISTER ALLOCATION : [wallbc_..0] setbc.f:433

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   31[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :     230
            Global    :      79
            Local     :     151
        Regenerable   :       3
        Spilled       :      69
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :     504 bytes*
            Reads     :      68 [1.43e+02 ~ 19.4%]
            Writes    :      65 [6.53e+01 ~ 8.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: PARALLEL

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (PARALLEL) [10/38=26.3%] parallel.f(1,18)
  -> (23,15) MPICX (isz = 4024) (sz = 4033)
     [[ Inlining would exceed -inline-max-total-size value (4024>2000) <3>]]
  -> (37,15) GHOST (isz = 355) (sz = 370)
     [[ Inlining would exceed -inline-max-size value (370>230) <2>]]
  -> (51,15) GHOST (isz = 355) (sz = 370)
     [[ Inlining would exceed -inline-max-size value (370>230) <2>]]
  -> (65,15) GHOST (isz = 355) (sz = 370)
     [[ Inlining would exceed -inline-max-size value (370>230) <2>]]
  -> (79,15) GHOST (isz = 355) (sz = 370)
     [[ Inlining would exceed -inline-max-size value (370>230) <2>]]
  -> (93,15) GHOST (isz = 355) (sz = 370)
     [[ Inlining would exceed -inline-max-size value (370>230) <2>]]
  -> (107,15) GHOST (isz = 355) (sz = 370)
     [[ Inlining would exceed -inline-max-size value (370>230) <2>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at parallel.f(22,7)
   remark #15382: vectorization support: call to function MPICX cannot be vectorized   [ parallel.f(23,15) ]
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (23:26) and at (23:15)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (23:15) and at (23:26)
   remark #25436: completely unrolled by 5  
LOOP END

    Report from: Code generation optimizations [cg]

parallel.f(1,18):remark #34051: REGISTER ALLOCATION : [parallel_] parallel.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   10[ rax rdx rcx rsi rdi r8-r12]
        
    Routine temporaries
        Total         :     274
            Global    :      12
            Local     :     262
        Regenerable   :      84
        Spilled       :       1
        
    Routine stack
        Variables     :      32 bytes*
            Reads     :       6 [4.41e+00 ~ 1.6%]
            Writes    :      42 [3.24e+01 ~ 11.9%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: MPICX

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (MPICX) [11/38=28.9%] parallel.f(282,18)
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> INLINE: (340,26) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (358,15) mpi_irecv_
  -> INLINE: (366,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (370,15) mpi_irecv_
  -> INLINE: (378,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (391,15) mpi_send_
  -> INLINE: (398,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (411,15) mpi_send_
  -> INLINE: (418,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (422,15) mpi_wait_
  -> EXTERN: (436,15) mpi_wait_
  -> EXTERN: (465,15) mpi_irecv_
  -> INLINE: (473,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (477,15) mpi_irecv_
  -> INLINE: (485,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (498,15) mpi_send_
  -> INLINE: (505,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (518,15) mpi_send_
  -> INLINE: (525,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (529,15) mpi_wait_
  -> EXTERN: (543,15) mpi_wait_
  -> EXTERN: (573,15) mpi_irecv_
  -> INLINE: (581,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (585,15) mpi_irecv_
  -> INLINE: (593,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (606,15) mpi_send_
  -> INLINE: (613,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (626,15) mpi_send_
  -> INLINE: (633,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (637,15) mpi_wait_
  -> EXTERN: (651,15) mpi_wait_
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at parallel.f(346,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <var(icmax+i,j,k)>, stride is unknown to compiler   [ parallel.f(349,19) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <var(i,j,k)>, stride is unknown to compiler   [ parallel.f(349,19) ]
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <var(i+1,j,k)>, stride is unknown to compiler   [ parallel.f(350,19) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <var(icmax-i+1,j,k)>, stride is unknown to compiler   [ parallel.f(350,19) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.222
   remark #15452: unmasked strided loads: 2 
   remark #15453: unmasked strided stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 7 
   remark #15477: vector cost: 9.000 
   remark #15478: estimated potential speedup: 0.770 
   remark #15488: --- end vector cost summary ---

   LOOP BEGIN at parallel.f(347,13)
      remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <var(icmax+i,j,k)>, stride is unknown to compiler   [ parallel.f(349,19) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <var(i,j,k)>, stride is unknown to compiler   [ parallel.f(349,19) ]
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <var(i+1,j,k)>, stride is unknown to compiler   [ parallel.f(350,19) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <var(icmax-i+1,j,k)>, stride is unknown to compiler   [ parallel.f(350,19) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.235
      remark #15452: unmasked strided loads: 2 
      remark #15453: unmasked strided stores: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 7 
      remark #15477: vector cost: 8.500 
      remark #15478: estimated potential speedup: 0.820 
      remark #15488: --- end vector cost summary ---

      LOOP BEGIN at parallel.f(348,16)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between var(icmax+i,j,k) (349:19) and var(i+1,j,k) (350:19)
         remark #15346: vector dependence: assumed OUTPUT dependence between var(i+1,j,k) (350:19) and var(icmax+i,j,k) (349:19)
         remark #25436: completely unrolled by 2  
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(383,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between S_W(icnt) (387:19) and S_W(icnt) (387:19)
   remark #15346: vector dependence: assumed OUTPUT dependence between S_W(icnt) (387:19) and S_W(icnt) (387:19)

   LOOP BEGIN at parallel.f(384,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between S_W(icnt) (387:19) and S_W(icnt) (387:19)
      remark #15346: vector dependence: assumed OUTPUT dependence between S_W(icnt) (387:19) and S_W(icnt) (387:19)
      remark #25439: unrolled with remainder by 2  

      LOOP BEGIN at parallel.f(385,16)
         remark #25436: completely unrolled by 2   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at parallel.f(384,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(403,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between S_E(icnt) (407:19) and S_E(icnt) (407:19)
   remark #15346: vector dependence: assumed OUTPUT dependence between S_E(icnt) (407:19) and S_E(icnt) (407:19)

   LOOP BEGIN at parallel.f(404,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between S_E(icnt) (407:19) and S_E(icnt) (407:19)
      remark #15346: vector dependence: assumed OUTPUT dependence between S_E(icnt) (407:19) and S_E(icnt) (407:19)
      remark #25439: unrolled with remainder by 2  

      LOOP BEGIN at parallel.f(405,16)
         remark #25436: completely unrolled by 2   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at parallel.f(404,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(425,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)

   LOOP BEGIN at parallel.f(426,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
      remark #25439: unrolled with remainder by 2  

      LOOP BEGIN at parallel.f(427,16)
         remark #25436: completely unrolled by 2   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at parallel.f(426,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(438,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)

   LOOP BEGIN at parallel.f(439,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
      remark #25439: unrolled with remainder by 2  

      LOOP BEGIN at parallel.f(442,32)
         remark #25436: completely unrolled by 2   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at parallel.f(439,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(490,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(491,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(492,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(492,16)
            remark #15389: vectorization support: reference S_N(jcnt) has unaligned access   [ parallel.f(494,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(494,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(492,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference S_N(jcnt) has unaligned access   [ parallel.f(494,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(494,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(510,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(512,16)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(512,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(512,16)
            remark #15389: vectorization support: reference S_S(jcnt) has unaligned access   [ parallel.f(514,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(514,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(512,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference S_S(jcnt) has unaligned access   [ parallel.f(514,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(514,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(532,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(533,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(534,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(534,16)
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(536,19) ]
            remark #15389: vectorization support: reference R_N(jcnt) has unaligned access   [ parallel.f(536,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(534,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(536,19) ]
            remark #15389: vectorization support: reference R_N(jcnt) has unaligned access   [ parallel.f(536,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(546,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(548,16)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(548,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(548,16)
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(550,19) ]
            remark #15389: vectorization support: reference R_S(jcnt) has unaligned access   [ parallel.f(550,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(548,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(550,19) ]
            remark #15389: vectorization support: reference R_S(jcnt) has unaligned access   [ parallel.f(550,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(563,16)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(562,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(563,16)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference var(i,j,kcmax+k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15389: vectorization support: reference var(i,j,kcmax-k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.793
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 7 
         remark #15477: vector cost: 1.620 
         remark #15478: estimated potential speedup: 3.890 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at parallel.f(563,16)
         remark #15389: vectorization support: reference var(i,j,kcmax+k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15389: vectorization support: reference var(i,j,kcmax-k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 1.462
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 7 
         remark #15477: vector cost: 1.620 
         remark #15478: estimated potential speedup: 3.890 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at parallel.f(563,16)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference var(i,j,kcmax+k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15389: vectorization support: reference var(i,j,kcmax-k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.793
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 7 
         remark #15477: vector cost: 1.620 
         remark #15478: estimated potential speedup: 3.890 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(600,16)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(599,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(600,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(600,16)
            remark #15389: vectorization support: reference S_I(kcnt) has unaligned access   [ parallel.f(602,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(602,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(600,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference S_I(kcnt) has unaligned access   [ parallel.f(602,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(602,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(618,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(619,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(620,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(620,16)
            remark #15389: vectorization support: reference S_O(kcnt) has unaligned access   [ parallel.f(622,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(622,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(620,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference S_O(kcnt) has unaligned access   [ parallel.f(622,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(622,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(642,16)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(641,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(642,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(642,16)
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(644,19) ]
            remark #15389: vectorization support: reference R_I(kcnt) has unaligned access   [ parallel.f(644,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(642,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(644,19) ]
            remark #15389: vectorization support: reference R_I(kcnt) has unaligned access   [ parallel.f(644,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(654,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(655,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(656,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(656,16)
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(658,19) ]
            remark #15389: vectorization support: reference R_O(kcnt) has unaligned access   [ parallel.f(658,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(656,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(658,19) ]
            remark #15389: vectorization support: reference R_O(kcnt) has unaligned access   [ parallel.f(658,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

parallel.f(282,18):remark #34051: REGISTER ALLOCATION : [mpicx_] parallel.f:282

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rdx rcx rsi rdi]
        
    Routine temporaries
        Total         :      22
            Global    :      10
            Local     :      12
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: MPICX [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (MPICX) [11/38=28.9%] parallel.f(282,18)
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> INLINE: (340,26) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (358,15) mpi_irecv_
  -> INLINE: (366,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (370,15) mpi_irecv_
  -> INLINE: (378,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (391,15) mpi_send_
  -> INLINE: (398,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (411,15) mpi_send_
  -> INLINE: (418,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (422,15) mpi_wait_
  -> EXTERN: (436,15) mpi_wait_
  -> EXTERN: (465,15) mpi_irecv_
  -> INLINE: (473,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (477,15) mpi_irecv_
  -> INLINE: (485,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (498,15) mpi_send_
  -> INLINE: (505,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (518,15) mpi_send_
  -> INLINE: (525,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (529,15) mpi_wait_
  -> EXTERN: (543,15) mpi_wait_
  -> EXTERN: (573,15) mpi_irecv_
  -> INLINE: (581,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (585,15) mpi_irecv_
  -> INLINE: (593,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (606,15) mpi_send_
  -> INLINE: (613,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (626,15) mpi_send_
  -> INLINE: (633,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (637,15) mpi_wait_
  -> EXTERN: (651,15) mpi_wait_
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at parallel.f(346,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <var(icmax+i,j,k)>, stride is unknown to compiler   [ parallel.f(349,19) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <var(i,j,k)>, stride is unknown to compiler   [ parallel.f(349,19) ]
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <var(i+1,j,k)>, stride is unknown to compiler   [ parallel.f(350,19) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <var(icmax-i+1,j,k)>, stride is unknown to compiler   [ parallel.f(350,19) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.222
   remark #15452: unmasked strided loads: 2 
   remark #15453: unmasked strided stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 7 
   remark #15477: vector cost: 9.000 
   remark #15478: estimated potential speedup: 0.760 
   remark #15488: --- end vector cost summary ---

   LOOP BEGIN at parallel.f(347,13)
      remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <var(icmax+i,j,k)>, stride is unknown to compiler   [ parallel.f(349,19) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <var(i,j,k)>, stride is unknown to compiler   [ parallel.f(349,19) ]
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <var(i+1,j,k)>, stride is unknown to compiler   [ parallel.f(350,19) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <var(icmax-i+1,j,k)>, stride is unknown to compiler   [ parallel.f(350,19) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.235
      remark #15452: unmasked strided loads: 2 
      remark #15453: unmasked strided stores: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 7 
      remark #15477: vector cost: 8.500 
      remark #15478: estimated potential speedup: 0.810 
      remark #15488: --- end vector cost summary ---

      LOOP BEGIN at parallel.f(348,16)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between var(icmax+i,j,k) (349:19) and var(i+1,j,k) (350:19)
         remark #15346: vector dependence: assumed OUTPUT dependence between var(i+1,j,k) (350:19) and var(icmax+i,j,k) (349:19)
         remark #25436: completely unrolled by 2  
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(383,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between S_W(icnt) (387:19) and S_W(icnt) (387:19)
   remark #15346: vector dependence: assumed OUTPUT dependence between S_W(icnt) (387:19) and S_W(icnt) (387:19)

   LOOP BEGIN at parallel.f(384,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between S_W(icnt) (387:19) and S_W(icnt) (387:19)
      remark #15346: vector dependence: assumed OUTPUT dependence between S_W(icnt) (387:19) and S_W(icnt) (387:19)
      remark #25439: unrolled with remainder by 2  

      LOOP BEGIN at parallel.f(385,16)
         remark #25436: completely unrolled by 2   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at parallel.f(384,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(403,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between S_E(icnt) (407:19) and S_E(icnt) (407:19)
   remark #15346: vector dependence: assumed OUTPUT dependence between S_E(icnt) (407:19) and S_E(icnt) (407:19)

   LOOP BEGIN at parallel.f(404,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between S_E(icnt) (407:19) and S_E(icnt) (407:19)
      remark #15346: vector dependence: assumed OUTPUT dependence between S_E(icnt) (407:19) and S_E(icnt) (407:19)
      remark #25439: unrolled with remainder by 2  

      LOOP BEGIN at parallel.f(405,16)
         remark #25436: completely unrolled by 2   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at parallel.f(404,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(425,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)

   LOOP BEGIN at parallel.f(426,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
      remark #25439: unrolled with remainder by 2  

      LOOP BEGIN at parallel.f(427,16)
         remark #25436: completely unrolled by 2   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at parallel.f(426,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(438,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)

   LOOP BEGIN at parallel.f(439,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
      remark #25439: unrolled with remainder by 2  

      LOOP BEGIN at parallel.f(442,32)
         remark #25436: completely unrolled by 2   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at parallel.f(439,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(490,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(491,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(492,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(492,16)
            remark #15389: vectorization support: reference S_N(jcnt) has unaligned access   [ parallel.f(494,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(494,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(492,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference S_N(jcnt) has unaligned access   [ parallel.f(494,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(494,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(510,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(512,16)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(512,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(512,16)
            remark #15389: vectorization support: reference S_S(jcnt) has unaligned access   [ parallel.f(514,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(514,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(512,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference S_S(jcnt) has unaligned access   [ parallel.f(514,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(514,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(532,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(533,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(534,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(534,16)
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(536,19) ]
            remark #15389: vectorization support: reference R_N(jcnt) has unaligned access   [ parallel.f(536,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(534,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(536,19) ]
            remark #15389: vectorization support: reference R_N(jcnt) has unaligned access   [ parallel.f(536,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(546,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(548,16)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(548,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(548,16)
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(550,19) ]
            remark #15389: vectorization support: reference R_S(jcnt) has unaligned access   [ parallel.f(550,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(548,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(550,19) ]
            remark #15389: vectorization support: reference R_S(jcnt) has unaligned access   [ parallel.f(550,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(563,16)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(562,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(563,16)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference var(i,j,kcmax+k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15389: vectorization support: reference var(i,j,kcmax-k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.793
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 7 
         remark #15477: vector cost: 1.620 
         remark #15478: estimated potential speedup: 3.890 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at parallel.f(563,16)
         remark #15389: vectorization support: reference var(i,j,kcmax+k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15389: vectorization support: reference var(i,j,kcmax-k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 1.462
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 7 
         remark #15477: vector cost: 1.620 
         remark #15478: estimated potential speedup: 3.890 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at parallel.f(563,16)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference var(i,j,kcmax+k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15389: vectorization support: reference var(i,j,kcmax-k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.793
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 7 
         remark #15477: vector cost: 1.620 
         remark #15478: estimated potential speedup: 3.890 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(600,16)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(599,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(600,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(600,16)
            remark #15389: vectorization support: reference S_I(kcnt) has unaligned access   [ parallel.f(602,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(602,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(600,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference S_I(kcnt) has unaligned access   [ parallel.f(602,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(602,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(618,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(619,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(620,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(620,16)
            remark #15389: vectorization support: reference S_O(kcnt) has unaligned access   [ parallel.f(622,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(622,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(620,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference S_O(kcnt) has unaligned access   [ parallel.f(622,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(622,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(642,16)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(641,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(642,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(642,16)
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(644,19) ]
            remark #15389: vectorization support: reference R_I(kcnt) has unaligned access   [ parallel.f(644,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(642,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(644,19) ]
            remark #15389: vectorization support: reference R_I(kcnt) has unaligned access   [ parallel.f(644,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(654,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(655,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(656,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(656,16)
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(658,19) ]
            remark #15389: vectorization support: reference R_O(kcnt) has unaligned access   [ parallel.f(658,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.778
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at parallel.f(656,16)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(658,19) ]
            remark #15389: vectorization support: reference R_O(kcnt) has unaligned access   [ parallel.f(658,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.474
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.120 
            remark #15478: estimated potential speedup: 1.760 
            remark #15488: --- end vector cost summary ---
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

parallel.f(492,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(492,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(492,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(512,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(512,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(512,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(534,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(534,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(534,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(548,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(548,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(548,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(600,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(600,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(600,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(620,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(620,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(620,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(642,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(642,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(642,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(656,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(656,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(656,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(282,18):remark #34051: REGISTER ALLOCATION : [mpicx_.h] parallel.f:282

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   27[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm3 zmm16-zmm19 k1-k5]
        
    Routine temporaries
        Total         :    2318
            Global    :     512
            Local     :    1806
        Regenerable   :     664
        Spilled       :     213
        
    Routine stack
        Variables     :    2272 bytes*
            Reads     :      92 [5.04e+01 ~ 0.4%]
            Writes    :     292 [1.64e+02 ~ 1.1%]
        Spills        :    1664 bytes*
            Reads     :     329 [1.42e+03 ~ 9.9%]
            Writes    :     253 [2.14e+02 ~ 1.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: MPICX [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (MPICX) [11/38=28.9%] parallel.f(282,18)
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> EXTERN: (328,7) for_alloc_allocatable
  -> EXTERN: (328,7) for_check_mult_overflow64
  -> INLINE: (340,26) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (358,15) mpi_irecv_
  -> INLINE: (366,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (370,15) mpi_irecv_
  -> INLINE: (378,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (391,15) mpi_send_
  -> INLINE: (398,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (411,15) mpi_send_
  -> INLINE: (418,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (422,15) mpi_wait_
  -> EXTERN: (436,15) mpi_wait_
  -> EXTERN: (465,15) mpi_irecv_
  -> INLINE: (473,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (477,15) mpi_irecv_
  -> INLINE: (485,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (498,15) mpi_send_
  -> INLINE: (505,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (518,15) mpi_send_
  -> INLINE: (525,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (529,15) mpi_wait_
  -> EXTERN: (543,15) mpi_wait_
  -> EXTERN: (573,15) mpi_irecv_
  -> INLINE: (581,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (585,15) mpi_irecv_
  -> INLINE: (593,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (606,15) mpi_send_
  -> INLINE: (613,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (626,15) mpi_send_
  -> INLINE: (633,29) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (637,15) mpi_wait_
  -> EXTERN: (651,15) mpi_wait_
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (666,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable
  -> EXTERN: (670,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at parallel.f(346,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <var(icmax+i,j,k)>, stride is unknown to compiler   [ parallel.f(349,19) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <var(i,j,k)>, stride is unknown to compiler   [ parallel.f(349,19) ]
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <var(i+1,j,k)>, stride is unknown to compiler   [ parallel.f(350,19) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <var(icmax-i+1,j,k)>, stride is unknown to compiler   [ parallel.f(350,19) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.222
   remark #15452: unmasked strided loads: 2 
   remark #15453: unmasked strided stores: 2 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 7 
   remark #15477: vector cost: 9.000 
   remark #15478: estimated potential speedup: 0.770 
   remark #15488: --- end vector cost summary ---

   LOOP BEGIN at parallel.f(347,13)
      remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <var(icmax+i,j,k)>, stride is unknown to compiler   [ parallel.f(349,19) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <var(i,j,k)>, stride is unknown to compiler   [ parallel.f(349,19) ]
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <var(i+1,j,k)>, stride is unknown to compiler   [ parallel.f(350,19) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <var(icmax-i+1,j,k)>, stride is unknown to compiler   [ parallel.f(350,19) ]
      remark #15305: vectorization support: vector length 2
      remark #15309: vectorization support: normalized vectorization overhead 0.235
      remark #15452: unmasked strided loads: 2 
      remark #15453: unmasked strided stores: 2 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 7 
      remark #15477: vector cost: 8.500 
      remark #15478: estimated potential speedup: 0.820 
      remark #15488: --- end vector cost summary ---

      LOOP BEGIN at parallel.f(348,16)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between var(icmax+i,j,k) (349:19) and var(i+1,j,k) (350:19)
         remark #15346: vector dependence: assumed OUTPUT dependence between var(i+1,j,k) (350:19) and var(icmax+i,j,k) (349:19)
         remark #25436: completely unrolled by 2  
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(383,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between S_W(icnt) (387:19) and S_W(icnt) (387:19)
   remark #15346: vector dependence: assumed OUTPUT dependence between S_W(icnt) (387:19) and S_W(icnt) (387:19)

   LOOP BEGIN at parallel.f(384,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between S_W(icnt) (387:19) and S_W(icnt) (387:19)
      remark #15346: vector dependence: assumed OUTPUT dependence between S_W(icnt) (387:19) and S_W(icnt) (387:19)
      remark #25439: unrolled with remainder by 2  

      LOOP BEGIN at parallel.f(385,16)
         remark #25436: completely unrolled by 2   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at parallel.f(384,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(403,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between S_E(icnt) (407:19) and S_E(icnt) (407:19)
   remark #15346: vector dependence: assumed OUTPUT dependence between S_E(icnt) (407:19) and S_E(icnt) (407:19)

   LOOP BEGIN at parallel.f(404,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between S_E(icnt) (407:19) and S_E(icnt) (407:19)
      remark #15346: vector dependence: assumed OUTPUT dependence between S_E(icnt) (407:19) and S_E(icnt) (407:19)
      remark #25439: unrolled with remainder by 2  

      LOOP BEGIN at parallel.f(405,16)
         remark #25436: completely unrolled by 2   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at parallel.f(404,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(425,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)

   LOOP BEGIN at parallel.f(426,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (428:19) and icnt (427:16)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (427:16) and icnt (428:19)
      remark #25439: unrolled with remainder by 2  

      LOOP BEGIN at parallel.f(427,16)
         remark #25436: completely unrolled by 2   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at parallel.f(426,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(438,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
   remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
   remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)

   LOOP BEGIN at parallel.f(439,13)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
      remark #15346: vector dependence: assumed FLOW dependence between icnt (441:19) and icnt (440:16)
      remark #15346: vector dependence: assumed ANTI dependence between icnt (440:16) and icnt (441:19)
      remark #25439: unrolled with remainder by 2  

      LOOP BEGIN at parallel.f(442,32)
         remark #25436: completely unrolled by 2   (pre-vector) 
      LOOP END
   LOOP END

   LOOP BEGIN at parallel.f(439,13)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(490,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(491,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(492,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(492,16)
            remark #15389: vectorization support: reference S_N(jcnt) has unaligned access   [ parallel.f(494,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(494,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 2.140 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at parallel.f(492,16)
         <Remainder loop for vectorization>
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(510,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(512,16)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(512,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(512,16)
            remark #15389: vectorization support: reference S_S(jcnt) has unaligned access   [ parallel.f(514,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(514,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 2.140 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at parallel.f(512,16)
         <Remainder loop for vectorization>
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(532,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(533,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(534,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(534,16)
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(536,19) ]
            remark #15389: vectorization support: reference R_N(jcnt) has unaligned access   [ parallel.f(536,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 2.140 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at parallel.f(534,16)
         <Remainder loop for vectorization>
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(546,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(548,16)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(548,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(548,16)
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(550,19) ]
            remark #15389: vectorization support: reference R_S(jcnt) has unaligned access   [ parallel.f(550,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 2.140 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at parallel.f(548,16)
         <Remainder loop for vectorization>
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(563,16)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(562,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(563,16)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at parallel.f(563,16)
         remark #15389: vectorization support: reference var(i,j,kcmax+k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(564,19) ]
         remark #15389: vectorization support: reference var(i,j,k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15389: vectorization support: reference var(i,j,kcmax-k+1) has unaligned access   [ parallel.f(565,19) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.900
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 7 
         remark #15477: vector cost: 2.500 
         remark #15478: estimated potential speedup: 2.660 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at parallel.f(563,16)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(600,16)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(599,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(600,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(600,16)
            remark #15389: vectorization support: reference S_I(kcnt) has unaligned access   [ parallel.f(602,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(602,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 2.140 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at parallel.f(600,16)
         <Remainder loop for vectorization>
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(618,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(619,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(620,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(620,16)
            remark #15389: vectorization support: reference S_O(kcnt) has unaligned access   [ parallel.f(622,19) ]
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(622,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 2.140 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at parallel.f(620,16)
         <Remainder loop for vectorization>
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(642,16)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(641,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(642,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(642,16)
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(644,19) ]
            remark #15389: vectorization support: reference R_I(kcnt) has unaligned access   [ parallel.f(644,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 2.140 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at parallel.f(642,16)
         <Remainder loop for vectorization>
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at parallel.f(654,10)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(655,13)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(656,16)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at parallel.f(656,16)
            remark #15389: vectorization support: reference var(i,j,k) has unaligned access   [ parallel.f(658,19) ]
            remark #15389: vectorization support: reference R_O(kcnt) has unaligned access   [ parallel.f(658,19) ]
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 5 
            remark #15477: vector cost: 1.750 
            remark #15478: estimated potential speedup: 2.140 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at parallel.f(656,16)
         <Remainder loop for vectorization>
            remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

parallel.f(492,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(492,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(492,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(512,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(512,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(512,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(534,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(534,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(534,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(548,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(548,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(548,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(600,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(600,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(600,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(620,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(620,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(620,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(642,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(642,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(642,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(656,16):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(656,16):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
parallel.f(656,16):remark #34026: call to memcpy implemented as a call to optimized library version
parallel.f(282,18):remark #34051: REGISTER ALLOCATION : [mpicx_.A] parallel.f:282

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :    2177
            Global    :     448
            Local     :    1729
        Regenerable   :     652
        Spilled       :     181
        
    Routine stack
        Variables     :    2272 bytes*
            Reads     :      92 [5.04e+01 ~ 0.4%]
            Writes    :     292 [1.64e+02 ~ 1.2%]
        Spills        :    1408 bytes*
            Reads     :     287 [9.11e+02 ~ 6.5%]
            Writes    :     234 [1.92e+02 ~ 1.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: GHOST

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (GHOST) [12/38=31.6%] parallel.f(113,18)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at parallel.f(124,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(125,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(127,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(130,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ parallel.f(130,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(130,42) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(129,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ parallel.f(129,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(129,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(128,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ parallel.f(128,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(128,42) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(138,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ parallel.f(137,24) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(137,39) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,44) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,44) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,44) ]
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ parallel.f(138,36) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ parallel.f(138,51) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ parallel.f(139,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(139,30) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ parallel.f(139,45) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(139,59) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.162
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 187 
         remark #15477: vector cost: 30.250 
         remark #15478: estimated potential speedup: 5.760 
         remark #15486: divides: 5 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at parallel.f(127,13)
         remark #25045: Fused Loops: ( 127 133 )

         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(130,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ parallel.f(130,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(130,42) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(129,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ parallel.f(129,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(129,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(128,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ parallel.f(128,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(128,42) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(138,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ parallel.f(137,24) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(137,39) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,44) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,44) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,44) ]
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ parallel.f(138,36) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ parallel.f(138,51) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ parallel.f(139,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(139,30) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ parallel.f(139,45) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(139,59) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.240
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 187 
         remark #15477: vector cost: 30.250 
         remark #15478: estimated potential speedup: 5.760 
         remark #15486: divides: 5 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
      LOOP END

      LOOP BEGIN at parallel.f(133,16)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at parallel.f(127,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(130,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ parallel.f(130,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(130,42) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(129,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ parallel.f(129,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(129,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(128,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ parallel.f(128,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(128,42) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(138,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ parallel.f(137,24) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(137,39) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,44) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,44) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,44) ]
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ parallel.f(138,36) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ parallel.f(138,51) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ parallel.f(139,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(139,30) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ parallel.f(139,45) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(139,59) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.162
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 187 
         remark #15477: vector cost: 30.250 
         remark #15478: estimated potential speedup: 5.760 
         remark #15486: divides: 5 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

parallel.f(113,18):remark #34051: REGISTER ALLOCATION : [ghost_] parallel.f:113

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rbx rsi rdi r8-r9]
        
    Routine temporaries
        Total         :      34
            Global    :      13
            Local     :      21
        Regenerable   :       1
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: GHOST [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (GHOST) [12/38=31.6%] parallel.f(113,18)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at parallel.f(124,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(125,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(127,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(130,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ parallel.f(130,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(130,42) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(129,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ parallel.f(129,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(129,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(128,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ parallel.f(128,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(128,42) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(138,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ parallel.f(137,24) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(137,39) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,44) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,44) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,44) ]
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ parallel.f(138,36) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ parallel.f(138,51) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ parallel.f(139,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(139,30) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ parallel.f(139,45) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(139,59) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.162
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 187 
         remark #15477: vector cost: 30.250 
         remark #15478: estimated potential speedup: 5.760 
         remark #15486: divides: 5 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at parallel.f(127,13)
         remark #25045: Fused Loops: ( 127 133 )

         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(130,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ parallel.f(130,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(130,42) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(129,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ parallel.f(129,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(129,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(128,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ parallel.f(128,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(128,42) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(138,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ parallel.f(137,24) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(137,39) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,44) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,44) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,44) ]
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ parallel.f(138,36) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ parallel.f(138,51) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ parallel.f(139,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(139,30) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ parallel.f(139,45) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(139,59) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.240
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 187 
         remark #15477: vector cost: 30.250 
         remark #15478: estimated potential speedup: 5.760 
         remark #15486: divides: 5 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
      LOOP END

      LOOP BEGIN at parallel.f(133,16)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at parallel.f(127,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(130,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ parallel.f(130,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(130,42) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(129,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ parallel.f(129,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(129,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(128,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ parallel.f(128,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(128,42) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(138,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ parallel.f(137,24) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(137,39) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,44) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,44) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,44) ]
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ parallel.f(138,36) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ parallel.f(138,51) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ parallel.f(139,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(139,30) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ parallel.f(139,45) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(139,59) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.162
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 187 
         remark #15477: vector cost: 30.250 
         remark #15478: estimated potential speedup: 5.760 
         remark #15486: divides: 5 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

parallel.f(113,18):remark #34051: REGISTER ALLOCATION : [ghost_.h] parallel.f:113

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   42[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm4 zmm16-zmm31 k1-k7]
        
    Routine temporaries
        Total         :     501
            Global    :     155
            Local     :     346
        Regenerable   :      10
        Spilled       :     107
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :     816 bytes*
            Reads     :     153 [3.26e+03 ~ 9.5%]
            Writes    :     113 [7.82e+02 ~ 2.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: GHOST [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (GHOST) [12/38=31.6%] parallel.f(113,18)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at parallel.f(124,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at parallel.f(125,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at parallel.f(127,13)
      <Peeled loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at parallel.f(127,13)
         remark #25045: Fused Loops: ( 127 133 )

         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(130,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,4,m) has unaligned access   [ parallel.f(130,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(130,42) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(129,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,3,m) has unaligned access   [ parallel.f(129,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(129,42) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(128,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,2,m) has unaligned access   [ parallel.f(128,27) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(128,42) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(138,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,5,m) has unaligned access   [ parallel.f(137,24) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(137,39) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,33) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ parallel.f(134,44) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ parallel.f(135,44) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,33) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ parallel.f(136,44) ]
         remark #15389: vectorization support: reference hf_(i,j,k,1) has unaligned access   [ parallel.f(138,36) ]
         remark #15389: vectorization support: reference hf_(i,j,k,3) has unaligned access   [ parallel.f(138,51) ]
         remark #15389: vectorization support: reference p_(i,j,k) has unaligned access   [ parallel.f(139,19) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,m) has unaligned access   [ parallel.f(139,30) ]
         remark #15389: vectorization support: reference hf_(i,j,k,4) has unaligned access   [ parallel.f(139,45) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ parallel.f(139,59) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.257
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 187 
         remark #15477: vector cost: 56.500 
         remark #15478: estimated potential speedup: 3.200 
         remark #15486: divides: 5 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 7
      LOOP END

      LOOP BEGIN at parallel.f(133,16)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at parallel.f(127,13)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

parallel.f(113,18):remark #34051: REGISTER ALLOCATION : [ghost_.A] parallel.f:113

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   28[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm13]
        
    Routine temporaries
        Total         :     281
            Global    :     104
            Local     :     177
        Regenerable   :       5
        Spilled       :      83
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :     608 bytes*
            Reads     :     113 [2.63e+03 ~ 18.1%]
            Writes    :      93 [9.68e+02 ~ 6.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: FLUXK

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (FLUXK) [13/38=34.2%] fluxk.f(1,18)
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_alloc_allocatable
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_alloc_allocatable
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> INLINE: (25,27) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> (28,12) EXTRAPK (isz = 2061) (sz = 2064)
     [[ Inlining would exceed -inline-max-size value (2064>230) <2>]]
  -> INLINE: (58,27) VISCK (isz = 1807) (sz = 1820)
  -> EXTERN: (69,7) for_dealloc_allocatable
  -> EXTERN: (69,7) for_dealloc_allocatable
  -> EXTERN: (72,7) for_dealloc_allocatable
  -> EXTERN: (72,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxk.f(30,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxk.f(31,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxk.f(33,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.711
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(33,12)
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.560
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 17 
         remark #15477: vector cost: 3.120 
         remark #15478: estimated potential speedup: 4.960 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(33,12)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.690
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(48,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference FSK(:,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference FSK(:,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.714
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(48,12)
         remark #25045: Fused Loops: ( 48 49 )

         remark #15389: vectorization support: reference FSK(:,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference FSK(:,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15388: vectorization support: reference QS(:) has aligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.500
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 18 
         remark #15477: vector cost: 3.500 
         remark #15478: estimated potential speedup: 4.700 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
      LOOP END

      LOOP BEGIN at fluxk.f(49,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(48,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference FSK(:,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference FSK(:,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15388: vectorization support: reference QS(:) has aligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.644
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(51,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference FSK(:,k,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference FSK(:,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference FSK(:,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.639
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(51,12)
         remark #25045: Fused Loops: ( 51 53 55 )

         remark #15389: vectorization support: reference FSK(:,k,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference FSK(:,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference FSK(:,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.804
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 7 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 5.110 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxk.f(53,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(55,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(51,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference FSK(:,k,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference FSK(:,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference FSK(:,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.639
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(283,7) inlined into fluxk.f(58,27)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxk.f(303,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxk.f(303,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxk.f(304,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxk.f(304,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxk.f(305,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxk.f(305,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxk.f(306,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxk.f(306,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxk.f(307,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxk.f(307,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxk.f(308,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxk.f(308,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxk.f(309,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxk.f(309,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxk.f(310,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxk.f(310,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(313,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(314,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(315,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(316,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(318,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(319,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(320,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(321,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(323,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(324,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(325,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(326,17) ]
         remark #15389: vectorization support: reference uav_(i,j-2,k) has unaligned access   [ fluxk.f(335,29) ]
         remark #15389: vectorization support: reference uav_(i,j+2,k) has unaligned access   [ fluxk.f(335,44) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(336,32) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(336,47) ]
         remark #15389: vectorization support: reference vav_(i,j-2,k) has unaligned access   [ fluxk.f(337,29) ]
         remark #15389: vectorization support: reference vav_(i,j+2,k) has unaligned access   [ fluxk.f(337,44) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(338,32) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(338,47) ]
         remark #15389: vectorization support: reference wav_(i,j-2,k) has unaligned access   [ fluxk.f(339,29) ]
         remark #15389: vectorization support: reference wav_(i,j+2,k) has unaligned access   [ fluxk.f(339,44) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(340,32) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(340,47) ]
         remark #15389: vectorization support: reference tav_(i,j-2,k) has unaligned access   [ fluxk.f(341,29) ]
         remark #15389: vectorization support: reference tav_(i,j+2,k) has unaligned access   [ fluxk.f(341,44) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(342,32) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(342,47) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(330,22) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(330,37) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(331,22) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(331,37) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(332,22) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(332,37) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(333,22) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(333,37) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(345,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(346,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(347,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(348,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(350,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(351,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(352,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(353,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(355,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(356,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(357,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(358,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(362,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(362,34) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(363,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(363,34) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(364,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(364,34) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(365,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(365,34) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(367,29) ]
         remark #15389: vectorization support: reference u_(i,j,kcd) has unaligned access   [ fluxk.f(367,42) ]
         remark #15389: vectorization support: reference u_(i,j,kk) has unaligned access   [ fluxk.f(368,32) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(368,45) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(369,29) ]
         remark #15389: vectorization support: reference v_(i,j,kcd) has unaligned access   [ fluxk.f(369,42) ]
         remark #15389: vectorization support: reference v_(i,j,kk) has unaligned access   [ fluxk.f(370,32) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(370,45) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(371,29) ]
         remark #15389: vectorization support: reference w_(i,j,kcd) has unaligned access   [ fluxk.f(371,42) ]
         remark #15389: vectorization support: reference w_(i,j,kk) has unaligned access   [ fluxk.f(372,32) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(372,45) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(373,29) ]
         remark #15389: vectorization support: reference t_(i,j,kcd) has unaligned access   [ fluxk.f(373,42) ]
         remark #15389: vectorization support: reference t_(i,j,kk) has unaligned access   [ fluxk.f(374,32) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(374,45) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(377,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(378,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(379,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(380,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(382,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(383,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(384,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(385,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(387,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(388,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(389,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(390,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(392,24) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(392,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(393,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(393,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(394,24) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(394,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(395,24) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(395,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxk.f(396,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k+1,2) has unaligned access   [ fluxk.f(396,38) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ fluxk.f(417,10) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ fluxk.f(418,10) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ fluxk.f(419,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,23) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,10) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,23) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,10) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,23) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,10) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.269
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(283,7) inlined into fluxk.f(58,27)
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxk.f(303,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxk.f(303,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxk.f(304,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxk.f(304,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxk.f(305,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxk.f(305,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxk.f(306,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxk.f(306,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxk.f(307,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxk.f(307,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxk.f(308,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxk.f(308,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxk.f(309,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxk.f(309,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxk.f(310,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxk.f(310,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(313,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(314,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(315,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(316,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(318,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(319,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(320,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(321,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(323,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(324,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(325,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(326,17) ]
         remark #15389: vectorization support: reference uav_(i,j-2,k) has unaligned access   [ fluxk.f(335,29) ]
         remark #15389: vectorization support: reference uav_(i,j+2,k) has unaligned access   [ fluxk.f(335,44) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(336,32) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(336,47) ]
         remark #15389: vectorization support: reference vav_(i,j-2,k) has unaligned access   [ fluxk.f(337,29) ]
         remark #15389: vectorization support: reference vav_(i,j+2,k) has unaligned access   [ fluxk.f(337,44) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(338,32) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(338,47) ]
         remark #15389: vectorization support: reference wav_(i,j-2,k) has unaligned access   [ fluxk.f(339,29) ]
         remark #15389: vectorization support: reference wav_(i,j+2,k) has unaligned access   [ fluxk.f(339,44) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(340,32) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(340,47) ]
         remark #15389: vectorization support: reference tav_(i,j-2,k) has unaligned access   [ fluxk.f(341,29) ]
         remark #15389: vectorization support: reference tav_(i,j+2,k) has unaligned access   [ fluxk.f(341,44) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(342,32) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(342,47) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(330,22) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(330,37) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(331,22) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(331,37) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(332,22) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(332,37) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(333,22) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(333,37) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(345,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(346,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(347,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(348,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(350,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(351,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(352,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(353,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(355,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(356,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(357,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(358,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(362,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(362,34) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(363,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(363,34) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(364,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(364,34) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(365,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(365,34) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(367,29) ]
         remark #15389: vectorization support: reference u_(i,j,kcd) has unaligned access   [ fluxk.f(367,42) ]
         remark #15389: vectorization support: reference u_(i,j,kk) has unaligned access   [ fluxk.f(368,32) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(368,45) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(369,29) ]
         remark #15389: vectorization support: reference v_(i,j,kcd) has unaligned access   [ fluxk.f(369,42) ]
         remark #15389: vectorization support: reference v_(i,j,kk) has unaligned access   [ fluxk.f(370,32) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(370,45) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(371,29) ]
         remark #15389: vectorization support: reference w_(i,j,kcd) has unaligned access   [ fluxk.f(371,42) ]
         remark #15389: vectorization support: reference w_(i,j,kk) has unaligned access   [ fluxk.f(372,32) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(372,45) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(373,29) ]
         remark #15389: vectorization support: reference t_(i,j,kcd) has unaligned access   [ fluxk.f(373,42) ]
         remark #15389: vectorization support: reference t_(i,j,kk) has unaligned access   [ fluxk.f(374,32) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(374,45) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(377,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(378,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(379,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(380,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(382,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(383,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(384,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(385,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(387,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(388,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(389,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(390,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(392,24) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(392,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(393,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(393,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(394,24) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(394,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(395,24) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(395,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxk.f(396,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k+1,2) has unaligned access   [ fluxk.f(396,38) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ fluxk.f(417,10) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ fluxk.f(418,10) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ fluxk.f(419,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,23) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,10) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,23) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,10) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,23) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,10) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.298
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 50 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15456: masked unaligned unit stride loads: 24 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 673 
         remark #15477: vector cost: 166.370 
         remark #15478: estimated potential speedup: 3.760 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 27
      LOOP END

      LOOP BEGIN at fluxk.f(283,7) inlined into fluxk.f(58,27)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxk.f(303,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxk.f(303,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxk.f(304,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxk.f(304,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxk.f(305,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxk.f(305,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxk.f(306,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxk.f(306,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxk.f(307,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxk.f(307,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxk.f(308,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxk.f(308,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxk.f(309,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxk.f(309,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxk.f(310,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxk.f(310,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(313,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(314,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(315,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(316,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(318,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(319,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(320,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(321,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(323,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(324,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(325,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(326,17) ]
         remark #15389: vectorization support: reference uav_(i,j-2,k) has unaligned access   [ fluxk.f(335,29) ]
         remark #15389: vectorization support: reference uav_(i,j+2,k) has unaligned access   [ fluxk.f(335,44) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(336,32) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(336,47) ]
         remark #15389: vectorization support: reference vav_(i,j-2,k) has unaligned access   [ fluxk.f(337,29) ]
         remark #15389: vectorization support: reference vav_(i,j+2,k) has unaligned access   [ fluxk.f(337,44) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(338,32) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(338,47) ]
         remark #15389: vectorization support: reference wav_(i,j-2,k) has unaligned access   [ fluxk.f(339,29) ]
         remark #15389: vectorization support: reference wav_(i,j+2,k) has unaligned access   [ fluxk.f(339,44) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(340,32) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(340,47) ]
         remark #15389: vectorization support: reference tav_(i,j-2,k) has unaligned access   [ fluxk.f(341,29) ]
         remark #15389: vectorization support: reference tav_(i,j+2,k) has unaligned access   [ fluxk.f(341,44) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(342,32) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(342,47) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(330,22) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(330,37) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(331,22) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(331,37) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(332,22) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(332,37) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(333,22) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(333,37) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(345,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(346,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(347,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(348,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(350,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(351,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(352,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(353,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(355,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(356,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(357,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(358,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(362,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(362,34) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(363,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(363,34) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(364,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(364,34) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(365,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(365,34) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(367,29) ]
         remark #15389: vectorization support: reference u_(i,j,kcd) has unaligned access   [ fluxk.f(367,42) ]
         remark #15389: vectorization support: reference u_(i,j,kk) has unaligned access   [ fluxk.f(368,32) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(368,45) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(369,29) ]
         remark #15389: vectorization support: reference v_(i,j,kcd) has unaligned access   [ fluxk.f(369,42) ]
         remark #15389: vectorization support: reference v_(i,j,kk) has unaligned access   [ fluxk.f(370,32) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(370,45) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(371,29) ]
         remark #15389: vectorization support: reference w_(i,j,kcd) has unaligned access   [ fluxk.f(371,42) ]
         remark #15389: vectorization support: reference w_(i,j,kk) has unaligned access   [ fluxk.f(372,32) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(372,45) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(373,29) ]
         remark #15389: vectorization support: reference t_(i,j,kcd) has unaligned access   [ fluxk.f(373,42) ]
         remark #15389: vectorization support: reference t_(i,j,kk) has unaligned access   [ fluxk.f(374,32) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(374,45) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(377,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(378,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(379,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(380,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(382,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(383,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(384,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(385,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(387,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(388,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(389,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(390,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(392,24) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(392,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(393,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(393,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(394,24) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(394,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(395,24) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(395,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxk.f(396,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k+1,2) has unaligned access   [ fluxk.f(396,38) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ fluxk.f(417,10) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ fluxk.f(418,10) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ fluxk.f(419,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,23) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,10) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,23) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,10) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,23) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,10) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.269
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END

   LOOP BEGIN at fluxk.f(61,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxk.f(63,15)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(63,15)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k,l) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: peel loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 0.356
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 1.870 
            remark #15478: estimated potential speedup: 5.810 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=7
         LOOP END

         LOOP BEGIN at fluxk.f(63,15)
            remark #15388: vectorization support: reference dq_(:,j,k,l) has aligned access
            remark #15388: vectorization support: reference dq_(:,j,k,l) has aligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k,l) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.633
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 1.870 
            remark #15478: estimated potential speedup: 5.810 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxk.f(63,15)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k,l) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.788
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 1.870 
            remark #15478: estimated potential speedup: 5.810 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxk.f(1,18):remark #34051: REGISTER ALLOCATION : [fluxk_] fluxk.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdx]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: FLUXK [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (FLUXK) [13/38=34.2%] fluxk.f(1,18)
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_alloc_allocatable
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_alloc_allocatable
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> INLINE: (25,27) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> (28,12) EXTRAPK (isz = 2061) (sz = 2064)
     [[ Inlining would exceed -inline-max-size value (2064>230) <2>]]
  -> INLINE: (58,27) VISCK (isz = 1807) (sz = 1820)
  -> EXTERN: (69,7) for_dealloc_allocatable
  -> EXTERN: (69,7) for_dealloc_allocatable
  -> EXTERN: (72,7) for_dealloc_allocatable
  -> EXTERN: (72,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxk.f(30,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxk.f(31,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxk.f(33,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.711
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(33,12)
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.560
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 17 
         remark #15477: vector cost: 3.120 
         remark #15478: estimated potential speedup: 4.960 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(33,12)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.690
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(48,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference FSK(:,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference FSK(:,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.714
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(48,12)
         remark #25045: Fused Loops: ( 48 49 )

         remark #15389: vectorization support: reference FSK(:,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference FSK(:,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15388: vectorization support: reference QS(:) has aligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.500
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 18 
         remark #15477: vector cost: 3.500 
         remark #15478: estimated potential speedup: 4.700 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 2
      LOOP END

      LOOP BEGIN at fluxk.f(49,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(48,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference FSK(:,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference FSK(:,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15388: vectorization support: reference QS(:) has aligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.644
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(51,12)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference FSK(:,k,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference FSK(:,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference FSK(:,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.639
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(51,12)
         remark #25045: Fused Loops: ( 51 53 55 )

         remark #15389: vectorization support: reference FSK(:,k,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference FSK(:,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference FSK(:,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.804
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 7 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.750 
         remark #15478: estimated potential speedup: 5.110 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxk.f(53,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(55,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(51,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference FSK(:,k,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference FSK(:,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference FSK(:,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.639
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(283,7) inlined into fluxk.f(58,27)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxk.f(303,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxk.f(303,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxk.f(304,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxk.f(304,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxk.f(305,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxk.f(305,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxk.f(306,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxk.f(306,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxk.f(307,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxk.f(307,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxk.f(308,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxk.f(308,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxk.f(309,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxk.f(309,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxk.f(310,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxk.f(310,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(313,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(314,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(315,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(316,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(318,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(319,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(320,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(321,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(323,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(324,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(325,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(326,17) ]
         remark #15389: vectorization support: reference uav_(i,j-2,k) has unaligned access   [ fluxk.f(335,29) ]
         remark #15389: vectorization support: reference uav_(i,j+2,k) has unaligned access   [ fluxk.f(335,44) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(336,32) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(336,47) ]
         remark #15389: vectorization support: reference vav_(i,j-2,k) has unaligned access   [ fluxk.f(337,29) ]
         remark #15389: vectorization support: reference vav_(i,j+2,k) has unaligned access   [ fluxk.f(337,44) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(338,32) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(338,47) ]
         remark #15389: vectorization support: reference wav_(i,j-2,k) has unaligned access   [ fluxk.f(339,29) ]
         remark #15389: vectorization support: reference wav_(i,j+2,k) has unaligned access   [ fluxk.f(339,44) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(340,32) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(340,47) ]
         remark #15389: vectorization support: reference tav_(i,j-2,k) has unaligned access   [ fluxk.f(341,29) ]
         remark #15389: vectorization support: reference tav_(i,j+2,k) has unaligned access   [ fluxk.f(341,44) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(342,32) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(342,47) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(330,22) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(330,37) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(331,22) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(331,37) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(332,22) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(332,37) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(333,22) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(333,37) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(345,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(346,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(347,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(348,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(350,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(351,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(352,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(353,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(355,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(356,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(357,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(358,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(362,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(362,34) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(363,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(363,34) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(364,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(364,34) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(365,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(365,34) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(367,29) ]
         remark #15389: vectorization support: reference u_(i,j,kcd) has unaligned access   [ fluxk.f(367,42) ]
         remark #15389: vectorization support: reference u_(i,j,kk) has unaligned access   [ fluxk.f(368,32) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(368,45) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(369,29) ]
         remark #15389: vectorization support: reference v_(i,j,kcd) has unaligned access   [ fluxk.f(369,42) ]
         remark #15389: vectorization support: reference v_(i,j,kk) has unaligned access   [ fluxk.f(370,32) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(370,45) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(371,29) ]
         remark #15389: vectorization support: reference w_(i,j,kcd) has unaligned access   [ fluxk.f(371,42) ]
         remark #15389: vectorization support: reference w_(i,j,kk) has unaligned access   [ fluxk.f(372,32) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(372,45) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(373,29) ]
         remark #15389: vectorization support: reference t_(i,j,kcd) has unaligned access   [ fluxk.f(373,42) ]
         remark #15389: vectorization support: reference t_(i,j,kk) has unaligned access   [ fluxk.f(374,32) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(374,45) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(377,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(378,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(379,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(380,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(382,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(383,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(384,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(385,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(387,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(388,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(389,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(390,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(392,24) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(392,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(393,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(393,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(394,24) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(394,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(395,24) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(395,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxk.f(396,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k+1,2) has unaligned access   [ fluxk.f(396,38) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ fluxk.f(417,10) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ fluxk.f(418,10) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ fluxk.f(419,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,23) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,10) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,23) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,10) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,23) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,10) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.269
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(283,7) inlined into fluxk.f(58,27)
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxk.f(303,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxk.f(303,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxk.f(304,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxk.f(304,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxk.f(305,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxk.f(305,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxk.f(306,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxk.f(306,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxk.f(307,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxk.f(307,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxk.f(308,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxk.f(308,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxk.f(309,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxk.f(309,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxk.f(310,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxk.f(310,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(313,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(314,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(315,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(316,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(318,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(319,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(320,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(321,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(323,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(324,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(325,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(326,17) ]
         remark #15389: vectorization support: reference uav_(i,j-2,k) has unaligned access   [ fluxk.f(335,29) ]
         remark #15389: vectorization support: reference uav_(i,j+2,k) has unaligned access   [ fluxk.f(335,44) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(336,32) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(336,47) ]
         remark #15389: vectorization support: reference vav_(i,j-2,k) has unaligned access   [ fluxk.f(337,29) ]
         remark #15389: vectorization support: reference vav_(i,j+2,k) has unaligned access   [ fluxk.f(337,44) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(338,32) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(338,47) ]
         remark #15389: vectorization support: reference wav_(i,j-2,k) has unaligned access   [ fluxk.f(339,29) ]
         remark #15389: vectorization support: reference wav_(i,j+2,k) has unaligned access   [ fluxk.f(339,44) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(340,32) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(340,47) ]
         remark #15389: vectorization support: reference tav_(i,j-2,k) has unaligned access   [ fluxk.f(341,29) ]
         remark #15389: vectorization support: reference tav_(i,j+2,k) has unaligned access   [ fluxk.f(341,44) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(342,32) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(342,47) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(330,22) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(330,37) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(331,22) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(331,37) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(332,22) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(332,37) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(333,22) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(333,37) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(345,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(346,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(347,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(348,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(350,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(351,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(352,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(353,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(355,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(356,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(357,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(358,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(362,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(362,34) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(363,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(363,34) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(364,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(364,34) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(365,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(365,34) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(367,29) ]
         remark #15389: vectorization support: reference u_(i,j,kcd) has unaligned access   [ fluxk.f(367,42) ]
         remark #15389: vectorization support: reference u_(i,j,kk) has unaligned access   [ fluxk.f(368,32) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(368,45) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(369,29) ]
         remark #15389: vectorization support: reference v_(i,j,kcd) has unaligned access   [ fluxk.f(369,42) ]
         remark #15389: vectorization support: reference v_(i,j,kk) has unaligned access   [ fluxk.f(370,32) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(370,45) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(371,29) ]
         remark #15389: vectorization support: reference w_(i,j,kcd) has unaligned access   [ fluxk.f(371,42) ]
         remark #15389: vectorization support: reference w_(i,j,kk) has unaligned access   [ fluxk.f(372,32) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(372,45) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(373,29) ]
         remark #15389: vectorization support: reference t_(i,j,kcd) has unaligned access   [ fluxk.f(373,42) ]
         remark #15389: vectorization support: reference t_(i,j,kk) has unaligned access   [ fluxk.f(374,32) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(374,45) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(377,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(378,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(379,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(380,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(382,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(383,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(384,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(385,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(387,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(388,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(389,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(390,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(392,24) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(392,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(393,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(393,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(394,24) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(394,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(395,24) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(395,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxk.f(396,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k+1,2) has unaligned access   [ fluxk.f(396,38) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ fluxk.f(417,10) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ fluxk.f(418,10) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ fluxk.f(419,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,23) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,10) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,23) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,10) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,23) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,10) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.298
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 50 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15456: masked unaligned unit stride loads: 24 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 673 
         remark #15477: vector cost: 166.370 
         remark #15478: estimated potential speedup: 3.760 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 27
      LOOP END

      LOOP BEGIN at fluxk.f(283,7) inlined into fluxk.f(58,27)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxk.f(303,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxk.f(303,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxk.f(304,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxk.f(304,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxk.f(305,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxk.f(305,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxk.f(306,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxk.f(306,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxk.f(307,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxk.f(307,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxk.f(308,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxk.f(308,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxk.f(309,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxk.f(309,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxk.f(310,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxk.f(310,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(313,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(314,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(315,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(316,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(318,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(319,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(320,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(321,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(323,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(324,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(325,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(326,17) ]
         remark #15389: vectorization support: reference uav_(i,j-2,k) has unaligned access   [ fluxk.f(335,29) ]
         remark #15389: vectorization support: reference uav_(i,j+2,k) has unaligned access   [ fluxk.f(335,44) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(336,32) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(336,47) ]
         remark #15389: vectorization support: reference vav_(i,j-2,k) has unaligned access   [ fluxk.f(337,29) ]
         remark #15389: vectorization support: reference vav_(i,j+2,k) has unaligned access   [ fluxk.f(337,44) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(338,32) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(338,47) ]
         remark #15389: vectorization support: reference wav_(i,j-2,k) has unaligned access   [ fluxk.f(339,29) ]
         remark #15389: vectorization support: reference wav_(i,j+2,k) has unaligned access   [ fluxk.f(339,44) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(340,32) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(340,47) ]
         remark #15389: vectorization support: reference tav_(i,j-2,k) has unaligned access   [ fluxk.f(341,29) ]
         remark #15389: vectorization support: reference tav_(i,j+2,k) has unaligned access   [ fluxk.f(341,44) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(342,32) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(342,47) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(330,22) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(330,37) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(331,22) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(331,37) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(332,22) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(332,37) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(333,22) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(333,37) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(345,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(346,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(347,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(348,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(350,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(351,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(352,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(353,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(355,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(356,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(357,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(358,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(362,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(362,34) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(363,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(363,34) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(364,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(364,34) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(365,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(365,34) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(367,29) ]
         remark #15389: vectorization support: reference u_(i,j,kcd) has unaligned access   [ fluxk.f(367,42) ]
         remark #15389: vectorization support: reference u_(i,j,kk) has unaligned access   [ fluxk.f(368,32) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(368,45) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(369,29) ]
         remark #15389: vectorization support: reference v_(i,j,kcd) has unaligned access   [ fluxk.f(369,42) ]
         remark #15389: vectorization support: reference v_(i,j,kk) has unaligned access   [ fluxk.f(370,32) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(370,45) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(371,29) ]
         remark #15389: vectorization support: reference w_(i,j,kcd) has unaligned access   [ fluxk.f(371,42) ]
         remark #15389: vectorization support: reference w_(i,j,kk) has unaligned access   [ fluxk.f(372,32) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(372,45) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(373,29) ]
         remark #15389: vectorization support: reference t_(i,j,kcd) has unaligned access   [ fluxk.f(373,42) ]
         remark #15389: vectorization support: reference t_(i,j,kk) has unaligned access   [ fluxk.f(374,32) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(374,45) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(377,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(378,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(379,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(380,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(382,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(383,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(384,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(385,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(387,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(388,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(389,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(390,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(392,24) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(392,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(393,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(393,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(394,24) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(394,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(395,24) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(395,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxk.f(396,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k+1,2) has unaligned access   [ fluxk.f(396,38) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ fluxk.f(417,10) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ fluxk.f(418,10) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ fluxk.f(419,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,23) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,10) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,23) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,10) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,23) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,10) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.269
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 1.870 
         remark #15478: estimated potential speedup: 5.810 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END

   LOOP BEGIN at fluxk.f(61,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxk.f(63,15)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(63,15)
         <Peeled loop for vectorization>
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k,l) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: peel loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 0.356
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 1.870 
            remark #15478: estimated potential speedup: 5.810 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=7
         LOOP END

         LOOP BEGIN at fluxk.f(63,15)
            remark #15388: vectorization support: reference dq_(:,j,k,l) has aligned access
            remark #15388: vectorization support: reference dq_(:,j,k,l) has aligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k,l) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15399: vectorization support: unroll factor set to 2
            remark #15309: vectorization support: normalized vectorization overhead 0.633
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 1.870 
            remark #15478: estimated potential speedup: 5.810 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxk.f(63,15)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k,l) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.788
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 1.870 
            remark #15478: estimated potential speedup: 5.810 
            remark #15488: --- end vector cost summary ---
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxk.f(1,18):remark #34051: REGISTER ALLOCATION : [fluxk_.h] fluxk.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   54[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm31 k0-k7]
        
    Routine temporaries
        Total         :    2846
            Global    :     823
            Local     :    2023
        Regenerable   :      85
        Spilled       :     570
        
    Routine stack
        Variables     :     312 bytes*
            Reads     :      14 [9.63e+01 ~ 0.0%]
            Writes    :      53 [3.69e+01 ~ 0.0%]
        Spills        :    5224 bytes*
            Reads     :     916 [2.82e+04 ~ 9.9%]
            Writes    :     625 [8.84e+03 ~ 3.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: FLUXK [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (FLUXK) [13/38=34.2%] fluxk.f(1,18)
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_alloc_allocatable
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> EXTERN: (24,7) for_alloc_allocatable
  -> EXTERN: (24,7) for_check_mult_overflow64
  -> INLINE: (25,27) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> (28,12) EXTRAPK (isz = 2061) (sz = 2064)
     [[ Inlining would exceed -inline-max-size value (2064>230) <2>]]
  -> INLINE: (58,27) VISCK (isz = 1807) (sz = 1820)
  -> EXTERN: (69,7) for_dealloc_allocatable
  -> EXTERN: (69,7) for_dealloc_allocatable
  -> EXTERN: (72,7) for_dealloc_allocatable
  -> EXTERN: (72,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxk.f(30,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxk.f(31,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxk.f(33,12)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at fluxk.f(33,12)
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.368
         remark #15300: LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 17 
         remark #15477: vector cost: 4.750 
         remark #15478: estimated potential speedup: 3.180 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(33,12)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference QS(:) has aligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(33,39) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(33,56) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.474
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 3.000 
         remark #15478: estimated potential speedup: 3.500 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(33,12)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxk.f(48,12)
      <Peeled loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at fluxk.f(48,12)
         remark #25045: Fused Loops: ( 48 49 )

         remark #15389: vectorization support: reference FSK(:,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference FSK(:,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.318
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 18 
         remark #15477: vector cost: 5.500 
         remark #15478: estimated potential speedup: 2.950 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxk.f(49,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(48,12)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference FSK(:,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference FSK(:,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(49,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15389: vectorization support: reference skx_(:,j,k) has unaligned access   [ fluxk.f(49,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.348
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 12 
         remark #15477: vector cost: 3.000 
         remark #15478: estimated potential speedup: 3.500 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      LOOP END

      LOOP BEGIN at fluxk.f(48,12)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxk.f(51,12)
      <Peeled loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at fluxk.f(51,12)
         remark #25045: Fused Loops: ( 51 53 55 )

         remark #15389: vectorization support: reference FSK(:,k,3) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference QS(:) has unaligned access
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference sky_(:,j,k) has unaligned access   [ fluxk.f(51,47) ]
         remark #15389: vectorization support: reference FSK(:,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(53,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference skz_(:,j,k) has unaligned access   [ fluxk.f(53,47) ]
         remark #15389: vectorization support: reference FSK(:,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(55,12) ]
         remark #15389: vectorization support: reference QS(:) has unaligned access   [ fluxk.f(55,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.000
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 7 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 3.300 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxk.f(53,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(55,12)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(51,12)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxk.f(283,7) inlined into fluxk.f(58,27)
      <Peeled loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 9
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at fluxk.f(283,7) inlined into fluxk.f(58,27)
         remark #15389: vectorization support: reference uav_(i-2,j,k) has unaligned access   [ fluxk.f(303,29) ]
         remark #15389: vectorization support: reference uav_(i+2,j,k) has unaligned access   [ fluxk.f(303,44) ]
         remark #15389: vectorization support: reference uav_(i+1,j,k) has unaligned access   [ fluxk.f(304,32) ]
         remark #15389: vectorization support: reference uav_(i-1,j,k) has unaligned access   [ fluxk.f(304,47) ]
         remark #15389: vectorization support: reference vav_(i-2,j,k) has unaligned access   [ fluxk.f(305,29) ]
         remark #15389: vectorization support: reference vav_(i+2,j,k) has unaligned access   [ fluxk.f(305,44) ]
         remark #15389: vectorization support: reference vav_(i+1,j,k) has unaligned access   [ fluxk.f(306,32) ]
         remark #15389: vectorization support: reference vav_(i-1,j,k) has unaligned access   [ fluxk.f(306,47) ]
         remark #15389: vectorization support: reference wav_(i-2,j,k) has unaligned access   [ fluxk.f(307,29) ]
         remark #15389: vectorization support: reference wav_(i+2,j,k) has unaligned access   [ fluxk.f(307,44) ]
         remark #15389: vectorization support: reference wav_(i+1,j,k) has unaligned access   [ fluxk.f(308,32) ]
         remark #15389: vectorization support: reference wav_(i-1,j,k) has unaligned access   [ fluxk.f(308,47) ]
         remark #15389: vectorization support: reference tav_(i-2,j,k) has unaligned access   [ fluxk.f(309,29) ]
         remark #15389: vectorization support: reference tav_(i+2,j,k) has unaligned access   [ fluxk.f(309,44) ]
         remark #15389: vectorization support: reference tav_(i+1,j,k) has unaligned access   [ fluxk.f(310,32) ]
         remark #15389: vectorization support: reference tav_(i-1,j,k) has unaligned access   [ fluxk.f(310,47) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(313,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(314,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(315,17) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ fluxk.f(316,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(318,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(319,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(320,17) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ fluxk.f(321,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(323,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(324,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(325,17) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ fluxk.f(326,17) ]
         remark #15389: vectorization support: reference uav_(i,j-2,k) has unaligned access   [ fluxk.f(335,29) ]
         remark #15389: vectorization support: reference uav_(i,j+2,k) has unaligned access   [ fluxk.f(335,44) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(336,32) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(336,47) ]
         remark #15389: vectorization support: reference vav_(i,j-2,k) has unaligned access   [ fluxk.f(337,29) ]
         remark #15389: vectorization support: reference vav_(i,j+2,k) has unaligned access   [ fluxk.f(337,44) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(338,32) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(338,47) ]
         remark #15389: vectorization support: reference wav_(i,j-2,k) has unaligned access   [ fluxk.f(339,29) ]
         remark #15389: vectorization support: reference wav_(i,j+2,k) has unaligned access   [ fluxk.f(339,44) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(340,32) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(340,47) ]
         remark #15389: vectorization support: reference tav_(i,j-2,k) has unaligned access   [ fluxk.f(341,29) ]
         remark #15389: vectorization support: reference tav_(i,j+2,k) has unaligned access   [ fluxk.f(341,44) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(342,32) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(342,47) ]
         remark #15389: vectorization support: reference uav_(i,j+1,k) has unaligned access   [ fluxk.f(330,22) ]
         remark #15389: vectorization support: reference uav_(i,j-1,k) has unaligned access   [ fluxk.f(330,37) ]
         remark #15389: vectorization support: reference vav_(i,j+1,k) has unaligned access   [ fluxk.f(331,22) ]
         remark #15389: vectorization support: reference vav_(i,j-1,k) has unaligned access   [ fluxk.f(331,37) ]
         remark #15389: vectorization support: reference wav_(i,j+1,k) has unaligned access   [ fluxk.f(332,22) ]
         remark #15389: vectorization support: reference wav_(i,j-1,k) has unaligned access   [ fluxk.f(332,37) ]
         remark #15389: vectorization support: reference tav_(i,j+1,k) has unaligned access   [ fluxk.f(333,22) ]
         remark #15389: vectorization support: reference tav_(i,j-1,k) has unaligned access   [ fluxk.f(333,37) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(345,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(346,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(347,24) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ fluxk.f(348,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(350,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(351,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(352,24) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ fluxk.f(353,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(355,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(356,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(357,24) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ fluxk.f(358,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(362,21) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(362,34) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(363,21) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(363,34) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(364,21) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(364,34) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(365,21) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(365,34) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(367,29) ]
         remark #15389: vectorization support: reference u_(i,j,kcd) has unaligned access   [ fluxk.f(367,42) ]
         remark #15389: vectorization support: reference u_(i,j,kk) has unaligned access   [ fluxk.f(368,32) ]
         remark #15389: vectorization support: reference u_(i,j,kbd) has unaligned access   [ fluxk.f(368,45) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(369,29) ]
         remark #15389: vectorization support: reference v_(i,j,kcd) has unaligned access   [ fluxk.f(369,42) ]
         remark #15389: vectorization support: reference v_(i,j,kk) has unaligned access   [ fluxk.f(370,32) ]
         remark #15389: vectorization support: reference v_(i,j,kbd) has unaligned access   [ fluxk.f(370,45) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(371,29) ]
         remark #15389: vectorization support: reference w_(i,j,kcd) has unaligned access   [ fluxk.f(371,42) ]
         remark #15389: vectorization support: reference w_(i,j,kk) has unaligned access   [ fluxk.f(372,32) ]
         remark #15389: vectorization support: reference w_(i,j,kbd) has unaligned access   [ fluxk.f(372,45) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(373,29) ]
         remark #15389: vectorization support: reference t_(i,j,kcd) has unaligned access   [ fluxk.f(373,42) ]
         remark #15389: vectorization support: reference t_(i,j,kk) has unaligned access   [ fluxk.f(374,32) ]
         remark #15389: vectorization support: reference t_(i,j,kbd) has unaligned access   [ fluxk.f(374,45) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(377,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(378,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(379,24) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ fluxk.f(380,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(382,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(383,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(384,24) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ fluxk.f(385,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(387,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(388,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(389,24) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ fluxk.f(390,24) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ fluxk.f(392,24) ]
         remark #15389: vectorization support: reference t_(i,j,k+1) has unaligned access   [ fluxk.f(392,38) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ fluxk.f(393,24) ]
         remark #15389: vectorization support: reference u_(i,j,k+1) has unaligned access   [ fluxk.f(393,38) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ fluxk.f(394,24) ]
         remark #15389: vectorization support: reference v_(i,j,k+1) has unaligned access   [ fluxk.f(394,38) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ fluxk.f(395,24) ]
         remark #15389: vectorization support: reference w_(i,j,k+1) has unaligned access   [ fluxk.f(395,38) ]
         remark #15389: vectorization support: reference hf_(i,j,k,2) has unaligned access   [ fluxk.f(396,24) ]
         remark #15389: vectorization support: reference hf_(i,j,k+1,2) has unaligned access   [ fluxk.f(396,38) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ fluxk.f(417,10) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ fluxk.f(418,10) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ fluxk.f(419,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,10) ]
         remark #15389: vectorization support: reference FSK(i,k,2) has unaligned access   [ fluxk.f(421,23) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,10) ]
         remark #15389: vectorization support: reference FSK(i,k,3) has unaligned access   [ fluxk.f(422,23) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,10) ]
         remark #15389: vectorization support: reference FSK(i,k,4) has unaligned access   [ fluxk.f(423,23) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,10) ]
         remark #15389: vectorization support: reference FSK(i,k,5) has unaligned access   [ fluxk.f(424,23) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.327
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 50 
         remark #15451: unmasked unaligned unit stride stores: 4 
         remark #15456: masked unaligned unit stride loads: 24 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 673 
         remark #15477: vector cost: 303.250 
         remark #15478: estimated potential speedup: 2.170 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 27
      LOOP END

      LOOP BEGIN at fluxk.f(283,7) inlined into fluxk.f(58,27)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END

   LOOP BEGIN at fluxk.f(61,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxk.f(63,15)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(63,15)
         <Peeled loop for vectorization>
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at fluxk.f(63,15)
            remark #15388: vectorization support: reference dq_(:,j,k,l) has aligned access
            remark #15388: vectorization support: reference dq_(:,j,k,l) has aligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k,l) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15399: vectorization support: unroll factor set to 4
            remark #15309: vectorization support: normalized vectorization overhead 0.396
            remark #15300: LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 3.000 
            remark #15478: estimated potential speedup: 3.500 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxk.f(63,15)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dq_(:,j,k,l) has unaligned access
            remark #15389: vectorization support: reference dtv_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k,l) has unaligned access
            remark #15389: vectorization support: reference FSK(:,k-1,l) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.667
            remark #15301: REMAINDER LOOP WAS VECTORIZED
            remark #15442: entire loop may be executed in remainder
            remark #15448: unmasked aligned unit stride loads: 1 
            remark #15449: unmasked aligned unit stride stores: 1 
            remark #15450: unmasked unaligned unit stride loads: 3 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 12 
            remark #15477: vector cost: 3.000 
            remark #15478: estimated potential speedup: 3.500 
            remark #15488: --- end vector cost summary ---
         LOOP END

         LOOP BEGIN at fluxk.f(63,15)
         <Remainder loop for vectorization>
         LOOP END
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxk.f(1,18):remark #34051: REGISTER ALLOCATION : [fluxk_.A] fluxk.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :    1964
            Global    :     671
            Local     :    1293
        Regenerable   :      73
        Spilled       :     494
        
    Routine stack
        Variables     :     312 bytes*
            Reads     :      14 [1.64e+02 ~ 0.1%]
            Writes    :      53 [3.69e+01 ~ 0.0%]
        Spills        :    4568 bytes*
            Reads     :     977 [4.15e+04 ~ 18.6%]
            Writes    :     597 [1.83e+04 ~ 8.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ALLOC

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ALLOC) [14/38=36.8%] alloc.f(1,18)
  -> EXTERN: (12,7) for_check_mult_overflow64
  -> EXTERN: (12,7) for_alloc_allocatable
  -> EXTERN: (12,7) for_check_mult_overflow64
  -> EXTERN: (12,7) for_check_mult_overflow64
  -> EXTERN: (12,7) for_alloc_allocatable
  -> EXTERN: (12,7) for_check_mult_overflow64
  -> EXTERN: (12,7) for_check_mult_overflow64
  -> EXTERN: (12,7) for_alloc_allocatable
  -> EXTERN: (12,7) for_check_mult_overflow64
  -> INLINE: (16,15) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_alloc_allocatable
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_alloc_allocatable
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_alloc_allocatable
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_alloc_allocatable
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_alloc_allocatable
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_alloc_allocatable
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_alloc_allocatable
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_alloc_allocatable
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_alloc_allocatable
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_alloc_allocatable
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_alloc_allocatable
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> EXTERN: (20,7) for_alloc_allocatable
  -> EXTERN: (20,7) for_check_mult_overflow64
  -> INLINE: (34,15) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (38,7) for_check_mult_overflow64
  -> EXTERN: (38,7) for_alloc_allocatable
  -> EXTERN: (38,7) for_check_mult_overflow64
  -> EXTERN: (38,7) for_check_mult_overflow64
  -> EXTERN: (38,7) for_alloc_allocatable
  -> EXTERN: (38,7) for_check_mult_overflow64
  -> EXTERN: (38,7) for_check_mult_overflow64
  -> EXTERN: (38,7) for_alloc_allocatable
  -> EXTERN: (38,7) for_check_mult_overflow64
  -> INLINE: (43,15) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_alloc_allocatable
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_alloc_allocatable
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_alloc_allocatable
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_alloc_allocatable
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_alloc_allocatable
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_alloc_allocatable
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_alloc_allocatable
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_alloc_allocatable
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_alloc_allocatable
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_alloc_allocatable
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> EXTERN: (47,7) for_alloc_allocatable
  -> EXTERN: (47,7) for_check_mult_overflow64
  -> INLINE: (60,15) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_alloc_allocatable
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_alloc_allocatable
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_alloc_allocatable
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_alloc_allocatable
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_alloc_allocatable
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_alloc_allocatable
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_alloc_allocatable
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_alloc_allocatable
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_alloc_allocatable
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_alloc_allocatable
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> EXTERN: (80,7) for_alloc_allocatable
  -> EXTERN: (80,7) for_check_mult_overflow64
  -> INLINE: (93,15) EJECT (isz = 24) (sz = 31)
    -> EXTERN: main.f:(364,7) for_write_seq_fmt
    -> EXTERN: main.f:(365,12) mpi_abort_
    -> EXTERN: main.f:(367,7) for_stop_core


    Report from: Code generation optimizations [cg]

alloc.f(1,18):remark #34051: REGISTER ALLOCATION : [alloc_] alloc.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rax rdx rcx rbx rbp rsi rdi r8-r15]
        
    Routine temporaries
        Total         :    3084
            Global    :     172
            Local     :    2912
        Regenerable   :     621
        Spilled       :      15
        
    Routine stack
        Variables     :    1060 bytes*
            Reads     :      40 [9.50e+00 ~ 1.1%]
            Writes    :      15 [3.30e+00 ~ 0.4%]
        Spills        :      72 bytes*
            Reads     :      65 [3.24e+01 ~ 3.9%]
            Writes    :      62 [2.10e+01 ~ 2.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: GRID

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (GRID) [15/38=39.5%] grid.f(1,18)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at grid.f(47,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(48,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at grid.f(49,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(53,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(54,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(55,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.600
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 30 
         remark #15477: vector cost: 2.500 
         remark #15478: estimated potential speedup: 10.970 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(49,13)
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(53,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(54,16) ]
         remark #15388: vectorization support: reference z_(i,j,k) has aligned access   [ grid.f(55,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.500
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 30 
         remark #15477: vector cost: 2.500 
         remark #15478: estimated potential speedup: 10.970 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(49,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(53,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(54,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(55,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.600
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 30 
         remark #15477: vector cost: 2.500 
         remark #15478: estimated potential speedup: 10.970 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at grid.f(69,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(70,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at grid.f(71,11)
      <Peeled, Peeled loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(73,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(74,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(75,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(76,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(77,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(78,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(79,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(80,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(81,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(82,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(83,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(84,16) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(85,16) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(86,16) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(87,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(88,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(89,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(90,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(91,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(92,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(93,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(94,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(95,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(96,16) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ grid.f(98,16) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ grid.f(99,16) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ grid.f(100,16) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ grid.f(102,16) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ grid.f(103,16) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ grid.f(104,16) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ grid.f(106,16) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ grid.f(107,16) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ grid.f(108,16) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ grid.f(139,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ grid.f(146,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.258
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(71,11)
      <Peeled>
         remark #25427: Loop Statements Reordered
         remark #25430: Scalar Expansion Performed at line 71   [ grid.f(73,16) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(73,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(74,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(75,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(76,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(77,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(78,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(79,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(80,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(81,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(82,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(83,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(84,16) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(85,16) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(86,16) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(87,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(88,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(89,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(90,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(91,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(92,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(93,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(94,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(95,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(96,16) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ grid.f(98,16) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ grid.f(99,16) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ grid.f(100,16) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ grid.f(102,16) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ grid.f(103,16) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ grid.f(104,16) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ grid.f(106,16) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ grid.f(107,16) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ grid.f(108,16) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ grid.f(139,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ grid.f(146,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.460
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 24 
         remark #15451: unmasked unaligned unit stride stores: 11 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 840 
         remark #15477: vector cost: 116.120 
         remark #15478: estimated potential speedup: 6.700 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(71,11)
      <Peeled, Remainder loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(73,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(74,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(75,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(76,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(77,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(78,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(79,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(80,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(81,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(82,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(83,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(84,16) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(85,16) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(86,16) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(87,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(88,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(89,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(90,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(91,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(92,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(93,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(94,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(95,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(96,16) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ grid.f(98,16) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ grid.f(99,16) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ grid.f(100,16) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ grid.f(102,16) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ grid.f(103,16) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ grid.f(104,16) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ grid.f(106,16) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ grid.f(107,16) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ grid.f(108,16) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ grid.f(139,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ grid.f(146,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.258
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at grid.f(160,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(161,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at grid.f(162,11)
      <Peeled, Peeled loop for vectorization>
         remark #15389: vectorization support: reference x_(i+2,j+1,k) has unaligned access   [ grid.f(164,36) ]
         remark #15389: vectorization support: reference x_(i+2,j,k) has unaligned access   [ grid.f(164,49) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(165,32) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(165,43) ]
         remark #15389: vectorization support: reference x_(i+2,j+1,k+1) has unaligned access   [ grid.f(166,32) ]
         remark #15389: vectorization support: reference x_(i+2,j,k+1) has unaligned access   [ grid.f(166,47) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(167,32) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(167,45) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k) has unaligned access   [ grid.f(168,36) ]
         remark #15389: vectorization support: reference y_(i+2,j,k) has unaligned access   [ grid.f(168,49) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(169,32) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(169,43) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k+1) has unaligned access   [ grid.f(170,32) ]
         remark #15389: vectorization support: reference y_(i+2,j,k+1) has unaligned access   [ grid.f(170,47) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(171,32) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(171,45) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k) has unaligned access   [ grid.f(172,36) ]
         remark #15389: vectorization support: reference z_(i+2,j,k) has unaligned access   [ grid.f(172,49) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(173,32) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(173,43) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k+1) has unaligned access   [ grid.f(174,32) ]
         remark #15389: vectorization support: reference z_(i+2,j,k+1) has unaligned access   [ grid.f(174,47) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(175,32) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(175,45) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(176,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(176,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(177,27) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(177,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(178,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(178,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(179,27) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(179,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(180,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(180,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(181,27) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(181,42) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(182,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(182,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(183,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(183,42) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(184,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(184,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(185,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(185,42) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(186,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(186,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(187,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(187,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,1) has unaligned access   [ grid.f(203,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,1) has unaligned access   [ grid.f(204,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,1) has unaligned access   [ grid.f(205,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,1) has unaligned access   [ grid.f(207,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,1) has unaligned access   [ grid.f(208,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,1) has unaligned access   [ grid.f(209,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,1) has unaligned access   [ grid.f(211,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,1) has unaligned access   [ grid.f(212,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,1) has unaligned access   [ grid.f(213,13) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(215,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(215,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(216,27) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(216,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(217,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(217,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(218,27) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(218,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(219,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(219,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(220,27) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(220,42) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k) has unaligned access   [ grid.f(221,33) ]
         remark #15389: vectorization support: reference x_(i,j+2,k) has unaligned access   [ grid.f(221,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(222,29) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(222,40) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k+1) has unaligned access   [ grid.f(223,29) ]
         remark #15389: vectorization support: reference x_(i,j+2,k+1) has unaligned access   [ grid.f(223,44) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(224,29) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(224,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k) has unaligned access   [ grid.f(225,33) ]
         remark #15389: vectorization support: reference y_(i,j+2,k) has unaligned access   [ grid.f(225,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(226,29) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(226,40) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k+1) has unaligned access   [ grid.f(227,29) ]
         remark #15389: vectorization support: reference y_(i,j+2,k+1) has unaligned access   [ grid.f(227,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(228,29) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(228,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k) has unaligned access   [ grid.f(229,33) ]
         remark #15389: vectorization support: reference z_(i,j+2,k) has unaligned access   [ grid.f(229,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(230,29) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(230,40) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k+1) has unaligned access   [ grid.f(231,29) ]
         remark #15389: vectorization support: reference z_(i,j+2,k+1) has unaligned access   [ grid.f(231,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(232,29) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(232,42) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(233,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(233,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(234,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(234,42) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(235,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(235,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(236,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(236,42) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(237,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(237,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(238,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(238,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ grid.f(256,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ grid.f(257,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ grid.f(258,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ grid.f(260,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ grid.f(261,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ grid.f(262,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ grid.f(264,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ grid.f(265,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ grid.f(266,13) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(268,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(268,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(269,24) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(269,39) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(270,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(270,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(271,24) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(271,39) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(272,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(272,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(273,24) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(273,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(274,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(274,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(275,24) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(275,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(276,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(276,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(277,24) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(277,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(278,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(278,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(279,24) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(279,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+2) has unaligned access   [ grid.f(280,30) ]
         remark #15389: vectorization support: reference x_(i,j,k+2) has unaligned access   [ grid.f(280,43) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(281,26) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(281,37) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+2) has unaligned access   [ grid.f(282,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+2) has unaligned access   [ grid.f(282,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(283,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(283,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+2) has unaligned access   [ grid.f(284,30) ]
         remark #15389: vectorization support: reference y_(i,j,k+2) has unaligned access   [ grid.f(284,43) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(285,26) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(285,37) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+2) has unaligned access   [ grid.f(286,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+2) has unaligned access   [ grid.f(286,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(287,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(287,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+2) has unaligned access   [ grid.f(288,30) ]
         remark #15389: vectorization support: reference z_(i,j,k+2) has unaligned access   [ grid.f(288,43) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(289,26) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(289,37) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+2) has unaligned access   [ grid.f(290,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+2) has unaligned access   [ grid.f(290,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(291,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(291,39) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ grid.f(307,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ grid.f(308,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ grid.f(309,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ grid.f(311,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ grid.f(312,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ grid.f(313,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ grid.f(315,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ grid.f(316,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ grid.f(317,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.323
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(162,11)
      <Peeled>
         remark #25427: Loop Statements Reordered
         remark #25430: Scalar Expansion Performed at line 162   [ grid.f(268,13) ]
         remark #15389: vectorization support: reference x_(i+2,j+1,k) has unaligned access   [ grid.f(164,36) ]
         remark #15389: vectorization support: reference x_(i+2,j,k) has unaligned access   [ grid.f(164,49) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(165,32) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(165,43) ]
         remark #15389: vectorization support: reference x_(i+2,j+1,k+1) has unaligned access   [ grid.f(166,32) ]
         remark #15389: vectorization support: reference x_(i+2,j,k+1) has unaligned access   [ grid.f(166,47) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(167,32) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(167,45) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k) has unaligned access   [ grid.f(168,36) ]
         remark #15389: vectorization support: reference y_(i+2,j,k) has unaligned access   [ grid.f(168,49) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(169,32) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(169,43) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k+1) has unaligned access   [ grid.f(170,32) ]
         remark #15389: vectorization support: reference y_(i+2,j,k+1) has unaligned access   [ grid.f(170,47) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(171,32) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(171,45) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k) has unaligned access   [ grid.f(172,36) ]
         remark #15389: vectorization support: reference z_(i+2,j,k) has unaligned access   [ grid.f(172,49) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(173,32) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(173,43) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k+1) has unaligned access   [ grid.f(174,32) ]
         remark #15389: vectorization support: reference z_(i+2,j,k+1) has unaligned access   [ grid.f(174,47) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(175,32) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(175,45) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(176,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(176,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(177,27) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(177,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(178,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(178,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(179,27) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(179,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(180,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(180,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(181,27) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(181,42) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(182,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(182,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(183,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(183,42) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(184,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(184,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(185,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(185,42) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(186,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(186,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(187,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(187,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,1) has unaligned access   [ grid.f(203,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,1) has unaligned access   [ grid.f(204,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,1) has unaligned access   [ grid.f(205,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,1) has unaligned access   [ grid.f(207,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,1) has unaligned access   [ grid.f(208,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,1) has unaligned access   [ grid.f(209,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,1) has unaligned access   [ grid.f(211,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,1) has unaligned access   [ grid.f(212,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,1) has unaligned access   [ grid.f(213,13) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(215,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(215,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(216,27) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(216,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(217,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(217,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(218,27) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(218,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(219,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(219,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(220,27) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(220,42) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k) has unaligned access   [ grid.f(221,33) ]
         remark #15389: vectorization support: reference x_(i,j+2,k) has unaligned access   [ grid.f(221,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(222,29) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(222,40) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k+1) has unaligned access   [ grid.f(223,29) ]
         remark #15389: vectorization support: reference x_(i,j+2,k+1) has unaligned access   [ grid.f(223,44) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(224,29) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(224,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k) has unaligned access   [ grid.f(225,33) ]
         remark #15389: vectorization support: reference y_(i,j+2,k) has unaligned access   [ grid.f(225,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(226,29) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(226,40) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k+1) has unaligned access   [ grid.f(227,29) ]
         remark #15389: vectorization support: reference y_(i,j+2,k+1) has unaligned access   [ grid.f(227,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(228,29) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(228,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k) has unaligned access   [ grid.f(229,33) ]
         remark #15389: vectorization support: reference z_(i,j+2,k) has unaligned access   [ grid.f(229,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(230,29) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(230,40) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k+1) has unaligned access   [ grid.f(231,29) ]
         remark #15389: vectorization support: reference z_(i,j+2,k+1) has unaligned access   [ grid.f(231,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(232,29) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(232,42) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(233,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(233,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(234,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(234,42) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(235,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(235,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(236,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(236,42) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(237,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(237,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(238,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(238,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ grid.f(256,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ grid.f(257,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ grid.f(258,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ grid.f(260,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ grid.f(261,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ grid.f(262,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ grid.f(264,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ grid.f(265,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ grid.f(266,13) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(268,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(268,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(269,24) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(269,39) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(270,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(270,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(271,24) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(271,39) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(272,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(272,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(273,24) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(273,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(274,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(274,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(275,24) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(275,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(276,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(276,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(277,24) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(277,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(278,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(278,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(279,24) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(279,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+2) has unaligned access   [ grid.f(280,30) ]
         remark #15389: vectorization support: reference x_(i,j,k+2) has unaligned access   [ grid.f(280,43) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(281,26) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(281,37) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+2) has unaligned access   [ grid.f(282,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+2) has unaligned access   [ grid.f(282,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(283,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(283,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+2) has unaligned access   [ grid.f(284,30) ]
         remark #15389: vectorization support: reference y_(i,j,k+2) has unaligned access   [ grid.f(284,43) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(285,26) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(285,37) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+2) has unaligned access   [ grid.f(286,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+2) has unaligned access   [ grid.f(286,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(287,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(287,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+2) has unaligned access   [ grid.f(288,30) ]
         remark #15389: vectorization support: reference z_(i,j,k+2) has unaligned access   [ grid.f(288,43) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(289,26) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(289,37) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+2) has unaligned access   [ grid.f(290,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+2) has unaligned access   [ grid.f(290,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(291,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(291,39) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ grid.f(307,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ grid.f(308,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ grid.f(309,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ grid.f(311,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ grid.f(312,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ grid.f(313,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ grid.f(315,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ grid.f(316,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ grid.f(317,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.398
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 60 
         remark #15451: unmasked unaligned unit stride stores: 27 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 876 
         remark #15477: vector cost: 133.250 
         remark #15478: estimated potential speedup: 6.100 
         remark #15486: divides: 3 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(162,11)
      <Peeled, Remainder loop for vectorization>
         remark #15389: vectorization support: reference x_(i+2,j+1,k) has unaligned access   [ grid.f(164,36) ]
         remark #15389: vectorization support: reference x_(i+2,j,k) has unaligned access   [ grid.f(164,49) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(165,32) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(165,43) ]
         remark #15389: vectorization support: reference x_(i+2,j+1,k+1) has unaligned access   [ grid.f(166,32) ]
         remark #15389: vectorization support: reference x_(i+2,j,k+1) has unaligned access   [ grid.f(166,47) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(167,32) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(167,45) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k) has unaligned access   [ grid.f(168,36) ]
         remark #15389: vectorization support: reference y_(i+2,j,k) has unaligned access   [ grid.f(168,49) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(169,32) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(169,43) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k+1) has unaligned access   [ grid.f(170,32) ]
         remark #15389: vectorization support: reference y_(i+2,j,k+1) has unaligned access   [ grid.f(170,47) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(171,32) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(171,45) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k) has unaligned access   [ grid.f(172,36) ]
         remark #15389: vectorization support: reference z_(i+2,j,k) has unaligned access   [ grid.f(172,49) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(173,32) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(173,43) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k+1) has unaligned access   [ grid.f(174,32) ]
         remark #15389: vectorization support: reference z_(i+2,j,k+1) has unaligned access   [ grid.f(174,47) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(175,32) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(175,45) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(176,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(176,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(177,27) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(177,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(178,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(178,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(179,27) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(179,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(180,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(180,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(181,27) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(181,42) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(182,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(182,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(183,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(183,42) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(184,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(184,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(185,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(185,42) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(186,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(186,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(187,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(187,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,1) has unaligned access   [ grid.f(203,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,1) has unaligned access   [ grid.f(204,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,1) has unaligned access   [ grid.f(205,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,1) has unaligned access   [ grid.f(207,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,1) has unaligned access   [ grid.f(208,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,1) has unaligned access   [ grid.f(209,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,1) has unaligned access   [ grid.f(211,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,1) has unaligned access   [ grid.f(212,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,1) has unaligned access   [ grid.f(213,13) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(215,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(215,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(216,27) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(216,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(217,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(217,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(218,27) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(218,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(219,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(219,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(220,27) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(220,42) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k) has unaligned access   [ grid.f(221,33) ]
         remark #15389: vectorization support: reference x_(i,j+2,k) has unaligned access   [ grid.f(221,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(222,29) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(222,40) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k+1) has unaligned access   [ grid.f(223,29) ]
         remark #15389: vectorization support: reference x_(i,j+2,k+1) has unaligned access   [ grid.f(223,44) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(224,29) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(224,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k) has unaligned access   [ grid.f(225,33) ]
         remark #15389: vectorization support: reference y_(i,j+2,k) has unaligned access   [ grid.f(225,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(226,29) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(226,40) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k+1) has unaligned access   [ grid.f(227,29) ]
         remark #15389: vectorization support: reference y_(i,j+2,k+1) has unaligned access   [ grid.f(227,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(228,29) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(228,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k) has unaligned access   [ grid.f(229,33) ]
         remark #15389: vectorization support: reference z_(i,j+2,k) has unaligned access   [ grid.f(229,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(230,29) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(230,40) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k+1) has unaligned access   [ grid.f(231,29) ]
         remark #15389: vectorization support: reference z_(i,j+2,k+1) has unaligned access   [ grid.f(231,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(232,29) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(232,42) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(233,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(233,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(234,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(234,42) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(235,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(235,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(236,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(236,42) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(237,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(237,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(238,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(238,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ grid.f(256,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ grid.f(257,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ grid.f(258,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ grid.f(260,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ grid.f(261,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ grid.f(262,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ grid.f(264,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ grid.f(265,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ grid.f(266,13) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(268,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(268,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(269,24) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(269,39) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(270,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(270,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(271,24) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(271,39) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(272,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(272,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(273,24) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(273,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(274,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(274,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(275,24) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(275,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(276,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(276,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(277,24) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(277,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(278,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(278,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(279,24) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(279,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+2) has unaligned access   [ grid.f(280,30) ]
         remark #15389: vectorization support: reference x_(i,j,k+2) has unaligned access   [ grid.f(280,43) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(281,26) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(281,37) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+2) has unaligned access   [ grid.f(282,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+2) has unaligned access   [ grid.f(282,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(283,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(283,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+2) has unaligned access   [ grid.f(284,30) ]
         remark #15389: vectorization support: reference y_(i,j,k+2) has unaligned access   [ grid.f(284,43) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(285,26) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(285,37) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+2) has unaligned access   [ grid.f(286,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+2) has unaligned access   [ grid.f(286,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(287,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(287,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+2) has unaligned access   [ grid.f(288,30) ]
         remark #15389: vectorization support: reference z_(i,j,k+2) has unaligned access   [ grid.f(288,43) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(289,26) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(289,37) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+2) has unaligned access   [ grid.f(290,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+2) has unaligned access   [ grid.f(290,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(291,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(291,39) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ grid.f(307,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ grid.f(308,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ grid.f(309,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ grid.f(311,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ grid.f(312,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ grid.f(313,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ grid.f(315,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ grid.f(316,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ grid.f(317,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.323
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at grid.f(400,7)
   remark #25045: Fused Loops: ( 400 428 )

   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(401,10)
   <Peeled>
      remark #25045: Fused Loops: ( 401 430 )

      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at grid.f(402,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(404,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(404,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(405,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(405,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(406,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(406,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(407,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(407,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(408,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(408,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(409,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(409,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(410,33) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(410,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(411,29) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(411,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(412,33) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(412,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(413,29) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(413,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(414,33) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(414,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(415,29) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(415,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(420,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.320
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(402,13)
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(404,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(404,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(405,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(405,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(406,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(406,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(407,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(407,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(408,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(408,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(409,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(409,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(410,33) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(410,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(411,29) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(411,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(412,33) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(412,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(413,29) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(413,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(414,33) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(414,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(415,29) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(415,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(420,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.516
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 24 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 140 
         remark #15477: vector cost: 22.750 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(402,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(404,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(404,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(405,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(405,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(406,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(406,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(407,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(407,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(408,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(408,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(409,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(409,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(410,33) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(410,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(411,29) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(411,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(412,33) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(412,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(413,29) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(413,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(414,33) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(414,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(415,29) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(415,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(420,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.320
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(422,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ grid.f(423,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(423,40) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ grid.f(423,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.339
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(422,13)
         remark #15388: vectorization support: reference ds1_(i,j,k,1) has aligned access   [ grid.f(423,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(423,40) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ grid.f(423,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.195
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(422,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ grid.f(423,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(423,40) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ grid.f(423,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.339
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(429,10)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(432,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(432,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(433,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(433,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(434,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(434,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(435,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(435,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(436,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(436,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(437,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(437,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(438,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(438,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(439,29) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(439,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(440,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(440,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(441,29) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(441,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(442,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(442,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(443,29) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(443,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(448,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.320
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(429,10)
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(432,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(432,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(433,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(433,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(434,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(434,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(435,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(435,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(436,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(436,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(437,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(437,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(438,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(438,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(439,29) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(439,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(440,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(440,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(441,29) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(441,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(442,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(442,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(443,29) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(443,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(448,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.516
         remark #15301: PERMUTED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 24 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 140 
         remark #15477: vector cost: 22.750 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(429,10)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(432,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(432,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(433,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(433,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(434,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(434,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(435,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(435,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(436,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(436,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(437,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(437,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(438,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(438,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(439,29) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(439,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(440,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(440,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(441,29) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(441,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(442,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(442,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(443,29) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(443,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(448,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.320
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END

   LOOP BEGIN at grid.f(429,10)
   <Distributed chunk1>
      remark #25426: Loop Distributed (2 way) 
      remark #25444: Loopnest Interchanged: ( 1 2 ) --> ( 2 1 )
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at grid.f(450,13)
   <Distributed chunk2>
      remark #25444: Loopnest Interchanged: ( 1 2 ) --> ( 2 1 )
      remark #15542: loop was not vectorized: inner loop was already vectorized   [ grid.f(450,13) ]

      LOOP BEGIN at grid.f(429,10)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,2) has unaligned access   [ grid.f(451,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(451,40) ]
         remark #15389: vectorization support: reference ds_(i,j+1,k,2) has unaligned access   [ grid.f(451,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.339
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(429,10)
         remark #15388: vectorization support: reference ds1_(i,j,k,2) has aligned access   [ grid.f(451,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(451,40) ]
         remark #15389: vectorization support: reference ds_(i,j+1,k,2) has unaligned access   [ grid.f(451,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.195
         remark #15301: PERMUTED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(429,10)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,2) has unaligned access   [ grid.f(451,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(451,40) ]
         remark #15389: vectorization support: reference ds_(i,j+1,k,2) has unaligned access   [ grid.f(451,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.339
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at grid.f(428,7)
   remark #25046: Loop lost in Fusion 
LOOP END

LOOP BEGIN at grid.f(456,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(458,13)
   <Distributed chunk1>
      remark #25426: Loop Distributed (2 way) 
      remark #25444: Loopnest Interchanged: ( 1 2 ) --> ( 2 1 )
      remark #15542: loop was not vectorized: inner loop was already vectorized   [ grid.f(458,13) ]

      LOOP BEGIN at grid.f(457,10)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(460,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(460,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(461,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(461,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(462,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(462,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(463,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(463,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(464,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(464,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(465,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(465,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(466,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(466,44) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(467,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(467,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(468,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(468,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(469,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(469,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(470,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(470,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(471,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(471,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(476,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.320
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(457,10)
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(460,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(460,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(461,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(461,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(462,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(462,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(463,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(463,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(464,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(464,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(465,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(465,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(466,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(466,44) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(467,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(467,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(468,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(468,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(469,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(469,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(470,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(470,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(471,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(471,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(476,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.516
         remark #15301: PERMUTED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 24 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 140 
         remark #15477: vector cost: 22.750 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(457,10)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(460,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(460,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(461,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(461,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(462,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(462,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(463,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(463,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(464,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(464,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(465,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(465,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(466,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(466,44) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(467,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(467,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(468,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(468,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(469,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(469,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(470,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(470,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(471,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(471,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(476,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.320
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END

   LOOP BEGIN at grid.f(478,13)
   <Distributed chunk2>
      remark #25444: Loopnest Interchanged: ( 1 2 ) --> ( 2 1 )
      remark #15542: loop was not vectorized: inner loop was already vectorized   [ grid.f(478,13) ]

      LOOP BEGIN at grid.f(457,10)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,3) has unaligned access   [ grid.f(479,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(479,40) ]
         remark #15389: vectorization support: reference ds_(i,j,k+1,3) has unaligned access   [ grid.f(479,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.339
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(457,10)
         remark #15388: vectorization support: reference ds1_(i,j,k,3) has aligned access   [ grid.f(479,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(479,40) ]
         remark #15389: vectorization support: reference ds_(i,j,k+1,3) has unaligned access   [ grid.f(479,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.195
         remark #15301: PERMUTED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(457,10)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,3) has unaligned access   [ grid.f(479,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(479,40) ]
         remark #15389: vectorization support: reference ds_(i,j,k+1,3) has unaligned access   [ grid.f(479,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.339
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

grid.f(1,18):remark #34051: REGISTER ALLOCATION : [grid_] grid.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdx]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: GRID [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (GRID) [15/38=39.5%] grid.f(1,18)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at grid.f(47,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(48,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at grid.f(49,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(53,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(54,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(55,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.600
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 30 
         remark #15477: vector cost: 2.500 
         remark #15478: estimated potential speedup: 10.970 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(49,13)
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(53,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(54,16) ]
         remark #15388: vectorization support: reference z_(i,j,k) has aligned access   [ grid.f(55,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.500
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 30 
         remark #15477: vector cost: 2.500 
         remark #15478: estimated potential speedup: 10.970 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(49,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(53,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(54,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(55,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.600
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 30 
         remark #15477: vector cost: 2.500 
         remark #15478: estimated potential speedup: 10.970 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at grid.f(69,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(70,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at grid.f(71,11)
      <Peeled, Peeled loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(73,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(74,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(75,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(76,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(77,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(78,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(79,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(80,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(81,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(82,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(83,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(84,16) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(85,16) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(86,16) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(87,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(88,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(89,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(90,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(91,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(92,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(93,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(94,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(95,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(96,16) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ grid.f(98,16) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ grid.f(99,16) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ grid.f(100,16) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ grid.f(102,16) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ grid.f(103,16) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ grid.f(104,16) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ grid.f(106,16) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ grid.f(107,16) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ grid.f(108,16) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ grid.f(139,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ grid.f(146,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.258
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(71,11)
      <Peeled>
         remark #25427: Loop Statements Reordered
         remark #25430: Scalar Expansion Performed at line 71   [ grid.f(73,16) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(73,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(74,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(75,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(76,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(77,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(78,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(79,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(80,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(81,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(82,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(83,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(84,16) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(85,16) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(86,16) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(87,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(88,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(89,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(90,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(91,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(92,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(93,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(94,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(95,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(96,16) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ grid.f(98,16) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ grid.f(99,16) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ grid.f(100,16) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ grid.f(102,16) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ grid.f(103,16) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ grid.f(104,16) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ grid.f(106,16) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ grid.f(107,16) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ grid.f(108,16) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ grid.f(139,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ grid.f(146,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.460
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 24 
         remark #15451: unmasked unaligned unit stride stores: 11 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 840 
         remark #15477: vector cost: 116.120 
         remark #15478: estimated potential speedup: 6.700 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(71,11)
      <Peeled, Remainder loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(73,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(74,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(75,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(76,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(77,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(78,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(79,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(80,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(81,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(82,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(83,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(84,16) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(85,16) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(86,16) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(87,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(88,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(89,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(90,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(91,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(92,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(93,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(94,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(95,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(96,16) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ grid.f(98,16) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ grid.f(99,16) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ grid.f(100,16) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ grid.f(102,16) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ grid.f(103,16) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ grid.f(104,16) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ grid.f(106,16) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ grid.f(107,16) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ grid.f(108,16) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ grid.f(139,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ grid.f(146,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.258
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at grid.f(160,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(161,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at grid.f(162,11)
      <Peeled, Peeled loop for vectorization>
         remark #15389: vectorization support: reference x_(i+2,j+1,k) has unaligned access   [ grid.f(164,36) ]
         remark #15389: vectorization support: reference x_(i+2,j,k) has unaligned access   [ grid.f(164,49) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(165,32) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(165,43) ]
         remark #15389: vectorization support: reference x_(i+2,j+1,k+1) has unaligned access   [ grid.f(166,32) ]
         remark #15389: vectorization support: reference x_(i+2,j,k+1) has unaligned access   [ grid.f(166,47) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(167,32) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(167,45) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k) has unaligned access   [ grid.f(168,36) ]
         remark #15389: vectorization support: reference y_(i+2,j,k) has unaligned access   [ grid.f(168,49) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(169,32) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(169,43) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k+1) has unaligned access   [ grid.f(170,32) ]
         remark #15389: vectorization support: reference y_(i+2,j,k+1) has unaligned access   [ grid.f(170,47) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(171,32) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(171,45) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k) has unaligned access   [ grid.f(172,36) ]
         remark #15389: vectorization support: reference z_(i+2,j,k) has unaligned access   [ grid.f(172,49) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(173,32) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(173,43) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k+1) has unaligned access   [ grid.f(174,32) ]
         remark #15389: vectorization support: reference z_(i+2,j,k+1) has unaligned access   [ grid.f(174,47) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(175,32) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(175,45) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(176,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(176,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(177,27) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(177,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(178,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(178,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(179,27) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(179,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(180,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(180,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(181,27) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(181,42) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(182,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(182,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(183,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(183,42) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(184,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(184,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(185,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(185,42) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(186,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(186,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(187,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(187,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,1) has unaligned access   [ grid.f(203,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,1) has unaligned access   [ grid.f(204,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,1) has unaligned access   [ grid.f(205,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,1) has unaligned access   [ grid.f(207,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,1) has unaligned access   [ grid.f(208,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,1) has unaligned access   [ grid.f(209,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,1) has unaligned access   [ grid.f(211,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,1) has unaligned access   [ grid.f(212,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,1) has unaligned access   [ grid.f(213,13) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(215,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(215,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(216,27) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(216,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(217,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(217,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(218,27) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(218,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(219,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(219,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(220,27) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(220,42) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k) has unaligned access   [ grid.f(221,33) ]
         remark #15389: vectorization support: reference x_(i,j+2,k) has unaligned access   [ grid.f(221,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(222,29) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(222,40) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k+1) has unaligned access   [ grid.f(223,29) ]
         remark #15389: vectorization support: reference x_(i,j+2,k+1) has unaligned access   [ grid.f(223,44) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(224,29) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(224,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k) has unaligned access   [ grid.f(225,33) ]
         remark #15389: vectorization support: reference y_(i,j+2,k) has unaligned access   [ grid.f(225,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(226,29) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(226,40) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k+1) has unaligned access   [ grid.f(227,29) ]
         remark #15389: vectorization support: reference y_(i,j+2,k+1) has unaligned access   [ grid.f(227,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(228,29) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(228,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k) has unaligned access   [ grid.f(229,33) ]
         remark #15389: vectorization support: reference z_(i,j+2,k) has unaligned access   [ grid.f(229,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(230,29) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(230,40) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k+1) has unaligned access   [ grid.f(231,29) ]
         remark #15389: vectorization support: reference z_(i,j+2,k+1) has unaligned access   [ grid.f(231,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(232,29) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(232,42) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(233,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(233,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(234,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(234,42) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(235,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(235,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(236,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(236,42) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(237,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(237,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(238,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(238,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ grid.f(256,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ grid.f(257,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ grid.f(258,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ grid.f(260,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ grid.f(261,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ grid.f(262,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ grid.f(264,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ grid.f(265,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ grid.f(266,13) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(268,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(268,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(269,24) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(269,39) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(270,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(270,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(271,24) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(271,39) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(272,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(272,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(273,24) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(273,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(274,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(274,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(275,24) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(275,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(276,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(276,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(277,24) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(277,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(278,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(278,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(279,24) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(279,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+2) has unaligned access   [ grid.f(280,30) ]
         remark #15389: vectorization support: reference x_(i,j,k+2) has unaligned access   [ grid.f(280,43) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(281,26) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(281,37) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+2) has unaligned access   [ grid.f(282,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+2) has unaligned access   [ grid.f(282,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(283,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(283,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+2) has unaligned access   [ grid.f(284,30) ]
         remark #15389: vectorization support: reference y_(i,j,k+2) has unaligned access   [ grid.f(284,43) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(285,26) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(285,37) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+2) has unaligned access   [ grid.f(286,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+2) has unaligned access   [ grid.f(286,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(287,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(287,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+2) has unaligned access   [ grid.f(288,30) ]
         remark #15389: vectorization support: reference z_(i,j,k+2) has unaligned access   [ grid.f(288,43) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(289,26) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(289,37) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+2) has unaligned access   [ grid.f(290,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+2) has unaligned access   [ grid.f(290,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(291,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(291,39) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ grid.f(307,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ grid.f(308,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ grid.f(309,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ grid.f(311,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ grid.f(312,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ grid.f(313,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ grid.f(315,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ grid.f(316,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ grid.f(317,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.323
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(162,11)
      <Peeled>
         remark #25427: Loop Statements Reordered
         remark #25430: Scalar Expansion Performed at line 162   [ grid.f(268,13) ]
         remark #15389: vectorization support: reference x_(i+2,j+1,k) has unaligned access   [ grid.f(164,36) ]
         remark #15389: vectorization support: reference x_(i+2,j,k) has unaligned access   [ grid.f(164,49) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(165,32) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(165,43) ]
         remark #15389: vectorization support: reference x_(i+2,j+1,k+1) has unaligned access   [ grid.f(166,32) ]
         remark #15389: vectorization support: reference x_(i+2,j,k+1) has unaligned access   [ grid.f(166,47) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(167,32) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(167,45) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k) has unaligned access   [ grid.f(168,36) ]
         remark #15389: vectorization support: reference y_(i+2,j,k) has unaligned access   [ grid.f(168,49) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(169,32) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(169,43) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k+1) has unaligned access   [ grid.f(170,32) ]
         remark #15389: vectorization support: reference y_(i+2,j,k+1) has unaligned access   [ grid.f(170,47) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(171,32) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(171,45) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k) has unaligned access   [ grid.f(172,36) ]
         remark #15389: vectorization support: reference z_(i+2,j,k) has unaligned access   [ grid.f(172,49) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(173,32) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(173,43) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k+1) has unaligned access   [ grid.f(174,32) ]
         remark #15389: vectorization support: reference z_(i+2,j,k+1) has unaligned access   [ grid.f(174,47) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(175,32) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(175,45) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(176,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(176,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(177,27) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(177,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(178,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(178,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(179,27) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(179,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(180,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(180,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(181,27) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(181,42) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(182,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(182,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(183,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(183,42) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(184,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(184,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(185,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(185,42) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(186,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(186,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(187,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(187,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,1) has unaligned access   [ grid.f(203,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,1) has unaligned access   [ grid.f(204,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,1) has unaligned access   [ grid.f(205,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,1) has unaligned access   [ grid.f(207,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,1) has unaligned access   [ grid.f(208,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,1) has unaligned access   [ grid.f(209,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,1) has unaligned access   [ grid.f(211,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,1) has unaligned access   [ grid.f(212,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,1) has unaligned access   [ grid.f(213,13) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(215,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(215,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(216,27) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(216,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(217,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(217,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(218,27) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(218,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(219,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(219,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(220,27) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(220,42) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k) has unaligned access   [ grid.f(221,33) ]
         remark #15389: vectorization support: reference x_(i,j+2,k) has unaligned access   [ grid.f(221,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(222,29) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(222,40) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k+1) has unaligned access   [ grid.f(223,29) ]
         remark #15389: vectorization support: reference x_(i,j+2,k+1) has unaligned access   [ grid.f(223,44) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(224,29) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(224,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k) has unaligned access   [ grid.f(225,33) ]
         remark #15389: vectorization support: reference y_(i,j+2,k) has unaligned access   [ grid.f(225,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(226,29) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(226,40) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k+1) has unaligned access   [ grid.f(227,29) ]
         remark #15389: vectorization support: reference y_(i,j+2,k+1) has unaligned access   [ grid.f(227,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(228,29) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(228,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k) has unaligned access   [ grid.f(229,33) ]
         remark #15389: vectorization support: reference z_(i,j+2,k) has unaligned access   [ grid.f(229,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(230,29) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(230,40) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k+1) has unaligned access   [ grid.f(231,29) ]
         remark #15389: vectorization support: reference z_(i,j+2,k+1) has unaligned access   [ grid.f(231,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(232,29) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(232,42) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(233,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(233,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(234,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(234,42) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(235,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(235,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(236,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(236,42) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(237,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(237,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(238,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(238,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ grid.f(256,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ grid.f(257,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ grid.f(258,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ grid.f(260,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ grid.f(261,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ grid.f(262,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ grid.f(264,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ grid.f(265,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ grid.f(266,13) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(268,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(268,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(269,24) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(269,39) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(270,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(270,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(271,24) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(271,39) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(272,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(272,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(273,24) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(273,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(274,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(274,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(275,24) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(275,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(276,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(276,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(277,24) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(277,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(278,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(278,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(279,24) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(279,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+2) has unaligned access   [ grid.f(280,30) ]
         remark #15389: vectorization support: reference x_(i,j,k+2) has unaligned access   [ grid.f(280,43) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(281,26) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(281,37) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+2) has unaligned access   [ grid.f(282,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+2) has unaligned access   [ grid.f(282,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(283,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(283,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+2) has unaligned access   [ grid.f(284,30) ]
         remark #15389: vectorization support: reference y_(i,j,k+2) has unaligned access   [ grid.f(284,43) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(285,26) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(285,37) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+2) has unaligned access   [ grid.f(286,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+2) has unaligned access   [ grid.f(286,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(287,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(287,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+2) has unaligned access   [ grid.f(288,30) ]
         remark #15389: vectorization support: reference z_(i,j,k+2) has unaligned access   [ grid.f(288,43) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(289,26) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(289,37) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+2) has unaligned access   [ grid.f(290,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+2) has unaligned access   [ grid.f(290,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(291,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(291,39) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ grid.f(307,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ grid.f(308,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ grid.f(309,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ grid.f(311,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ grid.f(312,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ grid.f(313,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ grid.f(315,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ grid.f(316,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ grid.f(317,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.398
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 60 
         remark #15451: unmasked unaligned unit stride stores: 27 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 876 
         remark #15477: vector cost: 133.250 
         remark #15478: estimated potential speedup: 6.100 
         remark #15486: divides: 3 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(162,11)
      <Peeled, Remainder loop for vectorization>
         remark #15389: vectorization support: reference x_(i+2,j+1,k) has unaligned access   [ grid.f(164,36) ]
         remark #15389: vectorization support: reference x_(i+2,j,k) has unaligned access   [ grid.f(164,49) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(165,32) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(165,43) ]
         remark #15389: vectorization support: reference x_(i+2,j+1,k+1) has unaligned access   [ grid.f(166,32) ]
         remark #15389: vectorization support: reference x_(i+2,j,k+1) has unaligned access   [ grid.f(166,47) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(167,32) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(167,45) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k) has unaligned access   [ grid.f(168,36) ]
         remark #15389: vectorization support: reference y_(i+2,j,k) has unaligned access   [ grid.f(168,49) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(169,32) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(169,43) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k+1) has unaligned access   [ grid.f(170,32) ]
         remark #15389: vectorization support: reference y_(i+2,j,k+1) has unaligned access   [ grid.f(170,47) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(171,32) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(171,45) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k) has unaligned access   [ grid.f(172,36) ]
         remark #15389: vectorization support: reference z_(i+2,j,k) has unaligned access   [ grid.f(172,49) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(173,32) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(173,43) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k+1) has unaligned access   [ grid.f(174,32) ]
         remark #15389: vectorization support: reference z_(i+2,j,k+1) has unaligned access   [ grid.f(174,47) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(175,32) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(175,45) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(176,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(176,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(177,27) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(177,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(178,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(178,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(179,27) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(179,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(180,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(180,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(181,27) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(181,42) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(182,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(182,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(183,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(183,42) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(184,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(184,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(185,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(185,42) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(186,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(186,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(187,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(187,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,1) has unaligned access   [ grid.f(203,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,1) has unaligned access   [ grid.f(204,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,1) has unaligned access   [ grid.f(205,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,1) has unaligned access   [ grid.f(207,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,1) has unaligned access   [ grid.f(208,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,1) has unaligned access   [ grid.f(209,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,1) has unaligned access   [ grid.f(211,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,1) has unaligned access   [ grid.f(212,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,1) has unaligned access   [ grid.f(213,13) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(215,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(215,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(216,27) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(216,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(217,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(217,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(218,27) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(218,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(219,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(219,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(220,27) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(220,42) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k) has unaligned access   [ grid.f(221,33) ]
         remark #15389: vectorization support: reference x_(i,j+2,k) has unaligned access   [ grid.f(221,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(222,29) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(222,40) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k+1) has unaligned access   [ grid.f(223,29) ]
         remark #15389: vectorization support: reference x_(i,j+2,k+1) has unaligned access   [ grid.f(223,44) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(224,29) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(224,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k) has unaligned access   [ grid.f(225,33) ]
         remark #15389: vectorization support: reference y_(i,j+2,k) has unaligned access   [ grid.f(225,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(226,29) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(226,40) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k+1) has unaligned access   [ grid.f(227,29) ]
         remark #15389: vectorization support: reference y_(i,j+2,k+1) has unaligned access   [ grid.f(227,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(228,29) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(228,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k) has unaligned access   [ grid.f(229,33) ]
         remark #15389: vectorization support: reference z_(i,j+2,k) has unaligned access   [ grid.f(229,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(230,29) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(230,40) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k+1) has unaligned access   [ grid.f(231,29) ]
         remark #15389: vectorization support: reference z_(i,j+2,k+1) has unaligned access   [ grid.f(231,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(232,29) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(232,42) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(233,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(233,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(234,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(234,42) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(235,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(235,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(236,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(236,42) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(237,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(237,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(238,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(238,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ grid.f(256,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ grid.f(257,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ grid.f(258,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ grid.f(260,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ grid.f(261,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ grid.f(262,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ grid.f(264,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ grid.f(265,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ grid.f(266,13) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(268,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(268,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(269,24) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(269,39) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(270,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(270,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(271,24) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(271,39) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(272,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(272,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(273,24) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(273,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(274,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(274,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(275,24) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(275,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(276,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(276,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(277,24) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(277,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(278,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(278,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(279,24) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(279,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+2) has unaligned access   [ grid.f(280,30) ]
         remark #15389: vectorization support: reference x_(i,j,k+2) has unaligned access   [ grid.f(280,43) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(281,26) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(281,37) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+2) has unaligned access   [ grid.f(282,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+2) has unaligned access   [ grid.f(282,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(283,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(283,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+2) has unaligned access   [ grid.f(284,30) ]
         remark #15389: vectorization support: reference y_(i,j,k+2) has unaligned access   [ grid.f(284,43) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(285,26) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(285,37) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+2) has unaligned access   [ grid.f(286,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+2) has unaligned access   [ grid.f(286,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(287,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(287,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+2) has unaligned access   [ grid.f(288,30) ]
         remark #15389: vectorization support: reference z_(i,j,k+2) has unaligned access   [ grid.f(288,43) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(289,26) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(289,37) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+2) has unaligned access   [ grid.f(290,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+2) has unaligned access   [ grid.f(290,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(291,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(291,39) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ grid.f(307,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ grid.f(308,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ grid.f(309,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ grid.f(311,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ grid.f(312,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ grid.f(313,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ grid.f(315,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ grid.f(316,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ grid.f(317,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.323
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at grid.f(400,7)
   remark #25045: Fused Loops: ( 400 428 )

   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(401,10)
   <Peeled>
      remark #25045: Fused Loops: ( 401 430 )

      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at grid.f(402,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(404,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(404,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(405,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(405,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(406,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(406,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(407,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(407,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(408,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(408,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(409,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(409,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(410,33) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(410,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(411,29) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(411,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(412,33) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(412,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(413,29) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(413,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(414,33) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(414,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(415,29) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(415,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(420,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.320
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(402,13)
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(404,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(404,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(405,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(405,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(406,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(406,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(407,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(407,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(408,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(408,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(409,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(409,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(410,33) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(410,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(411,29) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(411,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(412,33) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(412,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(413,29) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(413,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(414,33) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(414,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(415,29) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(415,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(420,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.516
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 24 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 140 
         remark #15477: vector cost: 22.750 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(402,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(404,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(404,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(405,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(405,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(406,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(406,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(407,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(407,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(408,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(408,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(409,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(409,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(410,33) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(410,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(411,29) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(411,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(412,33) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(412,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(413,29) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(413,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(414,33) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(414,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(415,29) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(415,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(420,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.320
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(422,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ grid.f(423,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(423,40) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ grid.f(423,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.339
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(422,13)
         remark #15388: vectorization support: reference ds1_(i,j,k,1) has aligned access   [ grid.f(423,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(423,40) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ grid.f(423,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.195
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(422,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ grid.f(423,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(423,40) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ grid.f(423,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.339
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(429,10)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(432,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(432,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(433,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(433,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(434,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(434,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(435,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(435,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(436,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(436,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(437,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(437,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(438,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(438,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(439,29) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(439,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(440,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(440,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(441,29) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(441,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(442,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(442,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(443,29) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(443,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(448,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.320
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(429,10)
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(432,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(432,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(433,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(433,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(434,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(434,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(435,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(435,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(436,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(436,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(437,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(437,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(438,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(438,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(439,29) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(439,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(440,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(440,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(441,29) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(441,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(442,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(442,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(443,29) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(443,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(448,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.516
         remark #15301: PERMUTED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 24 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 140 
         remark #15477: vector cost: 22.750 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(429,10)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(432,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(432,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(433,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(433,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(434,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(434,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(435,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(435,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(436,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(436,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(437,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(437,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(438,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(438,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(439,29) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(439,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(440,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(440,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(441,29) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(441,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(442,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(442,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(443,29) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(443,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(448,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.320
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END

   LOOP BEGIN at grid.f(429,10)
   <Distributed chunk1>
      remark #25426: Loop Distributed (2 way) 
      remark #25444: Loopnest Interchanged: ( 1 2 ) --> ( 2 1 )
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at grid.f(450,13)
   <Distributed chunk2>
      remark #25444: Loopnest Interchanged: ( 1 2 ) --> ( 2 1 )
      remark #15542: loop was not vectorized: inner loop was already vectorized   [ grid.f(450,13) ]

      LOOP BEGIN at grid.f(429,10)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,2) has unaligned access   [ grid.f(451,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(451,40) ]
         remark #15389: vectorization support: reference ds_(i,j+1,k,2) has unaligned access   [ grid.f(451,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.339
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(429,10)
         remark #15388: vectorization support: reference ds1_(i,j,k,2) has aligned access   [ grid.f(451,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(451,40) ]
         remark #15389: vectorization support: reference ds_(i,j+1,k,2) has unaligned access   [ grid.f(451,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.195
         remark #15301: PERMUTED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(429,10)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,2) has unaligned access   [ grid.f(451,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(451,40) ]
         remark #15389: vectorization support: reference ds_(i,j+1,k,2) has unaligned access   [ grid.f(451,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.339
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at grid.f(428,7)
   remark #25046: Loop lost in Fusion 
LOOP END

LOOP BEGIN at grid.f(456,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(458,13)
   <Distributed chunk1>
      remark #25426: Loop Distributed (2 way) 
      remark #25444: Loopnest Interchanged: ( 1 2 ) --> ( 2 1 )
      remark #15542: loop was not vectorized: inner loop was already vectorized   [ grid.f(458,13) ]

      LOOP BEGIN at grid.f(457,10)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(460,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(460,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(461,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(461,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(462,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(462,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(463,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(463,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(464,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(464,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(465,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(465,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(466,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(466,44) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(467,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(467,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(468,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(468,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(469,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(469,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(470,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(470,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(471,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(471,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(476,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.320
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(457,10)
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(460,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(460,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(461,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(461,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(462,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(462,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(463,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(463,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(464,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(464,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(465,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(465,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(466,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(466,44) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(467,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(467,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(468,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(468,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(469,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(469,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(470,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(470,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(471,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(471,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(476,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.516
         remark #15301: PERMUTED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 24 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 140 
         remark #15477: vector cost: 22.750 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(457,10)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(460,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(460,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(461,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(461,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(462,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(462,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(463,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(463,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(464,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(464,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(465,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(465,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(466,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(466,44) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(467,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(467,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(468,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(468,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(469,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(469,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(470,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(470,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(471,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(471,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(476,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.320
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END

   LOOP BEGIN at grid.f(478,13)
   <Distributed chunk2>
      remark #25444: Loopnest Interchanged: ( 1 2 ) --> ( 2 1 )
      remark #15542: loop was not vectorized: inner loop was already vectorized   [ grid.f(478,13) ]

      LOOP BEGIN at grid.f(457,10)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,3) has unaligned access   [ grid.f(479,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(479,40) ]
         remark #15389: vectorization support: reference ds_(i,j,k+1,3) has unaligned access   [ grid.f(479,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.339
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(457,10)
         remark #15388: vectorization support: reference ds1_(i,j,k,3) has aligned access   [ grid.f(479,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(479,40) ]
         remark #15389: vectorization support: reference ds_(i,j,k+1,3) has unaligned access   [ grid.f(479,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.195
         remark #15301: PERMUTED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(457,10)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,3) has unaligned access   [ grid.f(479,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(479,40) ]
         remark #15389: vectorization support: reference ds_(i,j,k+1,3) has unaligned access   [ grid.f(479,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.339
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 5.120 
         remark #15478: estimated potential speedup: 5.790 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

grid.f(73,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(73,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(73,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(73,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(74,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(74,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(74,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(74,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(75,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(75,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(75,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(75,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(76,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(76,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(76,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(76,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(77,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(77,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(77,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(77,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(78,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(78,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(78,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(78,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(85,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(85,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(85,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(85,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(86,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(86,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(86,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(86,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(87,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(87,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(87,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(87,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(88,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(88,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(88,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(88,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(89,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(89,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(89,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(89,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(90,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(90,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(90,16):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(90,16):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(164,36):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(164,36):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(164,36):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(164,36):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(164,49):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(164,49):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(164,49):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(164,49):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(166,32):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(166,32):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(166,32):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(166,32):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(166,47):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(166,47):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(166,47):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(166,47):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(168,36):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(168,36):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(168,36):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(168,36):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(168,49):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(168,49):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(168,49):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(168,49):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(170,32):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(170,32):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(170,32):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(170,32):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(170,47):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(170,47):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(170,47):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(170,47):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(172,36):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(172,36):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(172,36):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(172,36):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(172,49):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(172,49):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(172,49):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(172,49):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(174,32):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(174,32):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(174,32):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(174,32):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(174,47):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(174,47):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(174,47):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(174,47):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(221,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(221,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(221,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(221,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(223,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(223,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(223,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(223,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(225,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(225,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(225,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(225,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(227,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(227,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(227,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(227,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(229,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(229,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(229,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(229,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(231,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(231,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(231,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(231,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(280,30):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(280,30):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(280,30):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(280,30):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(280,43):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(280,43):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(280,43):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(280,43):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(284,30):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(284,30):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(284,30):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(284,30):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(284,43):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(284,43):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(284,43):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(284,43):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(288,30):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(288,30):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(288,30):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(288,30):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(288,43):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(288,43):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(288,43):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(288,43):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(404,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(404,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(404,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(404,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(404,46):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(404,46):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(404,46):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(404,46):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(405,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(405,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(405,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(405,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(405,44):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(405,44):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(405,44):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(405,44):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(406,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(406,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(406,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(406,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(406,46):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(406,46):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(406,46):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(406,46):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(407,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(407,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(407,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(407,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(407,44):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(407,44):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(407,44):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(407,44):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(408,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(408,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(408,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(408,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(408,46):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(408,46):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(408,46):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(408,46):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(409,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(409,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(409,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(409,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(409,44):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(409,44):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(409,44):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(409,44):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(423,40):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(423,40):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(423,40):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(423,40):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(423,40):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(423,40):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(423,40):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(423,40):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(432,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(432,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(432,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(432,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(433,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(433,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(433,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(433,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(434,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(434,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(434,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(434,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(435,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(435,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(435,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(435,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(436,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(436,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(436,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(436,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(437,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(437,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(437,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(437,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(438,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(438,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(438,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(438,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(439,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(439,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(439,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(439,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(440,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(440,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(440,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(440,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(441,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(441,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(441,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(441,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(442,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(442,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(442,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(442,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(443,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(443,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(443,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(443,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(460,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(460,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(460,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(460,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(461,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(461,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(461,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(461,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(462,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(462,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(462,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(462,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(463,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(463,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(463,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(463,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(464,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(464,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(464,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(464,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(465,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(465,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(465,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(465,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(466,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(466,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(466,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(466,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(467,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(467,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(467,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(467,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(468,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(468,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(468,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(468,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(469,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(469,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(469,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(469,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(470,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(470,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(470,33):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(470,33):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(471,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(471,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(471,29):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(471,29):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(73,16):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(74,16):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(75,16):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(76,16):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(77,16):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(78,16):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(85,16):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(86,16):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(87,16):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(88,16):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(89,16):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(90,16):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(164,36):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000007 }.
grid.f(164,49):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000007 }.
grid.f(166,32):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000007 }.
grid.f(166,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000007 }.
grid.f(168,36):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000007 }.
grid.f(168,49):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000007 }.
grid.f(170,32):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000007 }.
grid.f(170,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000007 }.
grid.f(172,36):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000007 }.
grid.f(172,49):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000007 }.
grid.f(174,32):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000007 }.
grid.f(174,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000007 }.
grid.f(221,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(223,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(225,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(227,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(229,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(231,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(280,30):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(280,43):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(284,30):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(284,43):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(288,30):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(288,43):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(404,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(404,46):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(405,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(405,44):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(406,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(406,46):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(407,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(407,44):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(408,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(408,46):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(409,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(409,44):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(423,40):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(423,40):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(432,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(433,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(434,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(435,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(436,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(437,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(438,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(439,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(440,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(441,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(442,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(443,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(460,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(461,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(462,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(463,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(464,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(465,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(466,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(467,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(468,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(469,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(470,33):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(471,29):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V512, F64-V512 }, number of elements { 8 }, select mask { 0x000000003 }.
grid.f(1,18):remark #34051: REGISTER ALLOCATION : [grid_.h] grid.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   53[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm31 k1-k7]
        
    Routine temporaries
        Total         :    5048
            Global    :    1412
            Local     :    3636
        Regenerable   :      58
        Spilled       :     991
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :   14408 bytes*
            Reads     :    1391 [5.79e+04 ~ 9.3%]
            Writes    :    1062 [2.38e+04 ~ 3.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: GRID [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (GRID) [15/38=39.5%] grid.f(1,18)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at grid.f(47,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(48,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at grid.f(49,13)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at grid.f(49,13)
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(53,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(54,16) ]
         remark #15388: vectorization support: reference z_(i,j,k) has aligned access   [ grid.f(55,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.278
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 30 
         remark #15477: vector cost: 4.500 
         remark #15478: estimated potential speedup: 5.360 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(49,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(53,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(54,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(55,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.150
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 30 
         remark #15477: vector cost: 4.500 
         remark #15478: estimated potential speedup: 5.360 
         remark #15487: type converts: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(49,13)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at grid.f(69,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(70,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at grid.f(71,11)
      <Peeled, Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at grid.f(71,11)
      <Peeled>
         remark #25427: Loop Statements Reordered
         remark #25430: Scalar Expansion Performed at line 71   [ grid.f(73,16) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(73,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(74,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(75,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(76,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(77,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(78,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(79,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(80,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(81,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(82,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(83,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(84,16) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(85,16) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(86,16) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(87,16) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(88,16) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(89,16) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(90,16) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(91,16) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(92,16) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(93,16) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(94,16) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(95,16) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(96,16) ]
         remark #15389: vectorization support: reference six_(i,j,k) has unaligned access   [ grid.f(98,16) ]
         remark #15389: vectorization support: reference siy_(i,j,k) has unaligned access   [ grid.f(99,16) ]
         remark #15389: vectorization support: reference siz_(i,j,k) has unaligned access   [ grid.f(100,16) ]
         remark #15389: vectorization support: reference sjx_(i,j,k) has unaligned access   [ grid.f(102,16) ]
         remark #15389: vectorization support: reference sjy_(i,j,k) has unaligned access   [ grid.f(103,16) ]
         remark #15389: vectorization support: reference sjz_(i,j,k) has unaligned access   [ grid.f(104,16) ]
         remark #15389: vectorization support: reference skx_(i,j,k) has unaligned access   [ grid.f(106,16) ]
         remark #15389: vectorization support: reference sky_(i,j,k) has unaligned access   [ grid.f(107,16) ]
         remark #15389: vectorization support: reference skz_(i,j,k) has unaligned access   [ grid.f(108,16) ]
         remark #15389: vectorization support: reference sijksq_(i,j,k) has unaligned access   [ grid.f(139,16) ]
         remark #15389: vectorization support: reference vol_(i,j,k) has unaligned access   [ grid.f(146,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.416
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 24 
         remark #15451: unmasked unaligned unit stride stores: 11 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 840 
         remark #15477: vector cost: 256.750 
         remark #15478: estimated potential speedup: 3.150 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(71,11)
      <Peeled, Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at grid.f(160,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(161,9)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at grid.f(162,11)
      <Peeled, Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at grid.f(162,11)
      <Peeled>
         remark #25427: Loop Statements Reordered
         remark #25430: Scalar Expansion Performed at line 162   [ grid.f(268,13) ]
         remark #15389: vectorization support: reference x_(i+2,j+1,k) has unaligned access   [ grid.f(164,36) ]
         remark #15389: vectorization support: reference x_(i+2,j,k) has unaligned access   [ grid.f(164,49) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(165,32) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(165,43) ]
         remark #15389: vectorization support: reference x_(i+2,j+1,k+1) has unaligned access   [ grid.f(166,32) ]
         remark #15389: vectorization support: reference x_(i+2,j,k+1) has unaligned access   [ grid.f(166,47) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(167,32) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(167,45) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k) has unaligned access   [ grid.f(168,36) ]
         remark #15389: vectorization support: reference y_(i+2,j,k) has unaligned access   [ grid.f(168,49) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(169,32) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(169,43) ]
         remark #15389: vectorization support: reference y_(i+2,j+1,k+1) has unaligned access   [ grid.f(170,32) ]
         remark #15389: vectorization support: reference y_(i+2,j,k+1) has unaligned access   [ grid.f(170,47) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(171,32) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(171,45) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k) has unaligned access   [ grid.f(172,36) ]
         remark #15389: vectorization support: reference z_(i+2,j,k) has unaligned access   [ grid.f(172,49) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(173,32) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(173,43) ]
         remark #15389: vectorization support: reference z_(i+2,j+1,k+1) has unaligned access   [ grid.f(174,32) ]
         remark #15389: vectorization support: reference z_(i+2,j,k+1) has unaligned access   [ grid.f(174,47) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(175,32) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(175,45) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(176,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(176,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(177,27) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(177,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(178,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(178,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(179,27) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(179,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(180,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(180,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(181,27) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(181,42) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(182,31) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(182,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(183,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(183,42) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(184,31) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(184,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(185,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(185,42) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(186,31) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(186,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(187,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(187,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,1) has unaligned access   [ grid.f(203,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,1) has unaligned access   [ grid.f(204,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,1) has unaligned access   [ grid.f(205,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,1) has unaligned access   [ grid.f(207,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,1) has unaligned access   [ grid.f(208,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,1) has unaligned access   [ grid.f(209,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,1) has unaligned access   [ grid.f(211,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,1) has unaligned access   [ grid.f(212,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,1) has unaligned access   [ grid.f(213,13) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(215,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(215,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(216,27) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(216,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(217,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(217,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(218,27) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(218,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(219,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(219,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(220,27) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(220,42) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k) has unaligned access   [ grid.f(221,33) ]
         remark #15389: vectorization support: reference x_(i,j+2,k) has unaligned access   [ grid.f(221,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(222,29) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(222,40) ]
         remark #15389: vectorization support: reference x_(i+1,j+2,k+1) has unaligned access   [ grid.f(223,29) ]
         remark #15389: vectorization support: reference x_(i,j+2,k+1) has unaligned access   [ grid.f(223,44) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(224,29) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(224,42) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k) has unaligned access   [ grid.f(225,33) ]
         remark #15389: vectorization support: reference y_(i,j+2,k) has unaligned access   [ grid.f(225,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(226,29) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(226,40) ]
         remark #15389: vectorization support: reference y_(i+1,j+2,k+1) has unaligned access   [ grid.f(227,29) ]
         remark #15389: vectorization support: reference y_(i,j+2,k+1) has unaligned access   [ grid.f(227,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(228,29) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(228,42) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k) has unaligned access   [ grid.f(229,33) ]
         remark #15389: vectorization support: reference z_(i,j+2,k) has unaligned access   [ grid.f(229,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(230,29) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(230,40) ]
         remark #15389: vectorization support: reference z_(i+1,j+2,k+1) has unaligned access   [ grid.f(231,29) ]
         remark #15389: vectorization support: reference z_(i,j+2,k+1) has unaligned access   [ grid.f(231,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(232,29) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(232,42) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(233,31) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(233,44) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(234,27) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(234,42) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(235,31) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(235,44) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(236,27) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(236,42) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(237,31) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(237,44) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(238,27) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(238,42) ]
         remark #15389: vectorization support: reference t11_(i,j,k,2) has unaligned access   [ grid.f(256,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,2) has unaligned access   [ grid.f(257,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,2) has unaligned access   [ grid.f(258,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,2) has unaligned access   [ grid.f(260,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,2) has unaligned access   [ grid.f(261,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,2) has unaligned access   [ grid.f(262,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,2) has unaligned access   [ grid.f(264,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,2) has unaligned access   [ grid.f(265,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,2) has unaligned access   [ grid.f(266,13) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(268,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(268,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(269,24) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(269,39) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(270,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(270,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(271,24) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(271,39) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(272,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(272,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(273,24) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(273,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(274,28) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(274,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(275,24) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(275,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(276,28) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(276,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(277,24) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(277,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(278,28) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(278,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(279,24) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(279,39) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+2) has unaligned access   [ grid.f(280,30) ]
         remark #15389: vectorization support: reference x_(i,j,k+2) has unaligned access   [ grid.f(280,43) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(281,26) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(281,37) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+2) has unaligned access   [ grid.f(282,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+2) has unaligned access   [ grid.f(282,41) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(283,26) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(283,39) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+2) has unaligned access   [ grid.f(284,30) ]
         remark #15389: vectorization support: reference y_(i,j,k+2) has unaligned access   [ grid.f(284,43) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(285,26) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(285,37) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+2) has unaligned access   [ grid.f(286,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+2) has unaligned access   [ grid.f(286,41) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(287,26) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(287,39) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+2) has unaligned access   [ grid.f(288,30) ]
         remark #15389: vectorization support: reference z_(i,j,k+2) has unaligned access   [ grid.f(288,43) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(289,26) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(289,37) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+2) has unaligned access   [ grid.f(290,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+2) has unaligned access   [ grid.f(290,41) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(291,26) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(291,39) ]
         remark #15389: vectorization support: reference t11_(i,j,k,3) has unaligned access   [ grid.f(307,13) ]
         remark #15389: vectorization support: reference t12_(i,j,k,3) has unaligned access   [ grid.f(308,13) ]
         remark #15389: vectorization support: reference t13_(i,j,k,3) has unaligned access   [ grid.f(309,13) ]
         remark #15389: vectorization support: reference t21_(i,j,k,3) has unaligned access   [ grid.f(311,13) ]
         remark #15389: vectorization support: reference t22_(i,j,k,3) has unaligned access   [ grid.f(312,13) ]
         remark #15389: vectorization support: reference t23_(i,j,k,3) has unaligned access   [ grid.f(313,13) ]
         remark #15389: vectorization support: reference t31_(i,j,k,3) has unaligned access   [ grid.f(315,13) ]
         remark #15389: vectorization support: reference t32_(i,j,k,3) has unaligned access   [ grid.f(316,13) ]
         remark #15389: vectorization support: reference t33_(i,j,k,3) has unaligned access   [ grid.f(317,13) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.373
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 60 
         remark #15451: unmasked unaligned unit stride stores: 27 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 876 
         remark #15477: vector cost: 284.000 
         remark #15478: estimated potential speedup: 2.980 
         remark #15486: divides: 3 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(162,11)
      <Peeled, Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at grid.f(400,7)
   remark #25045: Fused Loops: ( 400 428 )

   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(401,10)
   <Peeled>
      remark #25045: Fused Loops: ( 401 430 )

      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at grid.f(402,13)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at grid.f(402,13)
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(404,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(404,46) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(405,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(405,44) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(406,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(406,46) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(407,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(407,44) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(408,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(408,46) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(409,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(409,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(410,33) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(410,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(411,29) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(411,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(412,33) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(412,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(413,29) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(413,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(414,33) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(414,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(415,29) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(415,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(420,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.595
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 24 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 140 
         remark #15477: vector cost: 39.500 
         remark #15478: estimated potential speedup: 3.400 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(402,13)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at grid.f(422,13)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at grid.f(422,13)
         remark #15388: vectorization support: reference ds1_(i,j,k,1) has aligned access   [ grid.f(423,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(423,40) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ grid.f(423,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.103
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 9.750 
         remark #15478: estimated potential speedup: 2.990 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(422,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,1) has unaligned access   [ grid.f(423,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,1) has unaligned access   [ grid.f(423,40) ]
         remark #15389: vectorization support: reference ds_(i+1,j,k,1) has unaligned access   [ grid.f(423,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.463
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 9.750 
         remark #15478: estimated potential speedup: 2.990 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(422,13)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at grid.f(429,10)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at grid.f(429,10)
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(432,33) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(432,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(433,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(433,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(434,33) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(434,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(435,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(435,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(436,33) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(436,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(437,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(437,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(438,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(438,44) ]
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(439,29) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(439,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(440,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(440,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(441,29) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(441,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(442,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(442,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(443,29) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(443,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(448,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.595
         remark #15301: PERMUTED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 24 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 140 
         remark #15477: vector cost: 39.500 
         remark #15478: estimated potential speedup: 3.400 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(429,10)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END

   LOOP BEGIN at grid.f(429,10)
   <Distributed chunk1>
      remark #25426: Loop Distributed (2 way) 
      remark #25444: Loopnest Interchanged: ( 1 2 ) --> ( 2 1 )
      remark #25046: Loop lost in Fusion 
   LOOP END

   LOOP BEGIN at grid.f(450,13)
   <Distributed chunk2>
      remark #25444: Loopnest Interchanged: ( 1 2 ) --> ( 2 1 )
      remark #15542: loop was not vectorized: inner loop was already vectorized   [ grid.f(450,13) ]

      LOOP BEGIN at grid.f(429,10)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at grid.f(429,10)
         remark #15388: vectorization support: reference ds1_(i,j,k,2) has aligned access   [ grid.f(451,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(451,40) ]
         remark #15389: vectorization support: reference ds_(i,j+1,k,2) has unaligned access   [ grid.f(451,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.103
         remark #15301: PERMUTED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 9.750 
         remark #15478: estimated potential speedup: 2.990 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(429,10)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,2) has unaligned access   [ grid.f(451,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,2) has unaligned access   [ grid.f(451,40) ]
         remark #15389: vectorization support: reference ds_(i,j+1,k,2) has unaligned access   [ grid.f(451,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.463
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 9.750 
         remark #15478: estimated potential speedup: 2.990 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(429,10)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at grid.f(428,7)
   remark #25046: Loop lost in Fusion 
LOOP END

LOOP BEGIN at grid.f(456,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at grid.f(458,13)
   <Distributed chunk1>
      remark #25426: Loop Distributed (2 way) 
      remark #25444: Loopnest Interchanged: ( 1 2 ) --> ( 2 1 )
      remark #15542: loop was not vectorized: inner loop was already vectorized   [ grid.f(458,13) ]

      LOOP BEGIN at grid.f(457,10)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at grid.f(457,10)
         remark #15389: vectorization support: reference x_(i,j,k+1) has unaligned access   [ grid.f(460,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k+1) has unaligned access   [ grid.f(460,46) ]
         remark #15389: vectorization support: reference x_(i,j+1,k+1) has unaligned access   [ grid.f(461,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k+1) has unaligned access   [ grid.f(461,44) ]
         remark #15389: vectorization support: reference y_(i,j,k+1) has unaligned access   [ grid.f(462,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k+1) has unaligned access   [ grid.f(462,46) ]
         remark #15389: vectorization support: reference y_(i,j+1,k+1) has unaligned access   [ grid.f(463,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k+1) has unaligned access   [ grid.f(463,44) ]
         remark #15389: vectorization support: reference z_(i,j,k+1) has unaligned access   [ grid.f(464,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k+1) has unaligned access   [ grid.f(464,46) ]
         remark #15389: vectorization support: reference z_(i,j+1,k+1) has unaligned access   [ grid.f(465,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k+1) has unaligned access   [ grid.f(465,44) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ grid.f(466,33) ]
         remark #15389: vectorization support: reference x_(i+1,j,k) has unaligned access   [ grid.f(466,44) ]
         remark #15389: vectorization support: reference x_(i,j+1,k) has unaligned access   [ grid.f(467,29) ]
         remark #15389: vectorization support: reference x_(i+1,j+1,k) has unaligned access   [ grid.f(467,42) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ grid.f(468,33) ]
         remark #15389: vectorization support: reference y_(i+1,j,k) has unaligned access   [ grid.f(468,44) ]
         remark #15389: vectorization support: reference y_(i,j+1,k) has unaligned access   [ grid.f(469,29) ]
         remark #15389: vectorization support: reference y_(i+1,j+1,k) has unaligned access   [ grid.f(469,42) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ grid.f(470,33) ]
         remark #15389: vectorization support: reference z_(i+1,j,k) has unaligned access   [ grid.f(470,44) ]
         remark #15389: vectorization support: reference z_(i,j+1,k) has unaligned access   [ grid.f(471,29) ]
         remark #15389: vectorization support: reference z_(i+1,j+1,k) has unaligned access   [ grid.f(471,42) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(476,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.595
         remark #15301: PERMUTED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 24 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 140 
         remark #15477: vector cost: 39.500 
         remark #15478: estimated potential speedup: 3.400 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(457,10)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END

   LOOP BEGIN at grid.f(478,13)
   <Distributed chunk2>
      remark #25444: Loopnest Interchanged: ( 1 2 ) --> ( 2 1 )
      remark #15542: loop was not vectorized: inner loop was already vectorized   [ grid.f(478,13) ]

      LOOP BEGIN at grid.f(457,10)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at grid.f(457,10)
         remark #15388: vectorization support: reference ds1_(i,j,k,3) has aligned access   [ grid.f(479,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(479,40) ]
         remark #15389: vectorization support: reference ds_(i,j,k+1,3) has unaligned access   [ grid.f(479,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.103
         remark #15301: PERMUTED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 9.750 
         remark #15478: estimated potential speedup: 2.990 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(457,10)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference ds1_(i,j,k,3) has unaligned access   [ grid.f(479,16) ]
         remark #15389: vectorization support: reference ds_(i,j,k,3) has unaligned access   [ grid.f(479,40) ]
         remark #15389: vectorization support: reference ds_(i,j,k+1,3) has unaligned access   [ grid.f(479,52) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.463
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 32 
         remark #15477: vector cost: 9.750 
         remark #15478: estimated potential speedup: 2.990 
         remark #15486: divides: 1 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at grid.f(457,10)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

grid.f(164,36):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(164,36):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(164,36):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V256, F64-V256, F64-V256 }, number of elements { 4 }, select mask { 0x000000007 }.
grid.f(164,49):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(164,49):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(164,49):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V256, F64-V256, F64-V256 }, number of elements { 4 }, select mask { 0x000000007 }.
grid.f(166,32):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(166,32):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(166,32):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V256, F64-V256, F64-V256 }, number of elements { 4 }, select mask { 0x000000007 }.
grid.f(166,47):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(166,47):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(166,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V256, F64-V256, F64-V256 }, number of elements { 4 }, select mask { 0x000000007 }.
grid.f(168,36):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(168,36):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(168,36):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V256, F64-V256, F64-V256 }, number of elements { 4 }, select mask { 0x000000007 }.
grid.f(168,49):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(168,49):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(168,49):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V256, F64-V256, F64-V256 }, number of elements { 4 }, select mask { 0x000000007 }.
grid.f(170,32):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(170,32):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(170,32):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V256, F64-V256, F64-V256 }, number of elements { 4 }, select mask { 0x000000007 }.
grid.f(170,47):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(170,47):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(170,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V256, F64-V256, F64-V256 }, number of elements { 4 }, select mask { 0x000000007 }.
grid.f(172,36):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(172,36):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(172,36):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V256, F64-V256, F64-V256 }, number of elements { 4 }, select mask { 0x000000007 }.
grid.f(172,49):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(172,49):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(172,49):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V256, F64-V256, F64-V256 }, number of elements { 4 }, select mask { 0x000000007 }.
grid.f(174,32):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(174,32):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(174,32):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V256, F64-V256, F64-V256 }, number of elements { 4 }, select mask { 0x000000007 }.
grid.f(174,47):remark #34060: alignment of adjacent dense (unit-strided stencil) loads is (alignment, offset): (1, 0)
grid.f(174,47):remark #34050: adjacent dense (unit-strided stencil) loads seem unprofitable to optimize.
grid.f(174,47):remark #34055: adjacent dense (unit-strided stencil) loads are not optimized. Details: stride { 8 }, step { 8 }, types { F64-V256, F64-V256, F64-V256 }, number of elements { 4 }, select mask { 0x000000007 }.
grid.f(1,18):remark #34051: REGISTER ALLOCATION : [grid_.A] grid.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :    3167
            Global    :     781
            Local     :    2386
        Regenerable   :      19
        Spilled       :     681
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :    6720 bytes*
            Reads     :    1302 [5.67e+04 ~ 15.3%]
            Writes    :     836 [2.28e+04 ~ 6.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: TML

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (TML) [16/38=42.1%] setiv.f(145,18)
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (180,21) for_write_seq_lis_xmit
  -> EXTERN: (180,21) for_write_seq_lis
  -> EXTERN: (229,16) exp
  -> EXTERN: (234,26) exp
  -> EXTERN: (235,26) exp
  -> EXTERN: (236,26) cos
  -> EXTERN: (237,26) sin
  -> EXTERN: (238,26) cos
  -> EXTERN: (239,26) sin
  -> EXTERN: (241,28) cos
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at setiv.f(180,21)
   remark #15388: vectorization support: reference at (180:38) has aligned access   [ setiv.f(180,38) ]
   remark #15388: vectorization support: reference EPS(:) has aligned access
   remark #15305: vectorization support: vector length 2
   remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ setiv.f(180,38) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 2.000 
   remark #15478: estimated potential speedup: 1.660 
   remark #15487: type converts: 1 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at setiv.f(180,21)
<Remainder loop for vectorization>
   remark #15442: entire loop may be executed in remainder
   remark #15450: unmasked unaligned unit stride loads: 12 
   remark #15451: unmasked unaligned unit stride stores: 3 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 172 
   remark #15477: vector cost: 23.620 
   remark #15478: estimated potential speedup: 6.730 
   remark #15488: --- end vector cost summary ---
   remark #25436: completely unrolled by 1  
LOOP END

LOOP BEGIN at setiv.f(225,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between AEX(l) (234:13) and AEX(l) (245:13)
   remark #15346: vector dependence: assumed ANTI dependence between AEX(l) (245:13) and AEX(l) (234:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 57

   LOOP BEGIN at setiv.f(233,10)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ setiv.f(241,13) ]
      remark #25436: completely unrolled by 3   (pre-vector) 
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(257,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 3 ) --> ( 2 3 1 ) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(258,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(259,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(264,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(265,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(266,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(267,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(268,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(269,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(270,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(272,16) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(273,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(274,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(275,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(276,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(277,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(278,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(280,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.373
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 172 
         remark #15477: vector cost: 23.620 
         remark #15478: estimated potential speedup: 6.730 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(259,13)
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(264,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(265,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(266,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(267,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(268,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(269,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(270,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(272,16) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(273,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(274,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(275,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(276,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(277,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(278,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(280,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.602
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 86 
         remark #15477: vector cost: 12.250 
         remark #15478: estimated potential speedup: 6.480 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(259,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(264,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(265,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(266,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(267,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(268,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(269,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(270,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(272,16) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(273,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(274,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(275,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(276,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(277,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(278,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(280,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.373
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 172 
         remark #15477: vector cost: 23.620 
         remark #15478: estimated potential speedup: 6.730 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(288,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 3 ) --> ( 2 3 1 ) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(290,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(292,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(327,16) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(299,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(300,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(301,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(302,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(303,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(304,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(305,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(306,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(307,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(308,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(309,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(310,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(311,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(313,16) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(320,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(321,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(322,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(323,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(324,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(325,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(314,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(315,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(316,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(317,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(318,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(319,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.341
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 172 
         remark #15477: vector cost: 23.620 
         remark #15478: estimated potential speedup: 6.730 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(292,13)
         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(327,16) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(299,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(300,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(301,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(302,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(303,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(304,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(305,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(306,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(307,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(308,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(309,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(310,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(311,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(313,16) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(320,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(321,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(322,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(323,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(324,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(325,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(314,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(315,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(316,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(317,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(318,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(319,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.540
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 172 
         remark #15477: vector cost: 23.620 
         remark #15478: estimated potential speedup: 6.730 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(292,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(327,16) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(299,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(300,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(301,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(302,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(303,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(304,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(305,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(306,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(307,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(308,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(309,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(310,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(311,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(313,16) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(320,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(321,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(322,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(323,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(324,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(325,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(314,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(315,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(316,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(317,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(318,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(319,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.341
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 172 
         remark #15477: vector cost: 23.620 
         remark #15478: estimated potential speedup: 6.730 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

setiv.f(145,18):remark #34051: REGISTER ALLOCATION : [tml_] setiv.f:145

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdx]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: TML [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (TML) [16/38=42.1%] setiv.f(145,18)
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (180,21) for_write_seq_lis_xmit
  -> EXTERN: (180,21) for_write_seq_lis
  -> EXTERN: (229,16) exp
  -> EXTERN: (234,26) exp
  -> EXTERN: (235,26) exp
  -> EXTERN: (236,26) cos
  -> EXTERN: (237,26) sin
  -> EXTERN: (238,26) cos
  -> EXTERN: (239,26) sin
  -> EXTERN: (241,28) cos
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at setiv.f(180,21)
   remark #15388: vectorization support: reference at (180:38) has aligned access   [ setiv.f(180,38) ]
   remark #15388: vectorization support: reference EPS(:) has aligned access
   remark #15305: vectorization support: vector length 2
   remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ setiv.f(180,38) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 2.000 
   remark #15478: estimated potential speedup: 1.660 
   remark #15487: type converts: 1 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at setiv.f(180,21)
<Remainder loop for vectorization>
   remark #15442: entire loop may be executed in remainder
   remark #15450: unmasked unaligned unit stride loads: 12 
   remark #15451: unmasked unaligned unit stride stores: 3 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 172 
   remark #15477: vector cost: 23.620 
   remark #15478: estimated potential speedup: 6.730 
   remark #15488: --- end vector cost summary ---
   remark #25436: completely unrolled by 1  
LOOP END

LOOP BEGIN at setiv.f(225,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between AEX(l) (234:13) and AEX(l) (245:13)
   remark #15346: vector dependence: assumed ANTI dependence between AEX(l) (245:13) and AEX(l) (234:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 57

   LOOP BEGIN at setiv.f(233,10)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ setiv.f(241,13) ]
      remark #25436: completely unrolled by 3   (pre-vector) 
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(257,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 3 ) --> ( 2 3 1 ) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(258,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(259,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(264,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(265,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(266,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(267,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(268,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(269,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(270,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(272,16) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(273,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(274,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(275,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(276,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(277,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(278,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(280,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.373
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 172 
         remark #15477: vector cost: 23.620 
         remark #15478: estimated potential speedup: 6.730 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(259,13)
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(264,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(265,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(266,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(267,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(268,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(269,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(270,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(272,16) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(273,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(274,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(275,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(276,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(277,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(278,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(280,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.602
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 86 
         remark #15477: vector cost: 12.250 
         remark #15478: estimated potential speedup: 6.480 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(259,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(264,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(265,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(266,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(267,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(268,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(269,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(270,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(272,16) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(273,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(274,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(275,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(276,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(277,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(278,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(280,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.373
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 172 
         remark #15477: vector cost: 23.620 
         remark #15478: estimated potential speedup: 6.730 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(288,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 3 ) --> ( 2 3 1 ) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(290,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(292,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(327,16) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(299,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(300,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(301,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(302,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(303,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(304,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(305,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(306,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(307,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(308,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(309,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(310,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(311,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(313,16) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(320,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(321,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(322,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(323,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(324,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(325,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(314,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(315,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(316,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(317,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(318,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(319,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.341
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 172 
         remark #15477: vector cost: 23.620 
         remark #15478: estimated potential speedup: 6.730 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(292,13)
         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(327,16) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(299,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(300,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(301,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(302,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(303,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(304,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(305,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(306,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(307,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(308,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(309,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(310,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(311,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(313,16) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(320,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(321,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(322,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(323,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(324,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(325,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(314,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(315,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(316,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(317,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(318,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(319,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.540
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 172 
         remark #15477: vector cost: 23.620 
         remark #15478: estimated potential speedup: 6.730 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(292,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(327,16) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(299,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(300,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(301,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(302,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(303,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(304,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(305,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(306,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(307,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(308,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(309,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(310,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(311,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(313,16) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(320,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(321,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(322,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(323,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(324,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(325,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(314,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(315,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(316,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(317,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(318,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(319,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.341
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 172 
         remark #15477: vector cost: 23.620 
         remark #15478: estimated potential speedup: 6.730 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

setiv.f(145,18):remark #34051: REGISTER ALLOCATION : [tml_.h] setiv.f:145

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   53[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm31 k1-k7]
        
    Routine temporaries
        Total         :    1997
            Global    :     479
            Local     :    1518
        Regenerable   :     160
        Spilled       :     239
        
    Routine stack
        Variables     :    1804 bytes*
            Reads     :      66 [5.88e+01 ~ 0.2%]
            Writes    :     416 [4.12e+02 ~ 1.1%]
        Spills        :    2144 bytes*
            Reads     :     375 [3.61e+03 ~ 9.4%]
            Writes    :     259 [8.71e+02 ~ 2.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: TML [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (TML) [16/38=42.1%] setiv.f(145,18)
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (169,7) for_alloc_allocatable
  -> EXTERN: (169,7) for_check_mult_overflow64
  -> EXTERN: (180,21) for_write_seq_lis_xmit
  -> EXTERN: (180,21) for_write_seq_lis
  -> EXTERN: (229,16) exp
  -> EXTERN: (234,26) exp
  -> EXTERN: (235,26) exp
  -> EXTERN: (236,26) cos
  -> EXTERN: (237,26) sin
  -> EXTERN: (238,26) cos
  -> EXTERN: (239,26) sin
  -> EXTERN: (241,28) cos
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (333,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable
  -> EXTERN: (342,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at setiv.f(180,21)
   remark #15388: vectorization support: reference at (180:38) has aligned access   [ setiv.f(180,38) ]
   remark #15388: vectorization support: reference EPS(:) has aligned access
   remark #15305: vectorization support: vector length 2
   remark #15418: vectorization support: number of FP down converts: double precision to single precision 1   [ setiv.f(180,38) ]
   remark #15300: LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15451: unmasked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 5 
   remark #15477: vector cost: 2.000 
   remark #15478: estimated potential speedup: 1.660 
   remark #15487: type converts: 1 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at setiv.f(180,21)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 1  
LOOP END

LOOP BEGIN at setiv.f(225,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 ) --> ( 2 1 ) 
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between AEX(l) (234:13) and AEX(l) (245:13)
   remark #15346: vector dependence: assumed ANTI dependence between AEX(l) (245:13) and AEX(l) (234:13)
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 57

   LOOP BEGIN at setiv.f(233,10)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ setiv.f(241,13) ]
      remark #25436: completely unrolled by 3   (pre-vector) 
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(257,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 3 ) --> ( 2 3 1 ) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(258,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(259,13)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at setiv.f(259,13)
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(264,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(265,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(266,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(267,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(268,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(269,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(270,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(272,16) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(273,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(274,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(275,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(276,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(277,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(278,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(280,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.656
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 86 
         remark #15477: vector cost: 22.500 
         remark #15478: estimated potential speedup: 3.650 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(259,13)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at setiv.f(288,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest. Suggested Permutation : ( 1 2 3 ) --> ( 2 3 1 ) 
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at setiv.f(290,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at setiv.f(292,13)
      <Peeled loop for vectorization>
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at setiv.f(292,13)
         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ setiv.f(327,16) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ setiv.f(299,16) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(300,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(301,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(302,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(303,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(304,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(305,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(306,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(307,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(308,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(309,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(310,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(311,47) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ setiv.f(313,16) ]
         remark #15389: vectorization support: reference SI3(ii,2,1) has unaligned access   [ setiv.f(320,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,1) has unaligned access   [ setiv.f(321,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,2) has unaligned access   [ setiv.f(322,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,2) has unaligned access   [ setiv.f(323,47) ]
         remark #15389: vectorization support: reference SI3(ii,2,3) has unaligned access   [ setiv.f(324,47) ]
         remark #15389: vectorization support: reference SI3(ii,1,3) has unaligned access   [ setiv.f(325,47) ]
         remark #15389: vectorization support: reference SI(ii,2,1) has unaligned access   [ setiv.f(314,47) ]
         remark #15389: vectorization support: reference SI(ii,1,1) has unaligned access   [ setiv.f(315,47) ]
         remark #15389: vectorization support: reference SI(ii,2,2) has unaligned access   [ setiv.f(316,47) ]
         remark #15389: vectorization support: reference SI(ii,1,2) has unaligned access   [ setiv.f(317,47) ]
         remark #15389: vectorization support: reference SI(ii,2,3) has unaligned access   [ setiv.f(318,47) ]
         remark #15389: vectorization support: reference SI(ii,1,3) has unaligned access   [ setiv.f(319,47) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.583
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 12 
         remark #15451: unmasked unaligned unit stride stores: 3 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 172 
         remark #15477: vector cost: 43.750 
         remark #15478: estimated potential speedup: 3.750 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at setiv.f(292,13)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

setiv.f(145,18):remark #34051: REGISTER ALLOCATION : [tml_.A] setiv.f:145

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :    1691
            Global    :     338
            Local     :    1353
        Regenerable   :     148
        Spilled       :     228
        
    Routine stack
        Variables     :    1804 bytes*
            Reads     :      66 [5.88e+01 ~ 0.2%]
            Writes    :     416 [4.12e+02 ~ 1.7%]
        Spills        :    2456 bytes*
            Reads     :     402 [5.69e+03 ~ 23.2%]
            Writes    :     244 [1.08e+03 ~ 4.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: FLOWIO

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (FLOWIO) [17/38=44.7%] flowio.f(1,18)
  -> EXTERN: (21,10) for_write_int_fmt_xmit
  -> EXTERN: (21,10) for_write_int_fmt
  -> EXTERN: (23,10) for_write_seq_fmt
  -> EXTERN: (23,10) for_write_seq_fmt_xmit
  -> EXTERN: (25,10) for_open
  -> EXTERN: (26,10) for_write_seq
  -> EXTERN: (26,10) for_write_seq_xmit
  -> EXTERN: (26,10) for_write_seq_xmit
  -> EXTERN: (27,10) for_write_seq
  -> EXTERN: (27,10) for_write_seq_xmit
  -> EXTERN: (27,10) for_write_seq_xmit
  -> EXTERN: (30,7) for_alloc_allocatable
  -> EXTERN: (30,7) for_check_mult_overflow64
  -> EXTERN: (30,7) for_alloc_allocatable
  -> EXTERN: (30,7) for_check_mult_overflow64
  -> EXTERN: (54,12) mpi_reduce_
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq
  -> EXTERN: (64,16) for_close
  -> EXTERN: (67,7) for_dealloc_allocatable
  -> EXTERN: (67,7) for_dealloc_allocatable
  -> EXTERN: (72,10) for_write_int_fmt
  -> EXTERN: (73,10) for_write_seq_fmt
  -> EXTERN: (73,10) for_write_seq_fmt_xmit
  -> EXTERN: (75,10) for_open
  -> EXTERN: (76,10) for_write_seq
  -> EXTERN: (76,10) for_write_seq_xmit
  -> EXTERN: (76,10) for_write_seq_xmit
  -> EXTERN: (79,7) for_alloc_allocatable
  -> EXTERN: (79,7) for_check_mult_overflow64
  -> EXTERN: (79,7) for_alloc_allocatable
  -> EXTERN: (79,7) for_check_mult_overflow64
  -> EXTERN: (99,12) mpi_reduce_
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq
  -> EXTERN: (107,16) for_close
  -> EXTERN: (110,7) for_dealloc_allocatable
  -> EXTERN: (110,7) for_dealloc_allocatable
  -> EXTERN: (113,7) for_dealloc_allocatable
  -> EXTERN: (113,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at flowio.f(27,10)
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (27:10) and at (27:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (27:10) and at (27:10)
   remark #25436: completely unrolled by 4  
LOOP END

LOOP BEGIN at flowio.f(33,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at flowio.f(33,7)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at flowio.f(33,7)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at flowio.f(33,7)
            remark #25408: memset generated
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at flowio.f(33,7)
               remark #15389: vectorization support: reference RBUF(:,:,:,:) has unaligned access
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.500
               remark #15300: LOOP WAS VECTORIZED
               remark #15451: unmasked unaligned unit stride stores: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 3 
               remark #15477: vector cost: 0.750 
               remark #15478: estimated potential speedup: 1.710 
               remark #15488: --- end vector cost summary ---
               remark #25015: Estimate of max trip count of loop=1
            LOOP END

            LOOP BEGIN at flowio.f(33,7)
            <Remainder loop for vectorization>
               remark #15389: vectorization support: reference RBUF(:,:,:,:) has unaligned access
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
               remark #15305: vectorization support: vector length 2
               remark #15309: vectorization support: normalized vectorization overhead 1.167
               remark #15451: unmasked unaligned unit stride stores: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 3 
               remark #15477: vector cost: 0.750 
               remark #15478: estimated potential speedup: 1.710 
               remark #15488: --- end vector cost summary ---
               remark #25015: Estimate of max trip count of loop=12
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(35,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at flowio.f(36,10)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ flowio.f(49,10) ]
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at flowio.f(37,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(42,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(42,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(42,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(43,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(43,35) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(43,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,4) has unaligned access   [ flowio.f(44,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(44,35) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(44,50) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(47,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(47,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(47,61) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,5) has unaligned access   [ flowio.f(45,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(45,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ flowio.f(46,45) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.503
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 5.640 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at flowio.f(37,13)
         remark #25084: Preprocess Loopnests: Moving Out Store    [ flowio.f(48,13) ]
         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(42,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(42,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(42,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(43,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(43,35) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(43,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,4) has unaligned access   [ flowio.f(44,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(44,35) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(44,50) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(47,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(47,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(47,61) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,5) has unaligned access   [ flowio.f(45,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(45,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ flowio.f(46,45) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.611
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 5.640 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at flowio.f(37,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(42,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(42,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(42,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(43,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(43,35) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(43,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,4) has unaligned access   [ flowio.f(44,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(44,35) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(44,50) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(47,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(47,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(47,61) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,5) has unaligned access   [ flowio.f(45,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(45,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ flowio.f(46,45) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.503
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 5.640 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(82,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at flowio.f(82,7)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at flowio.f(82,7)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at flowio.f(82,7)
            remark #25408: memset generated
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at flowio.f(82,7)
               remark #15389: vectorization support: reference RBUF(:,:,:,:) has unaligned access
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.500
               remark #15300: LOOP WAS VECTORIZED
               remark #15451: unmasked unaligned unit stride stores: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 3 
               remark #15477: vector cost: 0.750 
               remark #15478: estimated potential speedup: 1.710 
               remark #15488: --- end vector cost summary ---
               remark #25015: Estimate of max trip count of loop=1
            LOOP END

            LOOP BEGIN at flowio.f(82,7)
            <Remainder loop for vectorization>
               remark #15389: vectorization support: reference RBUF(:,:,:,:) has unaligned access
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
               remark #15305: vectorization support: vector length 2
               remark #15309: vectorization support: normalized vectorization overhead 1.167
               remark #15451: unmasked unaligned unit stride stores: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 3 
               remark #15477: vector cost: 0.750 
               remark #15478: estimated potential speedup: 1.710 
               remark #15488: --- end vector cost summary ---
               remark #25015: Estimate of max trip count of loop=12
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(84,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at flowio.f(85,10)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ flowio.f(94,10) ]
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at flowio.f(86,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(92,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ flowio.f(92,16) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,1) has unaligned access   [ flowio.f(90,16) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ flowio.f(90,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.833
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 13 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 4.300 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at flowio.f(86,13)
         remark #25084: Preprocess Loopnests: Moving Out Store    [ flowio.f(93,13) ]
         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(92,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ flowio.f(92,16) ]
         remark #15388: vectorization support: reference RBUF(ig,jg,kg,1) has aligned access   [ flowio.f(90,16) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ flowio.f(90,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.591
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 13 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 4.300 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at flowio.f(86,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(92,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ flowio.f(92,16) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,1) has unaligned access   [ flowio.f(90,16) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ flowio.f(90,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.833
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 13 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 4.300 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(103,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

   LOOP BEGIN at flowio.f(103,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

      LOOP BEGIN at flowio.f(103,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(103,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

   LOOP BEGIN at flowio.f(103,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

      LOOP BEGIN at flowio.f(103,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(103,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

   LOOP BEGIN at flowio.f(103,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

      LOOP BEGIN at flowio.f(103,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

flowio.f(1,18):remark #34051: REGISTER ALLOCATION : [flowio_] flowio.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdx]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: FLOWIO [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (FLOWIO) [17/38=44.7%] flowio.f(1,18)
  -> EXTERN: (21,10) for_write_int_fmt_xmit
  -> EXTERN: (21,10) for_write_int_fmt
  -> EXTERN: (23,10) for_write_seq_fmt
  -> EXTERN: (23,10) for_write_seq_fmt_xmit
  -> EXTERN: (25,10) for_open
  -> EXTERN: (26,10) for_write_seq
  -> EXTERN: (26,10) for_write_seq_xmit
  -> EXTERN: (26,10) for_write_seq_xmit
  -> EXTERN: (27,10) for_write_seq
  -> EXTERN: (27,10) for_write_seq_xmit
  -> EXTERN: (27,10) for_write_seq_xmit
  -> EXTERN: (30,7) for_alloc_allocatable
  -> EXTERN: (30,7) for_check_mult_overflow64
  -> EXTERN: (30,7) for_alloc_allocatable
  -> EXTERN: (30,7) for_check_mult_overflow64
  -> EXTERN: (54,12) mpi_reduce_
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq
  -> EXTERN: (64,16) for_close
  -> EXTERN: (67,7) for_dealloc_allocatable
  -> EXTERN: (67,7) for_dealloc_allocatable
  -> EXTERN: (72,10) for_write_int_fmt
  -> EXTERN: (73,10) for_write_seq_fmt
  -> EXTERN: (73,10) for_write_seq_fmt_xmit
  -> EXTERN: (75,10) for_open
  -> EXTERN: (76,10) for_write_seq
  -> EXTERN: (76,10) for_write_seq_xmit
  -> EXTERN: (76,10) for_write_seq_xmit
  -> EXTERN: (79,7) for_alloc_allocatable
  -> EXTERN: (79,7) for_check_mult_overflow64
  -> EXTERN: (79,7) for_alloc_allocatable
  -> EXTERN: (79,7) for_check_mult_overflow64
  -> EXTERN: (99,12) mpi_reduce_
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq
  -> EXTERN: (107,16) for_close
  -> EXTERN: (110,7) for_dealloc_allocatable
  -> EXTERN: (110,7) for_dealloc_allocatable
  -> EXTERN: (113,7) for_dealloc_allocatable
  -> EXTERN: (113,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at flowio.f(27,10)
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (27:10) and at (27:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (27:10) and at (27:10)
   remark #25436: completely unrolled by 4  
LOOP END

LOOP BEGIN at flowio.f(33,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at flowio.f(33,7)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at flowio.f(33,7)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at flowio.f(33,7)
            remark #25408: memset generated
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at flowio.f(33,7)
               remark #15389: vectorization support: reference RBUF(:,:,:,:) has unaligned access
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.500
               remark #15300: LOOP WAS VECTORIZED
               remark #15451: unmasked unaligned unit stride stores: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 3 
               remark #15477: vector cost: 0.750 
               remark #15478: estimated potential speedup: 1.710 
               remark #15488: --- end vector cost summary ---
               remark #25015: Estimate of max trip count of loop=1
            LOOP END

            LOOP BEGIN at flowio.f(33,7)
            <Remainder loop for vectorization>
               remark #15389: vectorization support: reference RBUF(:,:,:,:) has unaligned access
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
               remark #15305: vectorization support: vector length 2
               remark #15309: vectorization support: normalized vectorization overhead 1.167
               remark #15451: unmasked unaligned unit stride stores: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 3 
               remark #15477: vector cost: 0.750 
               remark #15478: estimated potential speedup: 1.710 
               remark #15488: --- end vector cost summary ---
               remark #25015: Estimate of max trip count of loop=12
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(35,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at flowio.f(36,10)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ flowio.f(49,10) ]
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at flowio.f(37,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(42,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(42,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(42,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(43,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(43,35) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(43,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,4) has unaligned access   [ flowio.f(44,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(44,35) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(44,50) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(47,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(47,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(47,61) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,5) has unaligned access   [ flowio.f(45,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(45,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ flowio.f(46,45) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.503
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 5.640 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at flowio.f(37,13)
         remark #25084: Preprocess Loopnests: Moving Out Store    [ flowio.f(48,13) ]
         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(42,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(42,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(42,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(43,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(43,35) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(43,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,4) has unaligned access   [ flowio.f(44,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(44,35) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(44,50) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(47,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(47,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(47,61) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,5) has unaligned access   [ flowio.f(45,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(45,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ flowio.f(46,45) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.611
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 5.640 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at flowio.f(37,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(42,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(42,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(42,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(43,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(43,35) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(43,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,4) has unaligned access   [ flowio.f(44,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(44,35) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(44,50) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(47,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(47,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(47,61) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,5) has unaligned access   [ flowio.f(45,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(45,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ flowio.f(46,45) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.503
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 5.640 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(82,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at flowio.f(82,7)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at flowio.f(82,7)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at flowio.f(82,7)
            remark #25408: memset generated
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at flowio.f(82,7)
               remark #15389: vectorization support: reference RBUF(:,:,:,:) has unaligned access
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 8
               remark #15309: vectorization support: normalized vectorization overhead 0.500
               remark #15300: LOOP WAS VECTORIZED
               remark #15451: unmasked unaligned unit stride stores: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 3 
               remark #15477: vector cost: 0.750 
               remark #15478: estimated potential speedup: 1.710 
               remark #15488: --- end vector cost summary ---
               remark #25015: Estimate of max trip count of loop=1
            LOOP END

            LOOP BEGIN at flowio.f(82,7)
            <Remainder loop for vectorization>
               remark #15389: vectorization support: reference RBUF(:,:,:,:) has unaligned access
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
               remark #15305: vectorization support: vector length 2
               remark #15309: vectorization support: normalized vectorization overhead 1.167
               remark #15451: unmasked unaligned unit stride stores: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 3 
               remark #15477: vector cost: 0.750 
               remark #15478: estimated potential speedup: 1.710 
               remark #15488: --- end vector cost summary ---
               remark #25015: Estimate of max trip count of loop=12
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(84,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at flowio.f(85,10)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ flowio.f(94,10) ]
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at flowio.f(86,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(92,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ flowio.f(92,16) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,1) has unaligned access   [ flowio.f(90,16) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ flowio.f(90,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.833
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 13 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 4.300 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at flowio.f(86,13)
         remark #25084: Preprocess Loopnests: Moving Out Store    [ flowio.f(93,13) ]
         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(92,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ flowio.f(92,16) ]
         remark #15388: vectorization support: reference RBUF(ig,jg,kg,1) has aligned access   [ flowio.f(90,16) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ flowio.f(90,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.591
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 13 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 4.300 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at flowio.f(86,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(92,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ flowio.f(92,16) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,1) has unaligned access   [ flowio.f(90,16) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ flowio.f(90,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.833
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 13 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 4.300 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(103,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

   LOOP BEGIN at flowio.f(103,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

      LOOP BEGIN at flowio.f(103,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(103,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

   LOOP BEGIN at flowio.f(103,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

      LOOP BEGIN at flowio.f(103,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(103,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

   LOOP BEGIN at flowio.f(103,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

      LOOP BEGIN at flowio.f(103,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

flowio.f(33,7):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
flowio.f(33,7):remark #34026: call to memset implemented as a call to optimized library version
flowio.f(82,7):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
flowio.f(82,7):remark #34026: call to memset implemented as a call to optimized library version
flowio.f(1,18):remark #34051: REGISTER ALLOCATION : [flowio_.h] flowio.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   40[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm3 zmm16-zmm30 k1-k7]
        
    Routine temporaries
        Total         :    1468
            Global    :     456
            Local     :    1012
        Regenerable   :     385
        Spilled       :     239
        
    Routine stack
        Variables     :     728 bytes*
            Reads     :      56 [2.41e+01 ~ 0.0%]
            Writes    :     211 [1.15e+03 ~ 2.2%]
        Spills        :    1808 bytes*
            Reads     :     392 [2.90e+03 ~ 5.6%]
            Writes    :     294 [1.56e+03 ~ 3.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: FLOWIO [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (FLOWIO) [17/38=44.7%] flowio.f(1,18)
  -> EXTERN: (21,10) for_write_int_fmt_xmit
  -> EXTERN: (21,10) for_write_int_fmt
  -> EXTERN: (23,10) for_write_seq_fmt
  -> EXTERN: (23,10) for_write_seq_fmt_xmit
  -> EXTERN: (25,10) for_open
  -> EXTERN: (26,10) for_write_seq
  -> EXTERN: (26,10) for_write_seq_xmit
  -> EXTERN: (26,10) for_write_seq_xmit
  -> EXTERN: (27,10) for_write_seq
  -> EXTERN: (27,10) for_write_seq_xmit
  -> EXTERN: (27,10) for_write_seq_xmit
  -> EXTERN: (30,7) for_alloc_allocatable
  -> EXTERN: (30,7) for_check_mult_overflow64
  -> EXTERN: (30,7) for_alloc_allocatable
  -> EXTERN: (30,7) for_check_mult_overflow64
  -> EXTERN: (54,12) mpi_reduce_
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq_xmit
  -> EXTERN: (58,10) for_write_seq
  -> EXTERN: (64,16) for_close
  -> EXTERN: (67,7) for_dealloc_allocatable
  -> EXTERN: (67,7) for_dealloc_allocatable
  -> EXTERN: (72,10) for_write_int_fmt
  -> EXTERN: (73,10) for_write_seq_fmt
  -> EXTERN: (73,10) for_write_seq_fmt_xmit
  -> EXTERN: (75,10) for_open
  -> EXTERN: (76,10) for_write_seq
  -> EXTERN: (76,10) for_write_seq_xmit
  -> EXTERN: (76,10) for_write_seq_xmit
  -> EXTERN: (79,7) for_alloc_allocatable
  -> EXTERN: (79,7) for_check_mult_overflow64
  -> EXTERN: (79,7) for_alloc_allocatable
  -> EXTERN: (79,7) for_check_mult_overflow64
  -> EXTERN: (99,12) mpi_reduce_
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq_xmit
  -> EXTERN: (103,10) for_write_seq
  -> EXTERN: (107,16) for_close
  -> EXTERN: (110,7) for_dealloc_allocatable
  -> EXTERN: (110,7) for_dealloc_allocatable
  -> EXTERN: (113,7) for_dealloc_allocatable
  -> EXTERN: (113,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at flowio.f(27,10)
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (27:10) and at (27:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (27:10) and at (27:10)
   remark #25436: completely unrolled by 4  
LOOP END

LOOP BEGIN at flowio.f(33,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at flowio.f(33,7)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at flowio.f(33,7)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at flowio.f(33,7)
            remark #25408: memset generated
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at flowio.f(33,7)
               remark #15389: vectorization support: reference RBUF(:,:,:,:) has unaligned access
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 4
               remark #15399: vectorization support: unroll factor set to 2
               remark #15309: vectorization support: normalized vectorization overhead 0.300
               remark #15300: LOOP WAS VECTORIZED
               remark #15451: unmasked unaligned unit stride stores: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 3 
               remark #15477: vector cost: 1.250 
               remark #15478: estimated potential speedup: 1.440 
               remark #15488: --- end vector cost summary ---
               remark #25015: Estimate of max trip count of loop=1
            LOOP END

            LOOP BEGIN at flowio.f(33,7)
            <Remainder loop for vectorization>
               remark #25015: Estimate of max trip count of loop=12
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(35,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at flowio.f(36,10)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ flowio.f(49,10) ]
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at flowio.f(37,13)
      <Peeled loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at flowio.f(37,13)
         remark #25084: Preprocess Loopnests: Moving Out Store    [ flowio.f(48,13) ]
         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(42,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(42,35) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(42,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(43,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(43,35) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(43,50) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,4) has unaligned access   [ flowio.f(44,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(44,35) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(44,50) ]
         remark #15389: vectorization support: reference u_(i,j,k) has unaligned access   [ flowio.f(47,33) ]
         remark #15389: vectorization support: reference v_(i,j,k) has unaligned access   [ flowio.f(47,47) ]
         remark #15389: vectorization support: reference w_(i,j,k) has unaligned access   [ flowio.f(47,61) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,5) has unaligned access   [ flowio.f(45,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(45,35) ]
         remark #15389: vectorization support: reference t_(i,j,k) has unaligned access   [ flowio.f(46,45) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15389: vectorization support: reference q_(i,j,k,1,1) has unaligned access   [ flowio.f(41,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.698
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 5 
         remark #15451: unmasked unaligned unit stride stores: 5 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 55 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.340 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at flowio.f(37,13)
      <Remainder loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(58,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

   LOOP BEGIN at flowio.f(58,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)

      LOOP BEGIN at flowio.f(58,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (58:10) and at (58:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(82,7)
   remark #25101: Loop Interchange not done due to: Original Order seems proper
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at flowio.f(82,7)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at flowio.f(82,7)
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at flowio.f(82,7)
            remark #25408: memset generated
            remark #15542: loop was not vectorized: inner loop was already vectorized

            LOOP BEGIN at flowio.f(82,7)
               remark #15389: vectorization support: reference RBUF(:,:,:,:) has unaligned access
               remark #15381: vectorization support: unaligned access used inside loop body
               remark #15305: vectorization support: vector length 4
               remark #15399: vectorization support: unroll factor set to 2
               remark #15309: vectorization support: normalized vectorization overhead 0.300
               remark #15300: LOOP WAS VECTORIZED
               remark #15451: unmasked unaligned unit stride stores: 1 
               remark #15475: --- begin vector cost summary ---
               remark #15476: scalar cost: 3 
               remark #15477: vector cost: 1.250 
               remark #15478: estimated potential speedup: 1.440 
               remark #15488: --- end vector cost summary ---
               remark #25015: Estimate of max trip count of loop=1
            LOOP END

            LOOP BEGIN at flowio.f(82,7)
            <Remainder loop for vectorization>
               remark #25015: Estimate of max trip count of loop=12
            LOOP END
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(84,7)
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at flowio.f(85,10)
      remark #25084: Preprocess Loopnests: Moving Out Store    [ flowio.f(94,10) ]
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at flowio.f(86,13)
      <Peeled loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
         remark #25015: Estimate of max trip count of loop=7
      LOOP END

      LOOP BEGIN at flowio.f(86,13)
         remark #25084: Preprocess Loopnests: Moving Out Store    [ flowio.f(93,13) ]
         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(92,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ flowio.f(92,16) ]
         remark #15388: vectorization support: reference RBUF(ig,jg,kg,1) has aligned access   [ flowio.f(90,16) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ flowio.f(90,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.394
         remark #15300: LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 13 
         remark #15477: vector cost: 4.120 
         remark #15478: estimated potential speedup: 2.840 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at flowio.f(86,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,2) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference y_(i,j,k) has unaligned access   [ flowio.f(91,16) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,3) has unaligned access   [ flowio.f(92,16) ]
         remark #15389: vectorization support: reference z_(i,j,k) has unaligned access   [ flowio.f(92,16) ]
         remark #15389: vectorization support: reference RBUF(ig,jg,kg,1) has unaligned access   [ flowio.f(90,16) ]
         remark #15389: vectorization support: reference x_(i,j,k) has unaligned access   [ flowio.f(90,16) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.526
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15449: unmasked aligned unit stride stores: 1 
         remark #15450: unmasked unaligned unit stride loads: 3 
         remark #15451: unmasked unaligned unit stride stores: 2 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 13 
         remark #15477: vector cost: 4.120 
         remark #15478: estimated potential speedup: 2.840 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at flowio.f(86,13)
      <Remainder loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(103,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

   LOOP BEGIN at flowio.f(103,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

      LOOP BEGIN at flowio.f(103,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(103,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

   LOOP BEGIN at flowio.f(103,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

      LOOP BEGIN at flowio.f(103,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at flowio.f(103,10)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
   remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

   LOOP BEGIN at flowio.f(103,10)
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)

      LOOP BEGIN at flowio.f(103,10)
         remark #15382: vectorization support: call to function for_write_seq_xmit cannot be vectorized
         remark #15344: loop was not vectorized: vector dependence prevents vectorization
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
         remark #15346: vector dependence: assumed OUTPUT dependence between at (103:10) and at (103:10)
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

flowio.f(33,7):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
flowio.f(33,7):remark #34026: call to memset implemented as a call to optimized library version
flowio.f(82,7):remark #34014: optimization advice for memset: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
flowio.f(82,7):remark #34026: call to memset implemented as a call to optimized library version
flowio.f(1,18):remark #34051: REGISTER ALLOCATION : [flowio_.A] flowio.f:1

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   28[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm13]
        
    Routine temporaries
        Total         :    1275
            Global    :     383
            Local     :     892
        Regenerable   :     375
        Spilled       :     198
        
    Routine stack
        Variables     :     728 bytes*
            Reads     :      56 [2.41e+01 ~ 0.1%]
            Writes    :     211 [1.15e+03 ~ 3.1%]
        Spills        :    1544 bytes*
            Reads     :     335 [2.52e+03 ~ 6.7%]
            Writes    :     267 [1.39e+03 ~ 3.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: variable_data._

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (variable_data._) modules.f(170,14)

===========================================================================

Begin optimization report for: general_data._

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (general_data._) modules.f(1,14)

===========================================================================

Begin optimization report for: EXI2

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (EXI2) fluxi.f(156,18)

===========================================================================

Begin optimization report for: EJECT

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (EJECT) main.f(354,18)

===========================================================================

Begin optimization report for: EXJ2

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (EXJ2) fluxj.f(148,18)

===========================================================================

Begin optimization report for: EXJ4

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (EXJ4) fluxj.f(171,18)

===========================================================================

Begin optimization report for: VISCJ

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (VISCJ) fluxj.f(240,18)

===========================================================================

Begin optimization report for: EXK2

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (EXK2) fluxk.f(155,18)

===========================================================================

Begin optimization report for: EXK4

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (EXK4) fluxk.f(178,18)

===========================================================================

Begin optimization report for: VISCK

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (VISCK) fluxk.f(247,18)

===========================================================================

Begin optimization report for: UPDATE

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (UPDATE) update.f(1,18)

===========================================================================

Begin optimization report for: SETIV

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SETIV) setiv.f(1,18)

===========================================================================

Begin optimization report for: THERMAL_PROPS

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (THERMAL_PROPS) props.f(4,18)

===========================================================================

Begin optimization report for: GRIDMAP

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (GRIDMAP) parallel.f(148,18)

===========================================================================

Begin optimization report for: MAP

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (MAP) [32/38=84.2%] parallel.f(255,18)


    Report from: Code generation optimizations [cg]

parallel.f(255,18):remark #34051: REGISTER ALLOCATION : [map_] parallel.f:255

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8-r11]
        
    Routine temporaries
        Total         :      32
            Global    :      15
            Local     :      17
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: INTERNAL_ENERGY

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (INTERNAL_ENERGY) props.f(27,18)

===========================================================================

Begin optimization report for: WALLBC

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (WALLBC) setbc.f(433,18)

===========================================================================

Begin optimization report for: EXI4

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (EXI4) fluxi.f(185,18)

===========================================================================

Begin optimization report for: EXTRAPK

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (EXTRAPK) [36/38=94.7%] fluxk.f(74,18)
  -> EXTERN: (121,7) for_alloc_allocatable
  -> EXTERN: (121,7) for_check_mult_overflow64
  -> INLINE: (129,21) EXK2 (isz = 217) (sz = 228)
  -> INLINE: (131,21) EXK4 (isz = 1265) (sz = 1276)
    -> EXTERN: (178,18) __getsp_inlined
    -> EXTERN: (178,18) _alloca
    -> EXTERN: (178,18) _alloca
    -> EXTERN: (178,18) _alloca
    -> EXTERN: (244,7) __resetsp_inlined
  -> EXTERN: (150,7) for_dealloc_allocatable
  -> EXTERN: (153,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxk.f(123,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxk.f(125,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxk.f(169,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(169,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
            remark #15389: vectorization support: reference q_(:,j,kk,1,n) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxk.f(169,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
            remark #15389: vectorization support: reference q_(:,j,kk,1,n) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(170,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(170,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference u_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxk.f(170,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference u_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(171,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(171,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference v_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxk.f(171,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference v_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(172,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(172,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference w_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxk.f(172,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference w_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(173,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(173,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference t_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxk.f(173,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference t_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(198,10) inlined into fluxk.f(131,21)
         remark #25045: Fused Loops: ( 198 200 203 )

         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k+1,3) has unaligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(200,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access   [ fluxk.f(202,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(203,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(203,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k+1,3) has unaligned access   [ fluxk.f(203,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 5.000 
         remark #15478: estimated potential speedup: 7.060 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxk.f(200,10) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(203,10) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(205,10) inlined into fluxk.f(131,21)
         remark #25045: Fused Loops: ( 205 207 210 )

         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k-1,3) has unaligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(207,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access   [ fluxk.f(209,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(210,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(210,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k-1,3) has unaligned access   [ fluxk.f(210,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 5.000 
         remark #15478: estimated potential speedup: 7.060 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxk.f(207,10) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(210,10) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(213,7) inlined into fluxk.f(131,21)
         remark #25045: Fused Loops: ( 213 214 216 219 220 222 225 226 228 231 232 234 237 238 240 )

         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(237,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(237,7) ]
         remark #15389: vectorization support: reference t_(:,j,kk) has unaligned access   [ fluxk.f(237,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(231,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(231,7) ]
         remark #15389: vectorization support: reference w_(:,j,kk) has unaligned access   [ fluxk.f(231,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(225,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(225,7) ]
         remark #15389: vectorization support: reference v_(:,j,kk) has unaligned access   [ fluxk.f(225,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(219,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(219,7) ]
         remark #15389: vectorization support: reference u_(:,j,kk) has unaligned access   [ fluxk.f(219,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,j,kk,1,n) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(238,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference t_(:,j,kbd) has unaligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(232,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference w_(:,j,kbd) has unaligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(226,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference v_(:,j,kbd) has unaligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(220,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference u_(:,j,kbd) has unaligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(214,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference q_(:,j,kbd,1,n) has unaligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(240,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference t_(:,j,kcd) has unaligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(234,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference w_(:,j,kcd) has unaligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(228,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference v_(:,j,kcd) has unaligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(222,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference u_(:,j,kcd) has unaligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(216,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(216,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(216,7) ]
         remark #15389: vectorization support: reference q_(:,j,kcd,1,n) has unaligned access   [ fluxk.f(216,7) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.583
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 11 
         remark #15450: unmasked unaligned unit stride loads: 20 
         remark #15451: unmasked unaligned unit stride stores: 15 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 121 
         remark #15477: vector cost: 22.500 
         remark #15478: estimated potential speedup: 5.090 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 27
      LOOP END

      LOOP BEGIN at fluxk.f(214,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(216,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(219,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(220,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(222,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(225,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(226,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(228,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(231,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(232,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(234,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(237,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(238,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(240,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(213,7) inlined into fluxk.f(131,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(237,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(237,7) ]
         remark #15389: vectorization support: reference t_(:,j,kk) has unaligned access   [ fluxk.f(237,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(231,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(231,7) ]
         remark #15389: vectorization support: reference w_(:,j,kk) has unaligned access   [ fluxk.f(231,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(225,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(225,7) ]
         remark #15389: vectorization support: reference v_(:,j,kk) has unaligned access   [ fluxk.f(225,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(219,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(219,7) ]
         remark #15389: vectorization support: reference u_(:,j,kk) has unaligned access   [ fluxk.f(219,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,j,kk,1,n) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(238,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference t_(:,j,kbd) has unaligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(232,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference w_(:,j,kbd) has unaligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(226,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference v_(:,j,kbd) has unaligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(220,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference u_(:,j,kbd) has unaligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(214,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference q_(:,j,kbd,1,n) has unaligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(240,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference t_(:,j,kcd) has unaligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(234,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference w_(:,j,kcd) has unaligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(228,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference v_(:,j,kcd) has unaligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(222,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference u_(:,j,kcd) has unaligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(216,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(216,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(216,7) ]
         remark #15389: vectorization support: reference q_(:,j,kcd,1,n) has unaligned access   [ fluxk.f(216,7) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 0.150
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 27
      LOOP END

      LOOP BEGIN at fluxk.f(134,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(144,47) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxk.f(142,48) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.444
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(134,13)
         remark #25045: Fused Loops: ( 134 138 139 140 141 144 )

         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(144,47) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxk.f(142,48) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.581
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 8
      LOOP END

      LOOP BEGIN at fluxk.f(138,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(139,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(140,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(141,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(144,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(134,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(144,47) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxk.f(142,48) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.444
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(198,10) inlined into fluxk.f(131,21)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k+1,3) has unaligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(200,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access   [ fluxk.f(202,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(203,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(203,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k+1,3) has unaligned access   [ fluxk.f(203,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.461
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(205,10) inlined into fluxk.f(131,21)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k-1,3) has unaligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(207,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access   [ fluxk.f(209,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(210,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(210,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k-1,3) has unaligned access   [ fluxk.f(210,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.461
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxk.f(74,18):remark #34051: REGISTER ALLOCATION : [extrapk_] fluxk.f:74

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdx]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: EXTRAPK [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (EXTRAPK) [36/38=94.7%] fluxk.f(74,18)
  -> EXTERN: (121,7) for_alloc_allocatable
  -> EXTERN: (121,7) for_check_mult_overflow64
  -> INLINE: (129,21) EXK2 (isz = 217) (sz = 228)
  -> INLINE: (131,21) EXK4 (isz = 1265) (sz = 1276)
    -> EXTERN: (178,18) __getsp_inlined
    -> EXTERN: (178,18) _alloca
    -> EXTERN: (178,18) _alloca
    -> EXTERN: (178,18) _alloca
    -> EXTERN: (244,7) __resetsp_inlined
  -> EXTERN: (150,7) for_dealloc_allocatable
  -> EXTERN: (153,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxk.f(123,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxk.f(125,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxk.f(169,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(169,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
            remark #15389: vectorization support: reference q_(:,j,kk,1,n) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxk.f(169,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
            remark #15389: vectorization support: reference q_(:,j,kk,1,n) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(170,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(170,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference u_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxk.f(170,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference u_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(171,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(171,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference v_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxk.f(171,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference v_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(172,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(172,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference w_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxk.f(172,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference w_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(173,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(173,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference t_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxk.f(173,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference t_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(198,10) inlined into fluxk.f(131,21)
         remark #25045: Fused Loops: ( 198 200 203 )

         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k+1,3) has unaligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(200,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access   [ fluxk.f(202,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(203,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(203,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k+1,3) has unaligned access   [ fluxk.f(203,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 5.000 
         remark #15478: estimated potential speedup: 7.060 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxk.f(200,10) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(203,10) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(205,10) inlined into fluxk.f(131,21)
         remark #25045: Fused Loops: ( 205 207 210 )

         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k-1,3) has unaligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(207,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access   [ fluxk.f(209,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(210,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(210,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k-1,3) has unaligned access   [ fluxk.f(210,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 5.000 
         remark #15478: estimated potential speedup: 7.060 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxk.f(207,10) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(210,10) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(213,7) inlined into fluxk.f(131,21)
         remark #25045: Fused Loops: ( 213 214 216 219 220 222 225 226 228 231 232 234 237 238 240 )

         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(237,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(237,7) ]
         remark #15389: vectorization support: reference t_(:,j,kk) has unaligned access   [ fluxk.f(237,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(231,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(231,7) ]
         remark #15389: vectorization support: reference w_(:,j,kk) has unaligned access   [ fluxk.f(231,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(225,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(225,7) ]
         remark #15389: vectorization support: reference v_(:,j,kk) has unaligned access   [ fluxk.f(225,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(219,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(219,7) ]
         remark #15389: vectorization support: reference u_(:,j,kk) has unaligned access   [ fluxk.f(219,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,j,kk,1,n) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(238,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference t_(:,j,kbd) has unaligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(232,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference w_(:,j,kbd) has unaligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(226,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference v_(:,j,kbd) has unaligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(220,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference u_(:,j,kbd) has unaligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(214,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference q_(:,j,kbd,1,n) has unaligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(240,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference t_(:,j,kcd) has unaligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(234,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference w_(:,j,kcd) has unaligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(228,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference v_(:,j,kcd) has unaligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(222,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference u_(:,j,kcd) has unaligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(216,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(216,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(216,7) ]
         remark #15389: vectorization support: reference q_(:,j,kcd,1,n) has unaligned access   [ fluxk.f(216,7) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.583
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 11 
         remark #15450: unmasked unaligned unit stride loads: 20 
         remark #15451: unmasked unaligned unit stride stores: 15 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 121 
         remark #15477: vector cost: 22.500 
         remark #15478: estimated potential speedup: 5.090 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 27
      LOOP END

      LOOP BEGIN at fluxk.f(214,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(216,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(219,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(220,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(222,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(225,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(226,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(228,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(231,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(232,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(234,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(237,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(238,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(240,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(213,7) inlined into fluxk.f(131,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(237,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(237,7) ]
         remark #15389: vectorization support: reference t_(:,j,kk) has unaligned access   [ fluxk.f(237,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(231,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(231,7) ]
         remark #15389: vectorization support: reference w_(:,j,kk) has unaligned access   [ fluxk.f(231,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(225,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(225,7) ]
         remark #15389: vectorization support: reference v_(:,j,kk) has unaligned access   [ fluxk.f(225,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(219,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(219,7) ]
         remark #15389: vectorization support: reference u_(:,j,kk) has unaligned access   [ fluxk.f(219,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,j,kk,1,n) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(238,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference t_(:,j,kbd) has unaligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(232,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference w_(:,j,kbd) has unaligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(226,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference v_(:,j,kbd) has unaligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(220,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference u_(:,j,kbd) has unaligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(214,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference q_(:,j,kbd,1,n) has unaligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(240,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference t_(:,j,kcd) has unaligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(234,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference w_(:,j,kcd) has unaligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(228,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference v_(:,j,kcd) has unaligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(222,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference u_(:,j,kcd) has unaligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(216,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(216,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(216,7) ]
         remark #15389: vectorization support: reference q_(:,j,kcd,1,n) has unaligned access   [ fluxk.f(216,7) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
         remark #15305: vectorization support: vector length 2
         remark #15309: vectorization support: normalized vectorization overhead 0.150
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 27
      LOOP END

      LOOP BEGIN at fluxk.f(134,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(144,47) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxk.f(142,48) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.444
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(134,13)
         remark #25045: Fused Loops: ( 134 138 139 140 141 144 )

         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(144,47) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxk.f(142,48) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.581
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 8
      LOOP END

      LOOP BEGIN at fluxk.f(138,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(139,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(140,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(141,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(144,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(134,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(144,47) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxk.f(142,48) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.444
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(198,10) inlined into fluxk.f(131,21)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k+1,3) has unaligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(200,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access   [ fluxk.f(202,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(203,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(203,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k+1,3) has unaligned access   [ fluxk.f(203,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.461
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxk.f(205,10) inlined into fluxk.f(131,21)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k-1,3) has unaligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(207,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access   [ fluxk.f(209,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(210,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(210,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k-1,3) has unaligned access   [ fluxk.f(210,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.461
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxk.f(169,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(169,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(169,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxk.f(170,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(170,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(170,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxk.f(171,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(171,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(171,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxk.f(172,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(172,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(172,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxk.f(173,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(173,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(173,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxk.f(74,18):remark #34051: REGISTER ALLOCATION : [extrapk_.h] fluxk.f:74

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   44[ rax rdx rcx rsi rdi r8-r15 zmm0-zmm7 zmm16-zmm31 k1-k7]
        
    Routine temporaries
        Total         :    1021
            Global    :     337
            Local     :     684
        Regenerable   :      25
        Spilled       :     220
        
    Routine stack
        Variables     :      80 bytes*
            Reads     :       4 [3.98e+00 ~ 0.0%]
            Writes    :      10 [1.00e+01 ~ 0.0%]
        Spills        :    1720 bytes*
            Reads     :     414 [7.48e+03 ~ 13.8%]
            Writes    :     240 [1.27e+03 ~ 2.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: EXTRAPK [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (EXTRAPK) [36/38=94.7%] fluxk.f(74,18)
  -> EXTERN: (121,7) for_alloc_allocatable
  -> EXTERN: (121,7) for_check_mult_overflow64
  -> INLINE: (129,21) EXK2 (isz = 217) (sz = 228)
  -> INLINE: (131,21) EXK4 (isz = 1265) (sz = 1276)
    -> EXTERN: (178,18) __getsp_inlined
    -> EXTERN: (178,18) _alloca
    -> EXTERN: (178,18) _alloca
    -> EXTERN: (178,18) _alloca
    -> EXTERN: (244,7) __resetsp_inlined
  -> EXTERN: (150,7) for_dealloc_allocatable
  -> EXTERN: (153,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxk.f(123,7)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either at Source or due to other Compiler Transformations)
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxk.f(125,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxk.f(169,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(169,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
            remark #15389: vectorization support: reference q_(:,j,kk,1,n) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.000 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at fluxk.f(169,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(170,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(170,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference u_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.000 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at fluxk.f(170,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(171,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(171,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference v_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.000 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at fluxk.f(171,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(172,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(172,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference w_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.000 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at fluxk.f(172,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(173,7) inlined into fluxk.f(129,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxk.f(173,7) inlined into fluxk.f(129,21)
            remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference t_(:,j,kk) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.000 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at fluxk.f(173,7) inlined into fluxk.f(129,21)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxk.f(198,10) inlined into fluxk.f(131,21)
         remark #25045: Fused Loops: ( 198 200 203 )

         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k+1,3) has unaligned access   [ fluxk.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(200,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access   [ fluxk.f(202,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(203,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(203,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k+1,3) has unaligned access   [ fluxk.f(203,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.333
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 4.090 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxk.f(200,10) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(203,10) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(198,10) inlined into fluxk.f(131,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxk.f(205,10) inlined into fluxk.f(131,21)
         remark #25045: Fused Loops: ( 205 207 210 )

         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k-1,3) has unaligned access   [ fluxk.f(207,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k+1,3) has unaligned access   [ fluxk.f(207,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,3) has unaligned access   [ fluxk.f(209,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(210,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,3) has unaligned access   [ fluxk.f(210,10) ]
         remark #15389: vectorization support: reference ds1_(:,j,k-1,3) has unaligned access   [ fluxk.f(210,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.333
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 4.090 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxk.f(207,10) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(210,10) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(205,10) inlined into fluxk.f(131,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxk.f(213,7) inlined into fluxk.f(131,21)
         remark #25045: Fused Loops: ( 213 214 216 219 220 222 225 226 228 231 232 234 237 238 240 )

         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(237,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(237,7) ]
         remark #15389: vectorization support: reference t_(:,j,kk) has unaligned access   [ fluxk.f(237,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(231,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(231,7) ]
         remark #15389: vectorization support: reference w_(:,j,kk) has unaligned access   [ fluxk.f(231,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(225,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(225,7) ]
         remark #15389: vectorization support: reference v_(:,j,kk) has unaligned access   [ fluxk.f(225,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(219,7) ]
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxk.f(219,7) ]
         remark #15389: vectorization support: reference u_(:,j,kk) has unaligned access   [ fluxk.f(219,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,j,kk,1,n) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(238,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference t_(:,j,kbd) has unaligned access   [ fluxk.f(238,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(232,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference w_(:,j,kbd) has unaligned access   [ fluxk.f(232,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(226,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference v_(:,j,kbd) has unaligned access   [ fluxk.f(226,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(220,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference u_(:,j,kbd) has unaligned access   [ fluxk.f(220,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(214,7) ]
         remark #15388: vectorization support: reference af(:) has aligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference q_(:,j,kbd,1,n) has unaligned access   [ fluxk.f(214,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(240,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference t_(:,j,kcd) has unaligned access   [ fluxk.f(240,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(234,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference w_(:,j,kcd) has unaligned access   [ fluxk.f(234,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(228,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference v_(:,j,kcd) has unaligned access   [ fluxk.f(228,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(222,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference u_(:,j,kcd) has unaligned access   [ fluxk.f(222,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(216,7) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(216,7) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxk.f(216,7) ]
         remark #15389: vectorization support: reference q_(:,j,kcd,1,n) has unaligned access   [ fluxk.f(216,7) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.724
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 11 
         remark #15450: unmasked unaligned unit stride loads: 20 
         remark #15451: unmasked unaligned unit stride stores: 15 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 121 
         remark #15477: vector cost: 36.250 
         remark #15478: estimated potential speedup: 3.300 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 27
      LOOP END

      LOOP BEGIN at fluxk.f(214,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(216,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(219,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(220,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(222,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(225,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(226,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(228,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(231,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(232,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(234,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(237,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(238,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(240,7) inlined into fluxk.f(131,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(213,7) inlined into fluxk.f(131,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxk.f(134,13)
      <Peeled loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 8
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at fluxk.f(134,13)
         remark #25045: Fused Loops: ( 134 138 139 140 141 144 )

         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(134,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(134,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxk.f(138,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxk.f(139,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxk.f(140,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(144,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(144,47) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxk.f(141,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxk.f(142,48) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.683
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 8
      LOOP END

      LOOP BEGIN at fluxk.f(138,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(139,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(140,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(141,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(144,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxk.f(134,13)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxk.f(169,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(169,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(169,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxk.f(170,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(170,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(170,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxk.f(171,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(171,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(171,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxk.f(172,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(172,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(172,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxk.f(173,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(173,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxk.f(173,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxk.f(74,18):remark #34051: REGISTER ALLOCATION : [extrapk_.A] fluxk.f:74

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   29[ rax rdx rcx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :     775
            Global    :     265
            Local     :     510
        Regenerable   :      25
        Spilled       :     162
        
    Routine stack
        Variables     :      80 bytes*
            Reads     :       4 [3.98e+00 ~ 0.0%]
            Writes    :      10 [1.00e+01 ~ 0.0%]
        Spills        :    1248 bytes*
            Reads     :     378 [5.90e+03 ~ 18.6%]
            Writes    :     172 [9.28e+02 ~ 2.9%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: EXTRAPJ

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (EXTRAPJ) [37/38=97.4%] fluxj.f(74,18)
  -> EXTERN: (114,7) for_alloc_allocatable
  -> EXTERN: (114,7) for_check_mult_overflow64
  -> INLINE: (122,21) EXJ2 (isz = 217) (sz = 228)
  -> INLINE: (124,21) EXJ4 (isz = 1265) (sz = 1276)
    -> EXTERN: (171,18) __getsp_inlined
    -> EXTERN: (171,18) _alloca
    -> EXTERN: (171,18) _alloca
    -> EXTERN: (171,18) _alloca
    -> EXTERN: (237,7) __resetsp_inlined
  -> EXTERN: (143,7) for_dealloc_allocatable
  -> EXTERN: (146,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxj.f(116,7)
   remark #25095: Loop Interchange not done due to: User Function Inside Loop Nest
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxj.f(117,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxj.f(191,10) inlined into fluxj.f(124,21)
         remark #25045: Fused Loops: ( 191 193 196 )

         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds1_(:,j+1,k,2) has unaligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(193,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access   [ fluxj.f(195,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxj.f(196,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(196,10) ]
         remark #15389: vectorization support: reference ds1_(:,j+1,k,2) has unaligned access   [ fluxj.f(196,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 5.000 
         remark #15478: estimated potential speedup: 7.060 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxj.f(193,10) inlined into fluxj.f(124,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(196,10) inlined into fluxj.f(124,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(198,10) inlined into fluxj.f(124,21)
         remark #25045: Fused Loops: ( 198 200 203 )

         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds1_(:,j-1,k,2) has unaligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(200,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access   [ fluxj.f(202,29) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxj.f(203,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(203,10) ]
         remark #15389: vectorization support: reference ds1_(:,j-1,k,2) has unaligned access   [ fluxj.f(203,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 5.000 
         remark #15478: estimated potential speedup: 7.060 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxj.f(200,10) inlined into fluxj.f(124,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(203,10) inlined into fluxj.f(124,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(206,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jj,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 1.250 
         remark #15478: estimated potential speedup: 4.430 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(206,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jj,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.895
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(207,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jbd,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(207,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jbd,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(209,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jcd,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(209,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jcd,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(212,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 1.250 
         remark #15478: estimated potential speedup: 4.430 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(212,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.895
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(213,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(213,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(215,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(215,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(218,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 1.250 
         remark #15478: estimated potential speedup: 4.430 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(218,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.895
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(219,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(219,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(221,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(221,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(224,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 1.250 
         remark #15478: estimated potential speedup: 4.430 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(224,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.895
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(225,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(225,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(227,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(227,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(230,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 1.250 
         remark #15478: estimated potential speedup: 4.430 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(230,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.895
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(231,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(231,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(233,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(233,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(162,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(162,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
            remark #15389: vectorization support: reference q_(:,jj,k,1,n) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxj.f(162,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
            remark #15389: vectorization support: reference q_(:,jj,k,1,n) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(163,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(163,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference u_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxj.f(163,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference u_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(164,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(164,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference v_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxj.f(164,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference v_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(165,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(165,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference w_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxj.f(165,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference w_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(166,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(166,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference t_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxj.f(166,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference t_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(127,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(138,39) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxj.f(135,46) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.444
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(127,13)
         remark #25045: Fused Loops: ( 127 131 132 133 134 137 )

         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(138,39) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxj.f(135,46) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.581
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 8
      LOOP END

      LOOP BEGIN at fluxj.f(131,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(132,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(133,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(134,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(137,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(127,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(138,39) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxj.f(135,46) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.444
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(191,10) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds1_(:,j+1,k,2) has unaligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(193,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access   [ fluxj.f(195,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxj.f(196,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(196,10) ]
         remark #15389: vectorization support: reference ds1_(:,j+1,k,2) has unaligned access   [ fluxj.f(196,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.461
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(198,10) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds1_(:,j-1,k,2) has unaligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(200,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access   [ fluxj.f(202,29) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxj.f(203,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(203,10) ]
         remark #15389: vectorization support: reference ds1_(:,j-1,k,2) has unaligned access   [ fluxj.f(203,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.461
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxj.f(74,18):remark #34051: REGISTER ALLOCATION : [extrapj_] fluxj.f:74

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdx]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: EXTRAPJ [future_cpu_30]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (EXTRAPJ) [37/38=97.4%] fluxj.f(74,18)
  -> EXTERN: (114,7) for_alloc_allocatable
  -> EXTERN: (114,7) for_check_mult_overflow64
  -> INLINE: (122,21) EXJ2 (isz = 217) (sz = 228)
  -> INLINE: (124,21) EXJ4 (isz = 1265) (sz = 1276)
    -> EXTERN: (171,18) __getsp_inlined
    -> EXTERN: (171,18) _alloca
    -> EXTERN: (171,18) _alloca
    -> EXTERN: (171,18) _alloca
    -> EXTERN: (237,7) __resetsp_inlined
  -> EXTERN: (143,7) for_dealloc_allocatable
  -> EXTERN: (146,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxj.f(116,7)
   remark #25095: Loop Interchange not done due to: User Function Inside Loop Nest
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxj.f(117,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxj.f(191,10) inlined into fluxj.f(124,21)
         remark #25045: Fused Loops: ( 191 193 196 )

         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds1_(:,j+1,k,2) has unaligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(193,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access   [ fluxj.f(195,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxj.f(196,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(196,10) ]
         remark #15389: vectorization support: reference ds1_(:,j+1,k,2) has unaligned access   [ fluxj.f(196,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 5.000 
         remark #15478: estimated potential speedup: 7.060 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxj.f(193,10) inlined into fluxj.f(124,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(196,10) inlined into fluxj.f(124,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(198,10) inlined into fluxj.f(124,21)
         remark #25045: Fused Loops: ( 198 200 203 )

         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds1_(:,j-1,k,2) has unaligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(200,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access   [ fluxj.f(202,29) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxj.f(203,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(203,10) ]
         remark #15389: vectorization support: reference ds1_(:,j-1,k,2) has unaligned access   [ fluxj.f(203,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 5.000 
         remark #15478: estimated potential speedup: 7.060 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxj.f(200,10) inlined into fluxj.f(124,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(203,10) inlined into fluxj.f(124,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(206,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jj,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 1.250 
         remark #15478: estimated potential speedup: 4.430 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(206,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jj,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.895
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(207,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jbd,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(207,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jbd,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(209,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jcd,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(209,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jcd,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(212,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 1.250 
         remark #15478: estimated potential speedup: 4.430 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(212,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.895
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(213,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(213,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(215,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(215,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(218,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 1.250 
         remark #15478: estimated potential speedup: 4.430 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(218,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.895
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(219,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(219,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(221,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(221,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(224,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 1.250 
         remark #15478: estimated potential speedup: 4.430 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(224,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.895
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(225,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(225,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(227,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(227,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(230,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.300
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 1.250 
         remark #15478: estimated potential speedup: 4.430 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(230,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.895
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(231,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(231,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(233,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15399: vectorization support: unroll factor set to 2
         remark #15309: vectorization support: normalized vectorization overhead 0.321
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 1.750 
         remark #15478: estimated potential speedup: 4.740 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(233,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.800
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(162,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(162,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
            remark #15389: vectorization support: reference q_(:,jj,k,1,n) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxj.f(162,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
            remark #15389: vectorization support: reference q_(:,jj,k,1,n) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(163,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(163,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference u_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxj.f(163,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference u_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(164,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(164,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference v_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxj.f(164,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference v_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(165,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(165,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference w_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxj.f(165,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference w_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(166,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(166,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference t_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 8
            remark #15309: vectorization support: normalized vectorization overhead 0.750
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.000 
            remark #15478: estimated potential speedup: 1.600 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=1
         LOOP END

         LOOP BEGIN at fluxj.f(166,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference t_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15335: remainder loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
            remark #15305: vectorization support: vector length 2
            remark #15309: vectorization support: normalized vectorization overhead 1.133
            remark #15442: entire loop may be executed in remainder
            remark #15450: unmasked unaligned unit stride loads: 6 
            remark #15451: unmasked unaligned unit stride stores: 6 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 57 
            remark #15477: vector cost: 9.250 
            remark #15478: estimated potential speedup: 5.690 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(127,13)
      <Peeled loop for vectorization>
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(138,39) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxj.f(135,46) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.444
         remark #15301: PEEL LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(127,13)
         remark #25045: Fused Loops: ( 127 131 132 133 134 137 )

         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(138,39) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxj.f(135,46) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.581
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 8
      LOOP END

      LOOP BEGIN at fluxj.f(131,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(132,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(133,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(134,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(137,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(127,13)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(138,39) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxj.f(135,46) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.444
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(191,10) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds1_(:,j+1,k,2) has unaligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(193,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access   [ fluxj.f(195,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxj.f(196,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(196,10) ]
         remark #15389: vectorization support: reference ds1_(:,j+1,k,2) has unaligned access   [ fluxj.f(196,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.461
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(198,10) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds1_(:,j-1,k,2) has unaligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(200,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access   [ fluxj.f(202,29) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxj.f(203,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(203,10) ]
         remark #15389: vectorization support: reference ds1_(:,j-1,k,2) has unaligned access   [ fluxj.f(203,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 8
         remark #15309: vectorization support: normalized vectorization overhead 0.461
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 9.250 
         remark #15478: estimated potential speedup: 5.690 
         remark #15488: --- end vector cost summary ---
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxj.f(162,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(162,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(162,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxj.f(163,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(163,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(163,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxj.f(164,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(164,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(164,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxj.f(165,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(165,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(165,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxj.f(166,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(166,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(166,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxj.f(74,18):remark #34051: REGISTER ALLOCATION : [extrapj_.h] fluxj.f:74

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   63[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm31 k0-k7]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   41[ rax rdx rcx rsi rdi r8-r15 zmm0-zmm4 zmm16-zmm31 k1-k7]
        
    Routine temporaries
        Total         :    1439
            Global    :     480
            Local     :     959
        Regenerable   :      41
        Spilled       :     185
        
    Routine stack
        Variables     :      80 bytes*
            Reads     :       4 [3.90e+00 ~ 0.0%]
            Writes    :      10 [1.00e+01 ~ 0.0%]
        Spills        :    1448 bytes*
            Reads     :     463 [5.92e+03 ~ 9.0%]
            Writes    :     203 [8.59e+02 ~ 1.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: EXTRAPJ [generic]

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (EXTRAPJ) [37/38=97.4%] fluxj.f(74,18)
  -> EXTERN: (114,7) for_alloc_allocatable
  -> EXTERN: (114,7) for_check_mult_overflow64
  -> INLINE: (122,21) EXJ2 (isz = 217) (sz = 228)
  -> INLINE: (124,21) EXJ4 (isz = 1265) (sz = 1276)
    -> EXTERN: (171,18) __getsp_inlined
    -> EXTERN: (171,18) _alloca
    -> EXTERN: (171,18) _alloca
    -> EXTERN: (171,18) _alloca
    -> EXTERN: (237,7) __resetsp_inlined
  -> EXTERN: (143,7) for_dealloc_allocatable
  -> EXTERN: (146,7) for_dealloc_allocatable


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at fluxj.f(116,7)
   remark #25095: Loop Interchange not done due to: User Function Inside Loop Nest
   remark #25452: Original Order found to be proper, but by a close margin
   remark #15542: loop was not vectorized: inner loop was already vectorized

   LOOP BEGIN at fluxj.f(117,10)
      remark #15542: loop was not vectorized: inner loop was already vectorized

      LOOP BEGIN at fluxj.f(191,10) inlined into fluxj.f(124,21)
         remark #25045: Fused Loops: ( 191 193 196 )

         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds1_(:,j+1,k,2) has unaligned access   [ fluxj.f(193,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(193,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access   [ fluxj.f(195,30) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxj.f(196,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(196,10) ]
         remark #15389: vectorization support: reference ds1_(:,j+1,k,2) has unaligned access   [ fluxj.f(196,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.333
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 4.090 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxj.f(193,10) inlined into fluxj.f(124,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(196,10) inlined into fluxj.f(124,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(191,10) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(198,10) inlined into fluxj.f(124,21)
         remark #25045: Fused Loops: ( 198 200 203 )

         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds1_(:,j-1,k,2) has unaligned access   [ fluxj.f(200,10) ]
         remark #15389: vectorization support: reference ds_(:,j+1,k,2) has unaligned access   [ fluxj.f(200,37) ]
         remark #15389: vectorization support: reference ds1_(:,j,k,2) has unaligned access   [ fluxj.f(202,29) ]
         remark #15388: vectorization support: reference cf(:) has aligned access   [ fluxj.f(203,10) ]
         remark #15389: vectorization support: reference ds_(:,j,k,2) has unaligned access   [ fluxj.f(203,10) ]
         remark #15389: vectorization support: reference ds1_(:,j-1,k,2) has unaligned access   [ fluxj.f(203,29) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.333
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15449: unmasked aligned unit stride stores: 3 
         remark #15450: unmasked unaligned unit stride loads: 4 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 37 
         remark #15477: vector cost: 9.000 
         remark #15478: estimated potential speedup: 4.090 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 4
      LOOP END

      LOOP BEGIN at fluxj.f(200,10) inlined into fluxj.f(124,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(203,10) inlined into fluxj.f(124,21)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(198,10) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(206,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jj,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.188
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 2.750 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(206,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jj,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 2.000
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(206,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(207,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jbd,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.205
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 2.970 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(207,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jbd,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.727
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(207,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(209,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jcd,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.205
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 2.970 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(209,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference q_(:,jcd,k,1,n) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.727
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(209,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(212,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.188
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 2.750 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(212,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 2.000
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(212,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(213,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.205
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 2.970 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(213,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.727
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(213,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(215,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.205
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 2.970 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(215,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference u_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.727
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(215,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(218,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.188
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 2.750 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(218,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 2.000
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(218,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(219,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.205
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 2.970 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(219,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.727
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(219,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(221,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.205
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 2.970 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(221,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference v_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.727
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(221,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(224,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.188
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 2.750 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(224,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 2.000
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(224,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(225,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.205
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 2.970 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(225,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.727
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(225,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(227,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.205
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 2.970 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(227,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference w_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.727
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(227,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(230,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.188
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 1 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 6 
         remark #15477: vector cost: 2.000 
         remark #15478: estimated potential speedup: 2.750 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(230,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference bf(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jj,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 2.000
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(230,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(231,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.205
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 2.970 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(231,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference af(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jbd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.727
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(231,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(233,7) inlined into fluxj.f(124,21)
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15399: vectorization support: unroll factor set to 4
         remark #15309: vectorization support: normalized vectorization overhead 0.205
         remark #15300: LOOP WAS VECTORIZED
         remark #15448: unmasked aligned unit stride loads: 1 
         remark #15450: unmasked unaligned unit stride loads: 2 
         remark #15451: unmasked unaligned unit stride stores: 1 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 9 
         remark #15477: vector cost: 2.750 
         remark #15478: estimated potential speedup: 2.970 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(233,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
         remark #15388: vectorization support: reference cf(:) has aligned access
         remark #15389: vectorization support: reference t_(:,jcd,k) has unaligned access
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 1.727
         remark #15301: REMAINDER LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
      LOOP END

      LOOP BEGIN at fluxj.f(233,7) inlined into fluxj.f(124,21)
      <Remainder loop for vectorization>
      LOOP END

      LOOP BEGIN at fluxj.f(162,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(162,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access
            remark #15389: vectorization support: reference q_(:,jj,k,1,n) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.000 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at fluxj.f(162,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(163,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(163,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference u_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.000 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at fluxj.f(163,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(164,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(164,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference v_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.000 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at fluxj.f(164,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(165,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(165,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference w_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.000 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at fluxj.f(165,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(166,7) inlined into fluxj.f(122,21)
         remark #25399: memcopy generated
         remark #15542: loop was not vectorized: inner loop was already vectorized

         LOOP BEGIN at fluxj.f(166,7) inlined into fluxj.f(122,21)
            remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access
            remark #15389: vectorization support: reference t_(:,jj,k) has unaligned access
            remark #15381: vectorization support: unaligned access used inside loop body
            remark #15305: vectorization support: vector length 4
            remark #15309: vectorization support: normalized vectorization overhead 1.000
            remark #15300: LOOP WAS VECTORIZED
            remark #15450: unmasked unaligned unit stride loads: 1 
            remark #15451: unmasked unaligned unit stride stores: 1 
            remark #15475: --- begin vector cost summary ---
            remark #15476: scalar cost: 4 
            remark #15477: vector cost: 1.500 
            remark #15478: estimated potential speedup: 2.000 
            remark #15488: --- end vector cost summary ---
            remark #25015: Estimate of max trip count of loop=3
         LOOP END

         LOOP BEGIN at fluxj.f(166,7) inlined into fluxj.f(122,21)
         <Remainder loop for vectorization>
            remark #25015: Estimate of max trip count of loop=12
         LOOP END
      LOOP END

      LOOP BEGIN at fluxj.f(127,13)
      <Peeled loop for vectorization>
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 8
         remark #25015: Estimate of max trip count of loop=3
      LOOP END

      LOOP BEGIN at fluxj.f(127,13)
         remark #25045: Fused Loops: ( 127 131 132 133 134 137 )

         remark #25427: Loop Statements Reordered
         remark #15389: vectorization support: reference RWRK(:) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(127,53) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(127,70) ]
         remark #15389: vectorization support: reference qav_(:,j,k,2) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference uav_(:,j,k) has unaligned access   [ fluxj.f(131,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,3) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference vav_(:,j,k) has unaligned access   [ fluxj.f(132,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,4) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference wav_(:,j,k) has unaligned access   [ fluxj.f(133,13) ]
         remark #15389: vectorization support: reference pav_(:,j,k) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(137,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(138,39) ]
         remark #15389: vectorization support: reference qav_(:,j,k,5) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference qav_(:,j,k,1) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference tav_(:,j,k) has unaligned access   [ fluxj.f(134,13) ]
         remark #15389: vectorization support: reference RWRK(:) has unaligned access   [ fluxj.f(135,46) ]
         remark #15381: vectorization support: unaligned access used inside loop body
         remark #15305: vectorization support: vector length 4
         remark #15309: vectorization support: normalized vectorization overhead 0.683
         remark #15301: FUSED LOOP WAS VECTORIZED
         remark #15442: entire loop may be executed in remainder
         remark #15450: unmasked unaligned unit stride loads: 6 
         remark #15451: unmasked unaligned unit stride stores: 6 
         remark #15475: --- begin vector cost summary ---
         remark #15476: scalar cost: 57 
         remark #15477: vector cost: 15.750 
         remark #15478: estimated potential speedup: 3.460 
         remark #15488: --- end vector cost summary ---
         remark #25456: Number of Array Refs Scalar Replaced In Loop: 8
      LOOP END

      LOOP BEGIN at fluxj.f(131,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(132,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(133,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(134,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(137,13)
         remark #25046: Loop lost in Fusion 
      LOOP END

      LOOP BEGIN at fluxj.f(127,13)
      <Remainder loop for vectorization>
      LOOP END
   LOOP END
LOOP END

    Report from: Code generation optimizations [cg]

fluxj.f(162,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(162,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(162,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxj.f(163,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(163,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(163,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxj.f(164,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(164,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(164,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxj.f(165,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(165,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(165,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxj.f(166,7):remark #34014: optimization advice for memcpy: increase the destination's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(166,7):remark #34014: optimization advice for memcpy: increase the source's alignment to 16 (and use __assume_aligned) to speed up library implementation
fluxj.f(166,7):remark #34026: call to memcpy implemented as a call to optimized library version
fluxj.f(74,18):remark #34051: REGISTER ALLOCATION : [extrapj_.A] fluxj.f:74

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   29[ rax rdx rcx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :    1322
            Global    :     466
            Local     :     856
        Regenerable   :      26
        Spilled       :     164
        
    Routine stack
        Variables     :      80 bytes*
            Reads     :       4 [3.90e+00 ~ 0.0%]
            Writes    :      10 [1.00e+01 ~ 0.0%]
        Spills        :    1280 bytes*
            Reads     :     506 [4.86e+03 ~ 10.7%]
            Writes    :     181 [5.91e+02 ~ 1.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: EXTRAPI

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (EXTRAPI) fluxi.f(69,18)

===========================================================================

    Report from: Profile guided optimizations [pgo]



Profile feedback used a statically estimated profile for the following routines:

  File: alloc.f
        ALLOC    [Line     1]

  File: flowio.f
        FLOWIO   [Line     1]

  File: fluxi.f
        FLUXI    [Line     1]
        VISCI    [Line   248]

  File: fluxj.f
        FLUXJ    [Line     1]
        EXTRAPJ  [Line    74]

  File: fluxk.f
        FLUXK    [Line     1]
        EXTRAPK  [Line    74]

  File: grid.f
        GRID     [Line     1]

  File: main.f
        LES3D    [Line     1]
        ANALYSIS [Line   370]

  File: parallel.f
        PARALLEL [Line     1]
        GHOST    [Line   113]
        MAP      [Line   255]
        MPICX    [Line   282]

  File: setbc.f
        SETBC    [Line     1]
        WALLBC..0[Line   433]
        WALLBC..1[Line   433]

  File: setiv.f
        TML      [Line   145]

  File: tmstep.f
        TMSTEP   [Line     1]


  0 out of 20 routine(s) used training profile data for PGO feedback
  0 out of 20 routine(s) were unable to use training profile data for PGO feedback
  0 out of 20 routine(s) were unable to find training profile data for PGO feedback
  20 out of 20 routine(s) used a static estimate profile for PGO feedback




    Report from: Interprocedural optimizations [ipo]

INLINING FOOTNOTES:

<1> The compiler's heuristics indicate that the subprogram is not profitable to 
    inline.  Override this decision by adding "!DIR$ATTRIBUTES FORCEINLINE" 
    to the declaration of the called subprogram, or add "!DIR$ FORCEINLINE" 
    before the call site.

<2> The subprogram is larger than the inliner would normally inline.  Use the
    option -inline-max-size to increase the size of any subprogram that would
    normally be inlined, add "!DIR$ATTRIBUTES FORCEINLINE" to the
    declaration of the called function, or add "!DIR$ FORCEINLINE" before
    the call site.

<3> Inlining this subprogram at this call site would increase the size of the 
    caller more than is currently acceptable. Use the option 
    -inline-max-total-size to increase the size that all subprograms can 
    grow through inlining, add "!DIR$ATTRIBUTES OPTIMIZATION_PARAMETER:
    "INLINE_MAX_PER_ROUTINE"" to the caller, add "!DIR$ATTRIBUTES FORCEINLINE"
    to the declaration of the called subprogram, or add "!DIR$ FORCEINLINE" 
    before the call site.

